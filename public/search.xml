<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[如何在Linux Mint上安装QQ Light]]></title>
      <url>%2F2017%2F04%2F19%2Finstall-qq%2F</url>
      <content type="text"><![CDATA[Brief Description 您的电脑上安装了Linux Mint, 而且不幸的是, 磁盘全部分区给了Mint, 所以您无法装上双系统. 众所周知QQ是OIer国人常用的即时通讯软件, 所以 现在您的任务是在这台电脑上安装上QQ. Algortihm Design 这个坑跌题目坑了我两个晚自习. 辣鸡腾讯 先后尝试了许多解决方案, 最开始的方案是直接安装wine1.6尝试, 但是发现无法写入. 后来又尝试了crossover, winetricks等等….. 最后, 终于安装好了. 安装wine的官方ppa, 详情可以在Google上直接搜索“wine ppa”, 注意wine的版本必须高于2.0! 然后在QQ的官网下载QQ轻聊版, 下载之后安装就可以了. 效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj4625][BeiJing2016]水晶-最小割]]></title>
      <url>%2F2017%2F04%2F01%2Fbzoj4625%2F</url>
      <content type="text"><![CDATA[Brief Description 给定\(n\)个坐标\((x,y,z)\), 每个点有一个价值, 三个点会发生冲突: 形成了一个相邻的三角形 形成了一条相邻的直线, 且夹在中间的那一个点满足\(3|(x+y+z)\). 消灭某些点, 最优化价值, 且不发生任何冲突. Algorithm Design 一些物品之间不可以同时选择的模型可以被看做一个最小割模型, 即在这些点之间拆点或连边来表示冲突, 这样就可以表示成一个最小割模型了. 另外, 为了方便起见, 我们进行坐标变换\((x,y,z) \rightarrow (x-z, y-z)\), 变成二维坐标以方便编写程序. 这样坐标变换之后, 我们可以发现一个规律: 三个点会发生冲突当且仅当\((x+y+z)\pmod m\)的值两两不同: 把这个规律套到二维坐标上处理一下点之间的关系, 这个题就做完了. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;const int maxn = 500500;const int maxm = maxn &lt;&lt; 1;const int defl = 2001;const int maxk = 4109;const int inf = 100000000;int n, s, t, cnt = 1;struct edge &#123; int to, next, cap;&#125; e[maxm &lt;&lt; 1];struct point &#123; int x, y, t, c; bool operator&lt;(const point b) const &#123; return (this-&gt;x &lt; b.x) || (this-&gt;x == b.x &amp;&amp; this-&gt;y &lt; b.y); &#125; bool operator==(const point b) const &#123; return (this-&gt;x == b.x) &amp;&amp; (this-&gt;y == b.y); &#125;&#125; p[maxn];int mat[maxk][maxk], idx[maxk][maxk], ans;int head[maxn], dist[maxn], cur[maxn];void add(int u, int v, int w) &#123; e[++cnt].to = v; e[cnt].next = head[u]; e[cnt].cap = w; head[u] = cnt;&#125;void add_edge(int u, int v, int w) &#123; add(u, v, w); add(v, u, 0);&#125;void bfs(int s, int t) &#123; memset(dist, -1, sizeof(dist)); dist[s] = 0; std::queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to; if (e[i].cap &gt; 0 &amp;&amp; dist[v] == -1) &#123; dist[v] = dist[u] + 1; q.push(v); &#125; &#125; &#125;&#125;int dfs(int s, int t, int flow) &#123; if (s == t) return flow; for (int&amp; i = cur[s]; i; i = e[i].next) &#123; int u = e[i].to; if (e[i].cap &gt; 0 &amp;&amp; dist[u] &gt; dist[s]) &#123; int d = dfs(u, t, std::min(flow, e[i].cap)); if (d) &#123; e[i].cap -= d; e[i ^ 1].cap += d; return d; &#125; &#125; &#125; return 0;&#125;int dinic(int s, int t) &#123; int ans = 0; while (1) &#123; bfs(s, t); if (dist[t] == -1) break; memcpy(cur, head, sizeof(head)); int d; while ((d = dfs(s, t, inf))) ans += d; &#125; return ans;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int x, y, z, c; scanf("%d %d %d %d", &amp;x, &amp;y, &amp;z, &amp;c); x += defl - z, y += defl - z, p[i].t = (x + y) % 3; c *= (x + y) % 3 ? 10 : 11; p[i].x = x, p[i].y = y; mat[x][y] += c; ans += c; &#125; std::sort(p + 1, p + 1 + n); n = std::unique(p + 1, p + 1 + n) - p - 1; s = 0, t = 2 * n + 1; for (int i = 1; i &lt;= n; i++) idx[p[i].x][p[i].y] = i, p[i].c = mat[p[i].x][p[i].y]; for (int i = 1; i &lt;= n; i++) if (p[i].t == 1) add_edge(s, i, p[i].c); else if (p[i].t == 0) add_edge(i, i + n, p[i].c); else add_edge(i, t, p[i].c); for (int i = 1; i &lt;= n; i++) if (!p[i].t) &#123; int x = p[i].x, y = p[i].y; if (idx[x + 1][y]) add_edge(idx[x + 1][y], i, inf); if (idx[x][y + 1]) add_edge(idx[x][y + 1], i, inf); if (idx[x - 1][y - 1]) add_edge(idx[x - 1][y - 1], i, inf); if (idx[x - 1][y]) add_edge(i + n, idx[x - 1][y], inf); if (idx[x][y - 1]) add_edge(i + n, idx[x][y - 1], inf); if (idx[x + 1][y + 1]) add_edge(i + n, idx[x + 1][y + 1], inf); &#125; ans -= dinic(s, t); printf("%d.%d", ans / 10, ans % 10); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3963][WF2011]MachineWorks-斜率优化+CDQ分治]]></title>
      <url>%2F2017%2F04%2F01%2Fbzoj3963%2F</url>
      <content type="text"><![CDATA[Brief Description 你的公司获得了一个厂房\(N\)天的使用权和\(S\)元启动资金, 每天可以作出三种决策: 买入一台新机器 卖出一台旧机器 不做任何决策 每种机器有四个参数\(D, P, R, G\), 你可以在\(D\)天花费费用\(P\)购买这台机器, 这之后的每一天机器可以获得\(G\)的收益, 并且当把这台机器卖掉之后可以获得\(R\)元. 厂房每一时刻只能同时放一台机器. Algorithm Design 我们设\(f(i)\)为第\(i\)天把机器卖掉之后可以持有的最多的钱. 可以得到状态转移方程: \[f(i) = \max(f(i-1), \max_{f(j)&gt;P_j} \{f(j)-P_j+R_j+G_j*(i-j-1)\})\]. 令\(g(i) = f(i)-P_i+R_i-G_iD_i-G_i\), 方程就是: \[f(i) = \max(f(i-1), \max_{f(j)&gt;P_j}\{g(j)+G_j*D_i\})\]. 这个方程是\(1D/1D\)的, 可以使用斜率优化: 对于决策\(j\)和\(k\), 设\(G_j &gt; G_k\), 那么决策\(j\)优当且仅当 \[\frac{g(j)-g(k)}{G_j-G_k} &gt; D_i\]. 然后像bzoj1492那样上CDQ分治就好啦. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#define ll long longconst int maxn = 1e5 + 1e2;inline ll read() &#123; ll x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') f = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; return x * f;&#125;struct node &#123; ll P, R, G, D; ll x, y; int id; node() &#123;&#125; void init() &#123; D = read(); P = read(); R = read(); G = read(); x = G; y = -P + R - D * G - G; &#125; bool operator&lt;(const node b) const &#123; return this-&gt;D &lt; b.D; &#125;&#125; a[maxn], tmp[maxn];ll f[maxn];struct point &#123; ll x, y; point(ll a = 0, ll b = 0) : x(a), y(b) &#123;&#125;&#125;;point operator-(point a, point b) &#123; return point(a.x - b.x, a.y - b.y); &#125;double cross(point a, point b) &#123; return (double)a.x * b.y - (double)a.y * b.x; &#125;int N, D;point p[maxn], st[maxn];ll line(ll x, point &amp;p) &#123; return p.x * x + p.y; &#125;bool cmp(int i, int j) &#123; return a[i].x == a[j].x ? a[i].y + f[a[i].id] &lt; a[j].y + f[a[j].id] : a[i].x &lt; a[j].x;&#125;void solve(int l, int r) &#123; if (l == r) &#123; f[l] = std::max(f[l - 1], f[l]); return; &#125; int mid = (l + r) &gt;&gt; 1; solve(l, mid); int n = 0, top = 0; for (int i = l; i &lt;= mid; i++) if (f[a[i].id] &gt;= a[i].P) p[++n] = point(a[i].x, a[i].y + f[a[i].id]); for (int i = 1; i &lt;= n; i++) &#123; while (top &gt; 1 &amp;&amp; cross(st[top] - st[top - 1], p[i] - st[top - 1]) &gt;= 0) top--; st[++top] = p[i]; &#125; int j = 1; for (int i = mid + 1; i &lt;= r; i++) &#123; while (j &lt; top &amp;&amp; line(a[i].D, st[j + 1]) &gt; line(a[i].D, st[j])) j++; if (j &lt;= top) f[i] = std::max(f[i], line(a[i].D, st[j])); &#125; solve(mid + 1, r); int p = l, q = mid + 1; for (int i = l; i &lt;= r; i++) &#123; if (q &gt; r || (p &lt;= mid &amp;&amp; cmp(p, q))) tmp[i] = a[p++]; else tmp[i] = a[q++]; &#125; for (int i = l; i &lt;= r; i++) a[i] = tmp[i]; return;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif int kase = 0; while (scanf("%d %lld %d", &amp;N, &amp;f[0], &amp;D) != EOF) &#123; if (N == 0 &amp;&amp; f[0] == 0 &amp;&amp; D == 0) return 0; for (int i = 1; i &lt;= N; i++) a[i].init(); a[++N].D = D + 1; std::sort(a + 1, a + 1 + N); for (int i = 1; i &lt;= N; i++) f[i] = 0, a[i].id = i; solve(1, N); printf("Case %d: %lld\n", ++kase, f[N]); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3262]陌上花开-CDQ分治+树状数组]]></title>
      <url>%2F2017%2F04%2F01%2Fbzoj3262%2F</url>
      <content type="text"><![CDATA[Brief Description 有n朵花，每朵花有三个属性：花形(s)、颜色(c)、气味(m)，又三个整数表示。现要对每朵花评级，一朵花的级别是它拥有的美丽能超过的花的数量。定义一朵花A比另一朵花B要美丽，当且仅当Sa&gt;=Sb,Ca&gt;=Cb,Ma&gt;=Mb。显然，两朵花可能有同样的属性。需要统计出评出每个等级的花的数量. Algorithm Design 三维偏序模板题. 这种题目的套路就是: 第一维排序, 第二维CDQ分治, 第三维数据结构. 然后就这个题目而言, 我们先按照第一维排序, 然后在第二维上CDQ分治, 然后在第三维上使用树状数组统计即可. 顺便总结一下CDQ分治的套路. 按照第一维划分问题(split). 如果已经排序了, 这一步可以省略. 123456int p = l, q = mid+1;for(int i = l; i &lt;= r; i++) &#123; if(a[p].x &lt;= mid) tmp[p++] = a[i]; else tmp[q++] = a[i];&#125;for(int i = l; i &lt;= r; i++) a[i] = tmp[i]; 解决左边的子问题, 并且让左边的第二维有序. 1solve(l, mid); 如果右边问题的求解与左边问题无关, 那么直接求解右边的问题, 否则先统计左边问题对于右边问题的影响, 然后再解决右边的问题. 最后合并两个子问题, 使得区间[l,r]在第二维上有序(merge过程). Notice 这个题我居然CE了两次Orz. 写cmp的时候参数不能是引用Orz. Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;const int maxn = 100100;const int maxk = maxn &lt;&lt; 1;struct flower &#123; int x, y, z, cnt, ans; flower() &#123; cnt = 0; ans = 0; &#125;&#125; a[maxn], aa[maxn], tmp[maxn];bool cmp1(flower a, flower b) &#123; return a.x == b.x ? (a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y) : a.x &lt; b.x;&#125;bool cmp2(flower a, flower b) &#123; return a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y; &#125;bool equal(flower a, flower b) &#123; return a.x == b.x &amp;&amp; a.y == b.y &amp;&amp; a.z == b.z;&#125;int read() &#123; int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') f = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; return x * f;&#125;int n, k, m, cur;int bit[maxk], tim[maxk], ans[maxk];void add(int i, int v) &#123; for (; i &lt;= k; i += i &amp; -i) &#123; if (tim[i] == cur) bit[i] += v; else tim[i] = cur, bit[i] = v; &#125;&#125;int query(int i) &#123; int ret = 0; for (; i; i -= i &amp; -i) if (tim[i] == cur) ret += bit[i]; return ret;&#125;void solve(int l, int r) &#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1; solve(l, mid); solve(mid + 1, r); int j = l; cur++; for (int i = mid + 1; i &lt;= r; i++) &#123; while (j &lt;= mid &amp;&amp; a[j].y &lt;= a[i].y) add(a[j].z, a[j].cnt), j++; a[i].ans += query(a[i].z); &#125; int p = l, q = mid + 1; for (int i = l; i &lt;= r; i++) &#123; if ((p &lt;= mid) &amp;&amp; (q &gt; r || cmp2(a[p], a[q]))) tmp[i] = a[p++]; else tmp[i] = a[q++]; &#125; for (int i = l; i &lt;= r; i++) a[i] = tmp[i]; return;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif n = read(); k = read(); for (int i = 1; i &lt;= n; i++) aa[i].x = read(), aa[i].y = read(), aa[i].z = read(); std::sort(aa + 1, aa + 1 + n, cmp1); a[++m] = aa[1]; a[1].cnt = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!equal(a[m], aa[i])) a[++m] = aa[i], a[m].cnt = 1; else a[m].cnt++; &#125; solve(1, m); for (int i = 1; i &lt;= m; i++) ans[a[i].ans + a[i].cnt - 1] += a[i].cnt; for (int i = 0; i &lt; n; i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1176==bzoj2683][Balkan2007]Mokia-树状数组+CDQ分治]]></title>
      <url>%2F2017%2F03%2F31%2Fbzoj1176%2F</url>
      <content type="text"><![CDATA[Brief Description 给定一个\(n \times n\)的矩阵, 您需要支持两种操作: 将位置\((i,j)\)加上一个数\(v\). 统计子矩阵\((x_1, y_1)\)到\((x_2, y_2)\)的和. 数据范围: \(n \leqslant 500,000\). Algorithm Design 这个问题是IOI 2000 Mobile的加强版:Mobile中W≤1000,就可以利用二维树状数组在O(log n)的时间复杂度内维护出操作1)和操作2). 这个问题中W很大,开二维树状数组\(O(W^2)\)的空间显然吃不消,考虑使用动态空间的线段树,最多可能达到\(O(操作次数 \times (log_2W)^2)\) 个节点,也相当大了.考虑使用分治思想来解决问 题: 将 操 作 1 ) 和 操 作 2 ) 按 顺 序 看 成 是 一 个 个 事 件 , 假 设 共 有 To t 个 事 件 ,类似例题一,我们定义Solve(l, r)表示对于每一个Query操作的事件i, 将l ..i-1的Add操作的所有属于i的矩形范围内的数值累加进来.目标是Solve(1, n). 假设计算Solve(L, R),递归Solve(L, Mid),Solve(Mid + 1, r)后,对L .. Mid的所有Add操作的数值累加到Mid + 1 .. R的所有匹配的Query操作的矩形中.后面这个问题等价于:平面中有p个点,q个矩形,每个点有一个权值,求每个矩形内的点的权值之和.这个问题只需要对所有的点以及矩形的左右边界进行排序,用一维树状数组或线段树在O((p+q)log 2 W)的时间复杂度即可维护得 出. 因此问题的总的时间复杂度为\(O(Tot*log_2 Tot*log_2 W)\),不会高于二维线段树的的时间复杂度. 上述这个算法无论是编程复杂度还是空间复杂度都比使用二维线段树优秀,分治思想又一次得到了很好的应用.在这个问题中,利用分治思想我们将一个在线维护的问题转化成一个离线问题,将二维线段树解决的问题降维用一维线段树来解决,使得问题变得更加简单. Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int maxn = 2002005;struct node &#123; int x, y, z, pos, tag, ans; node() &#123;&#125; node(int a, int b, int c, int d, int e, int g) : x(a), y(b), z(c), pos(d), tag(e), ans(g) &#123;&#125;&#125; a[maxn], tmp[maxn];int n, s, m, foo, cur;int bit[maxn], tim[maxn];bool cmp1(node a, node b) &#123; return a.x != b.x ? a.x &lt; b.x : a.y &lt; b.y; &#125;bool cmp2(node a, node b) &#123; return a.pos &lt; b.pos; &#125;inline int lowbit(int i) &#123; return i &amp; -i; &#125;void add(int x, int p) &#123; for (; x &lt;= n; x += lowbit(x)) if (tim[x] == cur) bit[x] += p; else tim[x] = cur, bit[x] = p;&#125;int ask(int x) &#123; int ret = 0; for (; x; x -= lowbit(x)) if (tim[x] == cur) ret += bit[x]; return ret;&#125;void solve(int l, int r) &#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1; int p = l, q = mid + 1; for (int i = l; i &lt;= r; i++) if (a[i].pos &lt;= mid) tmp[p++] = a[i]; else tmp[q++] = a[i]; for (int i = l; i &lt;= r; i++) a[i] = tmp[i]; solve(l, mid); int j = l; cur++; for (int i = mid + 1; i &lt;= r; i++) &#123; while (j &lt;= mid &amp;&amp; a[j].x &lt;= a[i].x) &#123; if (a[j].tag == 1) add(a[j].y, a[j].z); ++j; &#125; if (a[i].tag == 2) a[i].ans += ask(a[i].y); &#125; solve(mid + 1, r); p = l; q = mid + 1; for (int i = l; i &lt;= r; i++) if ((a[p].x &lt; a[q].x || q &gt; r) &amp;&amp; p &lt;= mid) tmp[i] = a[p++]; else tmp[i] = a[q++]; for (int i = l; i &lt;= r; i++) a[i] = tmp[i];&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d", &amp;n); while (1) &#123; scanf("%d", &amp;foo); if (foo == 3) break; if (foo == 1) &#123; int a, b, c; scanf("%d %d %d", &amp;a, &amp;b, &amp;c); m++; ::a[m] = node(a, b, c, m, 1, 0); &#125; else &#123; int a, b, c, d; scanf("%d %d %d %d", &amp;a, &amp;b, &amp;c, &amp;d); m++; ::a[m] = node(a - 1, d, 0, m, 2, 0); m++; ::a[m] = node(c, b - 1, 0, m, 2, 0); m++; ::a[m] = node(a - 1, b - 1, 0, m, 2, 0); m++; ::a[m] = node(c, d, 0, m, 2, 0); &#125; &#125; std::sort(a + 1, a + m + 1, cmp1); solve(1, m); std::sort(a + 1, a + m + 1, cmp2); for (int i = 1; i &lt;= m; i++) &#123; if (a[i].tag == 1) continue; int ans = 0; ans -= a[i++].ans; ans -= a[i++].ans; ans += a[i++].ans; ans += a[i].ans; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1492][NOI2007]货币兑换Cash-斜率优化+CDQ分治]]></title>
      <url>%2F2017%2F03%2F31%2Fbzoj1492%2F</url>
      <content type="text"><![CDATA[Brief Description 某交易所发行A券和B券两种金券, 每天有两种决策: 卖出金券: 顾客提供一个[0,100]的实数\(k\), 将k%的A券和k%的B券按照当天汇率兑换. 买入金券, 顾客提供\(v\)元人民币, 兑换价值\(v\)元的金券, A券和B券的比例为\(Rate_k\). 开始有\(S\)元, 求\(N\)天后的最大收益. Algorithm Design 我们不妨设\(f(i)\)为第i天的钱全部兑换, 可以获得多少A券, 可以知道, 一定有一种最优决策, 每次都是全买全卖的, 所以由此可以设计出方程: \[f(i) = \max_{j} \{f(j)*A_i+\frac{f(j)}{Rate_j}*B_i\} * \frac{Rate_i}{A_i*Rate_i+B_i}\]. 12345678910111213141516171819202122232425#include &lt;cstdio&gt;const int maxn = 100100;double f[maxn], A[maxn], B[maxn], Rate[maxn];int N;double S, ans;double m2a(double x, int i) &#123; return x * (Rate[i]) / (A[i] * Rate[i] + B[i]); &#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d %lf", &amp;N, &amp;S); for (int i = 1; i &lt;= N; i++) scanf("%lf %lf %lf", &amp;A[i], &amp;B[i], &amp;Rate[i]); f[1] = S * (Rate[1]) / (A[1] * Rate[1] + B[1]); ans = S; // printf("%.3lf ", f[1]); for (int i = 2; i &lt;= N; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; double x = f[j] * A[i] + (f[j] / Rate[j]) * B[i]; if (x &gt; ans) ans = x; &#125; f[i] = m2a(ans, i); // printf("%.3lf ", f[i]); &#125; printf("%.3f", ans);&#125; 然后, 这个方程是1D/1D的, 显然可以用斜率优化: 设\(g(i) = \frac{f(i)}{Rate_i}\), 那么对于状态\(i\), 决策\(k\)比决策\(j\)优当且仅当: \[ \frac{g(k)-g(j)}{f(k)-f(j)} &gt; -\frac{A_i}{B_i} \]. 通过打一些小的数据的表, 我们可以发现, \(f(i)\)是单调增的, 我们就可以考虑使用这个式子斜率优化. 具体地, 我们有两种方法: 平衡树: 使用splay维护这个上凸壳, 然后每次二分查找. CDQ分治. 我们选择代码量相对少的CDQ分治. 沿用CDQ分治在DP问题上的常用套路: 123456def solve(l, r): split(); solve(l, mid) [l, mid] -&gt; [mid+1, r] solve(mid+1, r) merge() 把操作的时间看作第一维, f看作第二维, k看作第三维就好了. Summary 分治思想-&gt;只考虑跨立作用 段内影响忽略不计-&gt;问题离线化 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;const int maxn = 100100;const double eps = 1e-9;const double inf = 1e20;struct day &#123; double A, B, Rate, K, f, g; int id; bool operator&lt;(const day &amp;b) const &#123; return K &gt; b.K; &#125;&#125; a[maxn], tmp[maxn];int n, top;double S, d[maxn];int st[maxn];double getk(int i, int j) &#123; if (fabs(a[i].f - a[j].f) &lt; eps) return inf; return (a[i].g - a[j].g) / (a[i].f - a[j].f);&#125;bool cmp(day &amp;a, day &amp;b) &#123; return a.f &lt; b.f || (fabs(a.f - b.f) &lt; eps &amp;&amp; a.g &lt; b.g);&#125;void solve(int l, int r) &#123; if (l == r) &#123; d[l] = std::max(d[l], d[l - 1]); a[l].g = d[l] / (a[l].A * a[l].Rate + a[l].B); a[l].f = a[l].g * a[l].Rate; return; &#125; int mid = (l + r) &gt;&gt; 1, p = l, q = mid + 1; for (int i = l; i &lt;= r; i++) &#123; if (a[i].id &lt;= mid) tmp[p++] = a[i]; else tmp[q++] = a[i]; &#125; for (int i = l; i &lt;= r; i++) a[i] = tmp[i]; solve(l, mid); top = 0; for (int i = l; i &lt;= mid; i++) &#123; while (top &gt; 1 &amp;&amp; getk(st[top - 1], st[top]) &lt; getk(st[top - 1], i) + eps) top--; st[++top] = i; &#125; int j = 1; for (int i = mid + 1; i &lt;= r; i++) &#123; while (j &lt; top &amp;&amp; getk(st[j], st[j + 1]) + eps &gt; a[i].K) j++; d[a[i].id] = std::max(d[a[i].id], a[st[j]].f * a[i].A + a[st[j]].g * a[i].B); &#125; solve(mid + 1, r); p = l; q = mid + 1; for (int i = l; i &lt;= r; i++) &#123; if (p &lt;= mid &amp;&amp; (q &gt; r || cmp(a[p], a[q]))) tmp[i] = a[p++]; else tmp[i] = a[q++]; &#125; for (int i = l; i &lt;= r; i++) a[i] = tmp[i];&#125;int main() &#123; /* freopen("cash.in", "r", stdin); freopen("cash.out", "w", stdout);*/ scanf("%d %lf", &amp;n, &amp;d[0]); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lf %lf %lf", &amp;a[i].A, &amp;a[i].B, &amp;a[i].Rate); a[i].K = -(a[i].A / a[i].B); a[i].id = i; &#125; std::sort(a + 1, a + 1 + n); solve(1, n); printf("%.3lf", d[n]);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2705][SDOI2012]Longge的问题-欧拉函数]]></title>
      <url>%2F2017%2F03%2F31%2Fbzoj2705%2F</url>
      <content type="text"><![CDATA[Brief Description 计算\(\sum_{i=1}^n gcd(i,n)\). Algorithm Design 令\(f[x] = \sum_{i=1}^n [gcd(i, n) =x]\), 那么问题就是计算\(\sum_{i|n}{i*f(i)}\). 那么\(f(x) = \sum_{i=1}^n [gcd(i,n)=x] =\sum_{i=1}^n[gcd(i/x, n/x)=1]=\varphi(\frac nx)\), 那么我们只需要算出\(\sum_{i|n}\frac ni*\varphi(i)\)就好了. Code 1234567891011121314151617181920212223#include &lt;cstdio&gt;#define ll long longll n, ans;ll phi(ll x) &#123; int ans = x; for (int i = 2; i * i &lt;= x; i++) if (x % i == 0) &#123; ans = ans / i * (i - 1); while (x % i == 0) x /= i; &#125; if (x &gt; 1) ans = ans / x * (x - 1); return ans;&#125;int main() &#123; scanf("%lld", &amp;n); for (int i = 1; i * i &lt;= n; i++) if (n % i == 0) &#123; ans += 1ll * i * phi(n / i); if (i * i &lt; n) ans += 1ll * (n / i) * phi(i); &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2388]旅行规划-分块+凸包]]></title>
      <url>%2F2017%2F03%2F30%2Fbzoj2388%2F</url>
      <content type="text"><![CDATA[Brief Description 给定一个数列, 您需要支持两种操作: 区间同加一个数. 询问\(\max_{i=l}^r \sum_{j=1}^i a[j]\). 即动态维护最大前缀和. Algorithm Design 记\(s[j] = \sum_{i=1}^j a[j]\), 考察分块做法. 对于修改操作, 考察对于[l,r]同加v对于s[i]的贡献: 当\(i \in [l,r]\)时, \(s[i] = s[i] + v * (i-l+1)\). 当\(i &gt; r\)时, \(s[i] = s[i] + v * (r-l+1)\). 对于一个以\(i\)开头的块, 我们相当于是加了一个首相为\(v*(i-l+1)\), 公差为\(v\)的等差序列 我们对于每一个块维护两个标记\(a, b\). 对于块中的每一个位置\(i\), 它的实际值为\(i \times a +b + s_i\). 修改的时候, 对于两边的块暴力修改, 对于整块打标记, 然后重构凸包. 对于查询操作. 对于两边的块, 暴力统计 对于中间的块, 我们在每个块中维护一个上凸包, 这样进行二分查找. 考察凸包的维护方法, 把每个点变成二维的点:\((i, i*a+b+s_i)\), 那么对于\(i&lt;j\)的两个点, 如果我们有\(\frac{s_j-s_i}{i-j} &gt; a\), 那么\(j\)优于\(i\). Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#define ll long longconst ll maxn = 100000 + 100;const ll maxm = 400;const ll inf = 1ll &lt;&lt; 62;ll n, m, s[maxn], block, blockm, belong[maxn];ll a[maxm], b[maxm], q[maxn], R[maxm];int left(int x) &#123; return (x - 1) * block + 1; &#125;int right(int x) &#123; return std::min(x * block, n); &#125;void up(ll&amp; x, ll v) &#123; if (v &gt; x) x = v;&#125;inline double getk(ll i, ll j) &#123; if (i == j) return inf; return (double)(s[j] - s[i]) / (double)(i - j);&#125; //下凸包inline double getprev(ll i) &#123; return getk(q[i - 1], q[i]); &#125;inline ll value(ll x) &#123; return a[belong[x]] * x + b[belong[x]] + s[x]; &#125;void reset(ll x) &#123; ll l = left(x), r = right(x), t = l; q[t] = l; for (ll i = l + 1; i &lt;= r; q[++t] = i++) while (t &gt; l &amp;&amp; getprev(t) &gt;= getk(q[t], i)) t--; R[x] = t;&#125;void change(ll l, ll r, ll k, ll b) &#123; if (belong[l] == belong[r]) &#123; for (ll i = l; i &lt;= r; i++) s[i] += k * i + b; reset(belong[l]); return; &#125; for (ll i = belong[l] + 1; i &lt; belong[r]; i++) a[i] += k, ::b[i] += b; for (ll i = l; i &lt;= right(belong[l]); i++) s[i] += k * i + b; reset(belong[l]); for (ll i = left(belong[r]); i &lt;= r; i++) s[i] += k * i + b; reset(belong[r]);&#125;void modify(ll l, ll r, ll v) &#123; change(l, r, v, v * (1 - l)); if (r &lt; n) change(r + 1, n, 0, v * (r - l + 1));&#125;ll find(ll x) &#123; ll ans = left(x); ll l = ans + 1, r = R[x]; while (l &lt;= r) &#123; ll mid = (l + r) &gt;&gt; 1; if (getprev(mid) &lt; a[x]) &#123; l = (ans = mid) + 1; &#125; else r = mid - 1; &#125; return value(q[ans]);&#125;ll query(ll l, ll r) &#123; ll ans = -inf; if (belong[l] == belong[r]) &#123; for (ll i = l; i &lt;= r; i++) up(ans, value(i)); return ans; &#125; for (ll i = l; i &lt;= right(belong[l]); i++) up(ans, value(i)); for (ll i = left(belong[r]); i &lt;= r; i++) up(ans, value(i)); for (ll i = belong[l] + 1; i &lt; belong[r]; i++) up(ans, find(i)); return ans;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%lld", &amp;n); block = (ll)(sqrt(n) + 0.1); blockm = n / block + ((n % block) ? 1 : 0); for (ll i = 1; i &lt;= n; i++) scanf("%lld", &amp;s[i]); for (ll i = 1; i &lt;= n; i++) &#123; belong[i] = (i - 1) / block + 1; s[i] += s[i - 1]; &#125; for (ll i = 1; i &lt;= blockm; i++) reset(i); scanf("%lld", &amp;m); while (m--) &#123; ll opt, x, y; scanf("%lld %lld %lld", &amp;opt, &amp;x, &amp;y); if (opt) printf("%lld\n", query(x, y)); else &#123; ll k; scanf("%lld", &amp;k); modify(x, y, k); &#125; // for (ll i = 1; i &lt;= n; i++) printf("%lld ", value(i)); // prllf("\n"); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2453==bzoj2120]维护队列-分块]]></title>
      <url>%2F2017%2F03%2F30%2Fbzoj2453%2F</url>
      <content type="text"><![CDATA[Brief Description 给定一个数列, 您需要支援两种操作: 查询区间[l,r]中有多少不同的数字 更改一个数字. Algorithm Design 考察暴力做法. 记录pre[i]为i之前的最后一个与a[i]数字相同的位置, 那么对于查询操作, 就等于说是: \[ \sum_{i = l}^r [pre[i] &lt; l]\]. 暴力的想法就是: 对于查询操作, 暴力查询这个区间, 复杂度O(n) 对于修改操作, 重新统计pre, 复杂度O(n) 对于本题而言, 这个复杂度仍然不能接受, 我们考虑分块. 对于查询操作, 我们分成\(O(\sqrt n)\)个区间, 每个区间\(O(log \sqrt n)\)时间统计, 复杂度\(O(\sqrt n log \sqrt n)\). 对于修改操作, 我们重新统计, 并对需要重新排序的块重新排序, 那么每次修改一个点的时候, 最多要重新排序的块的个数是\(O(\sqrt n)\), 这样复杂度是\(O(n log \sqrt n)\).因为修改不超过1000次, 所以这个算法可以通过. Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;const int maxn = 10100;int N, M, pre1[maxn], pre2[maxn], a[maxn], belong[maxn], block, blockm, last[1000010];void reset(int x) &#123; int l = (x - 1) * block + 1, r = std::min(x * block, N); for (int i = l; i &lt;= r; i++) pre2[i] = pre1[i]; std::sort(pre2 + l, pre2 + r + 1);&#125;void change(int x, int v) &#123; for (int i = 1; i &lt;= N; i++) last[a[i]] = 0; a[x] = v; for (int i = 1; i &lt;= N; i++) &#123; int t = pre1[i]; pre1[i] = last[a[i]]; if (t != pre1[i]) reset(belong[i]); last[a[i]] = i; &#125;&#125;int find(int i, int x) &#123; int l = block * (i - 1) + 1, r = std::min(block * i, N); int fir = l; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (pre2[mid] &lt; x) l = mid + 1; else r = mid - 1; &#125; return l - fir;&#125;int ask(int l, int r) &#123; int ans = 0; if (belong[l] == belong[r]) &#123; for (int i = l; i &lt;= r; i++) ans += pre1[i] &lt; l; return ans; &#125; for (int i = l; i &lt;= block * belong[l]; i++) ans += pre1[i] &lt; l; for (int i = block * (belong[r] - 1) + 1; i &lt;= r; i++) ans += pre1[i] &lt; l; for (int i = belong[l] + 1; i &lt; belong[r]; i++) ans += find(i, l); return ans;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d %d", &amp;N, &amp;M); block = sqrt(N) + 1; blockm = N / block; if (N % block) blockm++; for (int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;a[i]); belong[i] = ((i - 1) / block) + 1; &#125; for (int i = 1; i &lt;= N; i++) &#123; pre1[i] = last[a[i]]; last[a[i]] = i; &#125; for (int i = 1; i &lt;= blockm; i++) reset(i); while (M--) &#123; char opt[5]; int x, y; scanf("%s %d %d", opt, &amp;x, &amp;y); if (opt[0] == 'Q') &#123; printf("%d\n", ask(x, y)); &#125; else &#123; change(x, y); &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3992][SDOI2015]序列统计-离散对数+生成函数+NTT]]></title>
      <url>%2F2017%2F03%2F29%2Fbzoj3992%2F</url>
      <content type="text"><![CDATA[Brief Description 有一个集合\(S\)，里面的元素都是小于\(M\)的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为\(N\)的数列，数列中的每个数都属于集合\(S\)。给定整数x，求所有可以生成出的，且满足数列中所有数的乘积mod M的值等于x的不同的数列的有多少个。两个数列{Ai}和{Bi}不同，当且仅当至少存在一个整数i，满足Ai≠Bi。答案对1004535809取模. Algorithm Design 不难想出一个动态规划算法: 设\(f[i][j]\)为目前已经生成了第\(i\)个数字, 他们的乘积与\(j\)同余的数列方案数. 方程容易写出:\(f[i][j] = \sum f[i-1][j&#39;]\), 显然这个方程可以使用矩阵乘法优化, 这个算法复杂度是\(O(m^3 log_2 n)\), 可以得到30分. 考察优化. 我们观察模数, 发现这个模数非常套路, 因为这个模数就是\(479*2^{21} + 1\). 这个数字非常适合进行快速数论变换. 然后我们考察怎么套用模板: 取\(M\)的原根\(g\), 求每个数字的指标(离散对数), 这样加法就变成了乘法, 然后构造生成函数, 进行多项式快速幂就好了. 复杂度\(O(mlog_2n)\), 可以拿到满分. Code(矩阵乘法优化动态规划, 30分) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstring&gt;#define mod 1004535809#define ll long longconst int maxm = 102;struct Matrix &#123; ll a[maxm][maxm]; int n, m; Matrix(int i = 0, int j = 0) : n(i), m(j) &#123; memset(a, 0, sizeof(a)); &#125;&#125;;Matrix operator*(Matrix A, Matrix B) &#123; Matrix C = Matrix(A.n, B.m); for (int i = 0; i &lt; A.n; i++) &#123; for (int j = 0; j &lt; B.m; j++) &#123; for (int k = 0; k &lt; A.m; k++) &#123; C.a[i][j] = (C.a[i][j] + (A.a[i][k] * B.a[k][j]) % mod) % mod; &#125; &#125; &#125; return C;&#125;Matrix pow(Matrix A, int n) &#123; Matrix ans = Matrix(A.n, A.n); for (int i = 0; i &lt; ans.n; i++) ans.a[i][i] = 1; while (n) &#123; if (n &amp; 1) ans = ans * A; n &gt;&gt;= 1; A = A * A; &#125; return ans;&#125;Matrix A, B, C;int N, M, x, S, a[maxm];int main() &#123; freopen("sdoi2015_sequence.in", "r", stdin); freopen("sdoi2015_sequence.out", "w", stdout); scanf("%d %d %d %d", &amp;N, &amp;M, &amp;x, &amp;S); for (int i = 1; i &lt;= S; i++) &#123; scanf("%d", &amp;a[i]); a[i] %= M; &#125; A = Matrix(M, M), B = Matrix(M, 1), C = Matrix(M, 1); for (int i = 0; i &lt; M; i++) &#123; for (int j = 1; j &lt;= S; j++) &#123; int tmp = (i * a[j]) % M; A.a[tmp][i]++; &#125; &#125; for (int i = 1; i &lt;= S; i++) B.a[a[i]][0]++; C = pow(A, N - 1); /*for (int i = 0; i &lt; C.n; i++) &#123; for (int j = 0; j &lt; C.m; j++) printf("%lld ", B.a[i][j]); printf("\n"); &#125;*/ C = C * B; printf("%lld\n", C.a[x % M][0] % mod); return 0;&#125; Code(构造生成函数, 快速数论变换) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define ll long longconst int maxm = 50000;const int P = 1004535809;const int G = 3;int R[maxm], L, ind[maxm];int N, M, x, Sb, n;ll s[2], w[2][maxm], g;ll qpow(ll a, ll b, ll p) &#123; ll ans = 1; for (; b; b &gt;&gt;= 1, a = (a * a) % p) if (b &amp; 1) ans = (ans * a) % p; return ans;&#125;ll inv(ll x, ll p) &#123; return qpow(x, p - 2, p); &#125;void ntt(ll* a, int f) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; R[i]) std::swap(a[i], a[R[i]]); for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; for (int j = 0, l = n / (i &lt;&lt; 1); j &lt; n; j += (i &lt;&lt; 1)) &#123; for (int k = 0, t = 0; k &lt; i; k++, t += l) &#123; ll x = a[j + k], y = (1ll * w[f][t] * a[j + k + i]) % P; a[j + k] = (x + y) % P; a[j + k + i] = (x - y + P) % P; &#125; &#125; &#125; if (f) for (int i = 0; i &lt; n; i++) (a[i] *= inv(n, P)) %= P;&#125;struct Poly &#123; ll a[maxm]; Poly() &#123; memset(a, 0, sizeof(a)); &#125; Poly(int x) &#123; memset(a, 0, sizeof(a)); a[0] = x; &#125; ll&amp; operator[](int i) &#123; return a[i]; &#125; Poly operator*(const Poly&amp; b) &#123; ll A[maxm], B[maxm]; Poly C; memcpy(A, this-&gt;a, sizeof(this-&gt;a)); memcpy(B, b.a, sizeof(b.a)); ntt(A, 0); ntt(B, 0); for (int i = 0; i &lt; n; i++) A[i] = (A[i] * B[i] * 1ll) % P; ntt(A, 1); for (int i = n - 1; i &gt;= M - 1; i--) (A[i - M + 1] += A[i]) %= P, A[i] = 0; memcpy(C.a, A, sizeof(A)); return C; &#125;&#125; a;Poly qqpow(Poly a, int n) &#123; Poly ans(1); for (; n; n &gt;&gt;= 1, a = a * a) if (n &amp; 1) ans = ans * a; return ans;&#125;bool check(int x, int M) &#123; for (int i = 2; i * i &lt; M; i++) if ((M - 1) % i == 0) if (qpow(x, (M - 1) / i, M) == 1 || qpow(x, i, M) == 1) return false; return true;&#125;int getroot(int x) &#123; for (int g = 2;; g++) if (qpow(g, x - 1, x) == 1 &amp;&amp; check(g, x)) return g;&#125;void init() &#123; s[0] = qpow(G, (ll)((P - 1) / n), P); s[1] = inv(s[0], P); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; 2; j++) w[j][i] = i ? w[j][i - 1] * s[j] % P : 1; for (int i = 0; i &lt; n; i++) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1));&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d %d %d %d", &amp;N, &amp;M, &amp;x, &amp;Sb); g = getroot(M); for (n = 1; n &lt; (M + M - 2); n &lt;&lt;= 1) L++; for (int i = 0, xx = 1; i &lt; M - 1; i++, (xx *= g) %= M) ind[xx] = i; // ind[0] = 1; for (int i = 0; i &lt; Sb; i++) &#123; int x; scanf("%d", &amp;x); if (x != 0) a[ind[x]] = 1; &#125; init(); Poly ans = qqpow(a, N); printf("%lld\n", ans[ind[x]]);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[离散对数与原根学习笔记]]></title>
      <url>%2F2017%2F03%2F28%2Fdiscrete-logarithm-and-primitive-root%2F</url>
      <content type="text"><![CDATA[定义 缩系 模\(m\)意义下与\(m\)互质的元素组成缩系. 缩系中任意两个元素的乘积还在缩系中. 缩系的大小是\(\varphi(m)\). 阶 满足\(x^r \equiv 1\pmod m\)的最小整数\(r\)被称为\(x\)的阶, 记作\(ord_m(x)\). 如果\(x\)和\(m\)互质且\(m &gt; 0\), 那么正整数\(r\)是\(x^r\equiv 1\)的一个解当且仅当\(ord_m x|r\). 如果\(x\)和\(m\)互质且\(m&gt;0\), 那么\(ord_m x|\varphi(m)\). 计算阶的\(O(log^2n)\)算法: 首先分解\(\varphi(n)\), 令\(\varphi(n) = \prod p_i^{k_i}\). 依次考察每一个质因子, 尝试一个一个地从答案中除去, 直到\(x^{ans} \not \equiv 1\), 然后把之前除去的质因子加到答案中. 因为要考虑\(O(log n)\)个因子, 每个因子使用\(O(logn)\)的时间快速幂验证, 也要考虑大数分解的复杂度, 总的复杂度就是\(O(log^2 n + \varphi (n) ^ {\frac 14})\). 如果\(x\)和\(m\)互质且\(m&gt;0\), 那么:\(x^i \equiv x^j \pmod m \Leftrightarrow i\equiv j \pmod {ord_m x}\). 原根 如果\(r\)和\(n\)是互质且\(n&gt;0\), 那么当\(ord_n a = \varphi(n)\)时, 称\(r\)是模\(n\)的原根. 一个整数当它为2, 4, \(p^t\), \(2p^t\)的时候才有原根, 这里\(p\)为奇素数且\(t\)为正整数. 令\(ord_n(a)=t\), 那么\(ord_n(a^k) = \frac t{(t, k)}\). 令\(r\)为模\(m\)的原根, 哪么\(r^k\)是模\(m\)的原根当且仅当\((k, \varphi(m))=1\). 证明: \(ord_m r^k = \frac{ord_m r}{(ord_m r, k)} =\frac{\varphi(m)}{(\varphi(m), k)}\) 由上面的推论可以证明: 如果正整数\(n\)有一个原根, 那么它一共有\(\varphi(\varphi(n))\)个不同的原根. 计算原根的算法: 由上面计算阶的算法, 我们可以推得计算模\(m\)的一个原根的算法. 首先, \(ind_m g = \varphi(m) \pmod m\) 那么我们从小到大枚举所有与\(m\)互质的数, 那么我们令\(\varphi(m) = \prod_{\omega(i)} p_i^{k_i}\), 根据原根的定义, 不难知道, 对于\(\varphi(m)\)的任何一个约数\(q\), \(g^q \not \equiv 1\), 又因为阶的性质, 我们可以得到一个更紧的条件: 对于任何一个\(\frac{\varphi(m)}{p_i} = q\), \(g^q \not \equiv 1\). 复杂度为\(O(nlog^2n)\). 虽然上界非常可怕, 但是实际上这个上界是非常非常松的. 计算原根的模板(51nod 1135): 1234567891011121314151617181920212223#include &lt;cstdio&gt;#define ll long longint n;ll pow(ll a, ll b, ll n) &#123; ll ans = 1; for (; b; b &gt;&gt;= 1, a = (a * a) % n) if (b &amp; 1) ans = (ans * a) % n; return ans;&#125;bool check(int i) &#123; for (int j = 2; j * j &lt; n; j++) if ((n - 1) % j == 0) if (pow(i, (n - 1) / j, n) == 1 || pow(i, j, n) == 1) return false; return true;&#125;int proot() &#123; for (int i = 2;; i++) if (pow(i, n - 1, n) == 1 &amp;&amp; check(i)) return i;&#125;int main() &#123; scanf("%d", &amp;n); printf("%d", proot());&#125; 离散对数 若有原根\(g\), 则元素\(x \equiv g^i \pmod m\)关于\(g\)的离散对数(指标为)\(ind_g(x) = i \pmod{\varphi(m)}\). 离散对数满足很多对数的性质. 指标: 以原根为底的离散对数, 记作\(ind_{m,g}(x)\), 当模数固定时, 省略下标\(m\). 根据阶的结论, 有:\(ord_m x = \frac {\varphi(m)}{(\varphi(m), ind_g(x))}\). 若缩系没有原根, 那么模\(m\)缩系可以表示成一系列有原根的缩系的笛卡尔积. 概述 考虑解方程\(A^B\equiv C \pmod M\): 已知\(ABM\)求\(C\)是模幂问题. 已知\(ACM\)求\(B\)是离散对数问题. 已知\(BCM\)求\(A\)是高次剩余问题. 已知\[ABC\]求\(M\)是大数分解问题. 模幂问题 快速幂. 离散对数问题 解方程\(A^B \equiv C \pmod M\), 已知\(ACM\)求\(B\). 不妨设一个原根是\(g\), 那么问题等价于\(ind_g(A)\times B \equiv ind_g(C) \pmod {\varphi(m)}\). 设\(r=(ind_g(A), \varphi(m))=\frac{\varphi(M)}{ord_M(A)}\), 问题转化为\(\frac{ind_g(A)}r \times B \equiv \frac{ind_g(C)}r\), 得到\(B \equiv \frac{ind_g(C)}r (\frac{ind_g(A)}r)^{-1} \pmod{\frac{\varphi(M)}{r}}\). 大步小步算法: 可以看我的这篇文章 Pollard’s rho Algorithm for Logarithms 把集合\(G=\{A^i\ mod\ M|i \in \mathbb{N}\}\)分为三个部分\(S_0, S_1, S_2\), 并保证\(1 \not \in S_1\). 生成一系列\(x=A^iC^j\)直到某个\(x\)找到了另一种表示方法\(x=A^uC^v\), 则\((i-u)\equiv B(j-v) \pmod {|G|}\). 使用Floyd’s Cycle-Finding Algorithm, 找环. 期望复杂度\(O(\sqrt{\frac {\pi n}2})\). 扩展大步小步算法(Extended Baby-step Giant-step Algorithm) 枚举\(\delta = 0, 1, \cdots\), 把方程化为\(A^{B-\delta}A^{\delta} \equiv C \pmod M\), 直到\((A^{\delta}, M&#39;)=1\) , 消去公因子, 变成\(A^{B-\delta}A&#39; \equiv C&#39; \pmod {M&#39;}\). 如果在上面的过程中\(C&#39;=A&#39;\), 那么就找到了一个解. 执行完上面的过程之后, 就变成了要解方程\(\frac{A}{A^{\delta}}A^{B-\delta}\equiv \frac{C}{A^{\delta}} \pmod {\frac {M}{A^{\delta}}}\), 令\(M&#39; = \frac{M}{A^{\delta}}, C&#39;=\frac{C}{A^{\delta}}(\frac{A}{A^{\delta}})^{-1}\), 那么方程就是\(A^{B&#39;} \equiv C&#39; \pmod {M&#39;}\), 执行类似BSGS的过程就好了. 复杂度\(O(log_2 m +\sqrt m)\). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//spoj-Power Modulo Inverted#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;map&gt;#define ll long longint a, c, m;ll gcd(ll a, ll b) &#123; return b ? gcd(b, a % b) : a; &#125;ll qpow(ll a, ll b, ll p) &#123; ll ans = 1; for (; b; b &gt;&gt;= 1, a = (a * a) % p) if (b &amp; 1) ans = (ans * a) % p; return ans;&#125;int exbsgs(int a, int c, int m) &#123; a %= m, c %= m; if (c == 1) return 0; int delta = 0; ll t = 1; for (int g = gcd(a, m); g != 1; g = gcd(a, m)) &#123; if (c % g) return -1; m /= g, c /= g, t = t * a / g % m; ++delta; if (c == t) return delta; &#125; std::map&lt;int, int&gt; hash; int M = int(sqrt(1.0 * m) + 1); ll tmp = c; for (int i = 0; i != M; i++) &#123; hash[tmp] = i; tmp = tmp * a % m; &#125; tmp = qpow(a, M, m); ll now = t; for (int i = 1; i &lt;= m + 1; i++) &#123; now = now * tmp % m; if (hash.count(now)) return i * M - hash[now] + delta; &#125; return -1;&#125;int main() &#123; while (scanf("%d %d %d", &amp;a, &amp;m, &amp;c), m) &#123; if (m == 1) &#123; printf("%s\n", c == 0 ? "0" : "No Solution"); continue; &#125; int ans = exbsgs(a, c, m); if (ans != -1) printf("%d\n", ans); else printf("No Solution\n"); &#125; return 0;&#125; 高次剩余问题 解方程\(A^B \equiv C \pmod M\), 已知\(BCM\)求\(A\). 如果\(M\)是质数的幂, 那么拆成若干个质数, 使用原根求解, 并使用中国剩余定理合并即可. 更难的部分先留坑Orz. 大数分解 Pollard \(\rho\)算法. 留坑.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3527][Zjoi2014]力-FFT]]></title>
      <url>%2F2017%2F03%2F28%2Fbzoj3527%2F</url>
      <content type="text"><![CDATA[Brief Description 求\[E_i = \sum_{i&lt;j} \frac {q_i}{(i-j)^2}-\sum_{i&gt;j}\frac{q_i}{(i-j)^2}\] Algorithm Design 令\(f(x) = q(x), g(x)=x^2\), 那么前面的式子就是\((f*g)(i)\), 对于后面的式子, 我们化简: \[\sum_{i&gt;j}\frac{q_i}{(i-j)^2}=\sum_{i = j+1}^{n}f(i)g(j-i)\\=\sum_{i=0}^{n-j-1} f(i+j)g(i)\] 令\(f&#39;(i) = f(n-i-1)\), 那么这个式子就是 \[\sum_{i=0}^{n-j-1}f&#39;(n-j-1 - i)g(i)=(f&#39;*g)(n-j-1)\] 然后调用fft, 大力算卷积就好了. Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;complex&gt;#include &lt;cstdio&gt;#define pi acos(-1)const int maxn = 262200 + 10;typedef std::complex&lt;double&gt; E;E f[maxn], g[maxn], _f[maxn], e1[maxn], e2[maxn];int R[maxn], q[maxn];int n, m, L;void fft(E *a, int f) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; R[i]) std::swap(a[i], a[R[i]]); for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; E wn(cos(pi / i), f * sin(pi / i)); for (int j = 0; j &lt; n; j += (i &lt;&lt; 1)) &#123; E w(1, 0); for (int k = 0; k &lt; i; k++, w *= wn) &#123; E x = a[j + k], y = a[j + k + i] * w; a[j + k] = x + y; a[j + k + i] = x - y; &#125; &#125; &#125; if (f == -1) for (int i = 0; i &lt; n; i++) a[i] /= n;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d", &amp;n); n--; for (int i = 0; i &lt;= n; i++) &#123; double x; scanf("%lf", &amp;x); f[i] = x; _f[n - i] = x; &#125; for (int i = 1; i &lt;= n; i++) g[i] = 1.0 / i / i; m = 2 * n; for (n = 1; n &lt;= m; n &lt;&lt;= 1, L++) ; for (int i = 0; i &lt; n; i++) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)); fft(f, 1); fft(g, 1); fft(_f, 1); for (int i = 0; i &lt; n; i++) e1[i] = f[i] * g[i]; for (int i = 0; i &lt; n; i++) e2[i] = _f[i] * g[i]; fft(e1, -1); fft(e2, -1); for (int i = 0; i &lt;= (m / 2); i++) printf("%.3lf\n", e1[i].real() - e2[m / 2 - i].real()); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2194]快速傅立叶之二-FFT]]></title>
      <url>%2F2017%2F03%2F28%2Fbzoj2194%2F</url>
      <content type="text"><![CDATA[Brief Description 请计算\(C[k]=\sum_{i=k}^{n-1}(a[i]\times b[i-k])\). Algorithm Design 令\(b&#39;[i]=b[n-i]\), 得到 \[C[k] = \sum_{i=k}^{n-1}(a[i]*b&#39;[n+k-i])=\sum_{i=0}^{n-k-1}a[i-k]b&#39;[n-i+2k]=(a*b&#39;)(n+k)\]. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;algorithm&gt;#include &lt;complex&gt;#include &lt;cstdio&gt;typedef std::complex&lt;double&gt; E;#define pi acos(-1)const int maxn = 262144;E a[maxn], b[maxn];int R[maxn];int n, m, L;void fft(E *a, int f) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; R[i]) std::swap(a[i], a[R[i]]); for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; E wn(cos(pi / i), f * sin(pi / i)); for (int j = 0; j &lt; n; j += (i &lt;&lt; 1)) &#123; E w(1, 0); for (int k = 0; k &lt; i; k++, w *= wn) &#123; E x = a[j + k], y = a[j + k + i] * w; a[j + k] = x + y; a[j + k + i] = x - y; &#125; &#125; &#125; if (f == -1) for (int i = 0; i &lt; n; i++) a[i] /= n;&#125;int main() &#123; scanf("%d", &amp;n); n--; for (int i = 0; i &lt;= n; i++) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); a[i] = x; b[n - i] = y; &#125; m = n &lt;&lt; 1; for (n = 1; n &lt;= m; n &lt;&lt;= 1) L++; for (int i = 0; i &lt; n; i++) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)); fft(a, 1); fft(b, 1); for (int i = 0; i &lt;= n; i++) a[i] *= b[i]; fft(a, -1); for (int i = m &gt;&gt; 1; i &lt;= m; i++) printf("%d\n", (int)(a[i].real() + 0.1)); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2179]FFT快速傅立叶-FFT+NTT]]></title>
      <url>%2F2017%2F03%2F27%2Fbzoj2179%2F</url>
      <content type="text"><![CDATA[Brief Description 给出两个n位10进制整数x和y，你需要计算x*y。 Algorithm Design FFT和NTT的模板题. Code(FFT) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;complex&gt;#include &lt;cstdio&gt;using std::complex;#define maxn 131072#define pi acos(-1)#define ll long longtypedef complex&lt;double&gt; E;int n, m, L;char ch[maxn];int R[maxn], c[maxn];E a[maxn], b[maxn];void fft(E *a, int f) &#123; for (int i = 0; i &lt; n; i++) if (i &lt; R[i]) std::swap(a[i], a[R[i]]); for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; E wn(cos(pi / i), f * sin(pi / i)); for (int j = 0; j &lt; n; j += (i &lt;&lt; 1)) &#123; E w(1, 0); for (int k = 0; k &lt; i; k++, w *= wn) &#123; E x = a[j + k], y = w * a[j + k + i]; a[j + k] = x + y; a[j + k + i] = x - y; &#125; &#125; &#125; if (f == -1) for (int i = 0; i &lt; n; i++) a[i] /= n;&#125;int main() &#123; scanf("%d", &amp;n); n--; scanf("%s", ch); for (int i = 0; i &lt;= n; i++) a[i] = ch[n - i] - '0'; scanf("%s", ch); for (int i = 0; i &lt;= n; i++) b[i] = ch[n - i] - '0'; m = 2 * n; for (n = 1; n &lt;= m; n &lt;&lt;= 1) L++; for (int i = 0; i &lt; n; i++) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)); fft(a, 1); fft(b, 1); for (int i = 0; i &lt;= n; i++) a[i] *= b[i]; fft(a, -1); for (int i = 0; i &lt;= m; i++) c[i] = (int)(a[i].real() + 0.01); for (int i = 0; i &lt;= m; i++) if (c[i] &gt;= 10) &#123; c[i + 1] += c[i] / 10, c[i] %= 10; if (i == m) m++; &#125; for (int i = m; i &gt;= 0; i--) printf("%d", c[i]); return 0;&#125; Code(NTT) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#define maxn 131072#define ll long longconst ll P = 479 &lt;&lt; 21 ^ 1;const ll G = 3;ll n, m, L;char ch[maxn];ll R[maxn], c[maxn];ll a[maxn], b[maxn];ll w[2][maxn], s[2];ll pow(ll a, ll b) &#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = ((ll)ans * a) % P; a = ((ll)a * a) % P; b &gt;&gt;= 1; &#125; return ans;&#125;ll inv(ll x) &#123; return pow(x, P - 2); &#125;void ntt(ll *a, ll f) &#123; for (ll i = 0; i &lt; n; i++) if (i &lt; R[i]) std::swap(a[i], a[R[i]]); for (ll i = 1; i &lt; n; i &lt;&lt;= 1) &#123; for (ll j = 0, l = n / (i &lt;&lt; 1); j &lt; n; j += (i &lt;&lt; 1)) &#123; for (ll k = 0, t = 0; k &lt; i; k++, t += l) &#123; ll x = a[j + k], y = (1ll * w[f][t] * a[j + k + i]) % P; a[j + k] = (x + y) % P; a[j + k + i] = (x - y + P) % P; &#125; &#125; &#125; if (f) for (ll i = 0; i &lt; n; i++) (a[i] *= inv(n)) %= P;&#125;void init() &#123; s[0] = pow(G, (P - 1) / n); s[1] = inv(s[0]); for (ll i = 0; i &lt; n; i++) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)); for (ll i = 0; i &lt; n; i++) for (ll j = 0; j &lt; 2; j++) w[j][i] = i ? w[j][i - 1] * s[j] % P : 1;&#125;int main() &#123; scanf("%lld", &amp;n); n--; scanf("%s", ch); for (ll i = 0; i &lt;= n; i++) a[i] = ch[n - i] - '0'; scanf("%s", ch); for (ll i = 0; i &lt;= n; i++) b[i] = ch[n - i] - '0'; m = 2 * n; for (n = 1; n &lt;= m; n &lt;&lt;= 1) L++; init(); ntt(a, 0); ntt(b, 0); for (ll i = 0; i &lt;= n; i++) a[i] *= b[i]; ntt(a, 1); for (ll i = 0; i &lt;= m; i++) c[i] = a[i]; for (ll i = 0; i &lt;= m; i++) if (c[i] &gt;= 10) &#123; c[i + 1] += c[i] / 10, c[i] %= 10; if (i == m) m++; &#125; for (ll i = m; i &gt;= 0; i--) printf("%lld", c[i]); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从博客园迁移到了Hexo]]></title>
      <url>%2F2017%2F03%2F27%2F%E4%BB%8E%E5%8D%9A%E5%AE%A2%E5%9B%AD%E8%BF%81%E7%A7%BB%2F</url>
      <content type="text"><![CDATA[从博客园迁移到了Hexo 感觉hexo很方便, 所以从原来的博客迁移过来了. 对于我这个Linuxer来说, hexo还是非常好搭建的. 然后导入的话就是从博客园备份成xml文件直接暴力导入了. 可能以后回顾以前的文档的时候会重新整理一下标签和格式吧. 感谢博客园这个好网站让我记录了100多篇博客. 开始了新生活!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj4552][Tjoi2016&Heoi2016]排序-二分+线段树]]></title>
      <url>%2F2017%2F03%2F24%2Fbzoj4552-Tjoi2016-Heoi2016-%E6%8E%92%E5%BA%8F-%E4%BA%8C%E5%88%86-%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
      <content type="text"><![CDATA[Brief Description DZY有一个数列a[1..n]，它是1∼n这n个正整数的一个排列。 现在他想支持两种操作： 0, l, r: 将a[l..r]原地升序排序。 1, l, r: 将a[l..r]原地降序排序。 操作完后，他会给你指定一个位置k，请你告诉他a[k]的值。 Algorithm Design 很好的一道题目, 反正我没有想到正解, 但是直接抄袭jcvb的bc题目就不太资辞了(连样例都抄也太懒了吧喂) , 附上原题地址. &gt;这是一道良心的基础数据结构题。 &gt;我们二分a[k]的值，假设当前是mid，然后把大于mid的数字标为1，不大于mid的数字标为0。然后对所有操作做完以后检查一下a[k]位置上是0还是1。 &gt;因为只有两种值，所以操作还是不难做的。只要用一个线段树，支持区间求和、区间赋值即可。这样要排序一个区间时只要查询一下里面有几个1和几个0，然后把前半段赋值为0，后半段赋值为1即可（降序的话就是反过来）。 &gt;复杂度是\(O(mlog^2n)\)的。 &gt;这题用其他玄学做法或者用更加厉害的平衡树做法也是有可能AC的。 题解来自jcvb的官方题解 # Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;cstdio&gt;#define init int l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1const int maxn = 1e5 + 1e2;int n, m, a[maxn], lambda, q;struct seg &#123; int l, r, val, cov;&#125; t[maxn &lt;&lt; 4];struct op &#123; int a, b, c;&#125; o[maxn];void update(int k) &#123; t[k].val = t[k &lt;&lt; 1].val + t[k &lt;&lt; 1 | 1].val; &#125;void build(int k, int l, int r) &#123; t[k].l = l, t[k].r = r, t[k].cov = -1; if (l == r) &#123; t[k].val = a[l] &gt; lambda; return; &#125; int mid = (l + r) &gt;&gt; 1; build(k &lt;&lt; 1, l, mid); build(k &lt;&lt; 1 | 1, mid + 1, r); update(k);&#125;void pushdown(int k) &#123; if (t[k].cov != -1) &#123; t[k &lt;&lt; 1].cov = t[k].cov; t[k &lt;&lt; 1 | 1].cov = t[k].cov; t[k &lt;&lt; 1].val = (t[k &lt;&lt; 1].r - t[k &lt;&lt; 1].l + 1) * (t[k].cov); t[k &lt;&lt; 1 | 1].val = (t[k &lt;&lt; 1 | 1].r - t[k &lt;&lt; 1 | 1].l + 1) * (t[k].cov); t[k].cov = -1; &#125; if (t[k].l &lt; t[k].r) update(k);&#125;int query(int k, int x, int y) &#123; init; pushdown(k); if (x &lt;= l &amp;&amp; r &lt;= y) return t[k].val; int ans = 0; if (x &lt;= mid) ans += query(k &lt;&lt; 1, x, y); if (y &gt; mid) ans += query(k &lt;&lt; 1 | 1, x, y); return ans;&#125;void modify(int k, int x, int y, int val) &#123; init; pushdown(k); if (x &lt;= l &amp;&amp; r &lt;= y) &#123; t[k].val = (r - l + 1) * val; t[k].cov = val; return; &#125; if (x &lt;= mid) modify(k &lt;&lt; 1, x, y, val); if (y &gt; mid) modify(k &lt;&lt; 1 | 1, x, y, val); update(k);&#125;bool check(int x) &#123; lambda = x; build(1, 1, n); for (int i = 1; i &lt;= m; i++) &#123; int opt = o[i].a, x = o[i].b, y = o[i].c; int tmp = query(1, x, y); if (opt == 0) &#123; modify(1, x, y - tmp, 0); modify(1, y - tmp + 1, y, 1); &#125; else &#123; modify(1, x, x + tmp - 1, 1); modify(1, x + tmp, y, 0); &#125; &#125; return !query(1, q, q);&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); int l = 1, r = n; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d %d %d", &amp;o[i].a, &amp;o[i].b, &amp;o[i].c); &#125; scanf("%d", &amp;q); while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; &#125; printf("%d", r);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj4551][Tjoi2016&Heoi2016]树-树链剖分]]></title>
      <url>%2F2017%2F03%2F24%2Fbzoj4551-Tjoi2016-Heoi2016-%E6%A0%91-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
      <content type="text"><![CDATA[Brief Description 给定一颗有根树（根为1），有以下 两种操作：1. 标记操作：对某个结点打上标记（在最开始，只有结点1有标记，其他结点均无标记，而且对于某个 结点，可以打多次标记。）2. 询问操作：询问某个结点最近的一个打了标记的祖先（这个结点本身也算自己的祖 先）你能帮帮他吗? Algorithm Design 树链剖分维护最深层带标记节点. 裸, 1A, 高兴. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;cstdio&gt;#define init int l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1const int maxn = 201000;int n, Q, cnt;struct edge &#123; int to, next;&#125; e[maxn &lt;&lt; 1];struct seg &#123; int l, r, data;&#125; t[maxn &lt;&lt; 2];int head[maxn], q[maxn], bl[maxn], belong[maxn], size[maxn], dfn, like[maxn], tag[maxn], fa[maxn], deep[maxn];void add_edge(int u, int v) &#123; e[++cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;&#125;void dfs1(int x) &#123; size[x] = 1; for (int i = head[x]; i; i = e[i].next) &#123; if (e[i].to != fa[x]) &#123; fa[e[i].to] = x; deep[e[i].to] = deep[x] + 1; dfs1(e[i].to); size[x] += size[e[i].to]; if (size[e[i].to] &gt; size[like[x]]) like[x] = e[i].to; &#125; &#125;&#125;void dfs2(int x, int chain) &#123; bl[x] = ++dfn; q[dfn] = x; belong[x] = chain; if (like[x]) dfs2(like[x], chain); for (int i = head[x]; i; i = e[i].next) &#123; if (e[i].to != fa[x] &amp;&amp; e[i].to != like[x]) &#123; dfs2(e[i].to, e[i].to); &#125; &#125;&#125;void build(int k, int l, int r) &#123; t[k].l = l, t[k].r = r, t[k].data = (l &lt;= 1 &amp;&amp; 1 &lt;= r) ? 1 : 0; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(k &lt;&lt; 1, l, mid); build(k &lt;&lt; 1 | 1, mid + 1, r);&#125;void update(int k) &#123; t[k].data = t[k &lt;&lt; 1 | 1].data ? t[k &lt;&lt; 1 | 1].data : t[k &lt;&lt; 1].data;&#125;void modify(int k, int pos, int val) &#123; init; if (l == r) &#123; if (deep[val] &gt; deep[t[k].data]) t[k].data = val; return; &#125; if (pos &lt;= mid) modify(k &lt;&lt; 1, pos, val); else modify(k &lt;&lt; 1 | 1, pos, val); update(k);&#125;int query(int k, int x, int y) &#123; init; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; return t[k].data; &#125; int ans = 0; if (x &lt;= mid) &#123; int t = query(k &lt;&lt; 1, x, y); if (deep[t] &gt; deep[ans]) ans = t; &#125; if (y &gt; mid) &#123; int t = query(k &lt;&lt; 1 | 1, x, y); if (deep[t] &gt; deep[ans]) ans = t; &#125; return ans;&#125;void ask(int x, int f) &#123; int ans = 0; while (belong[x] != belong[f]) &#123; int t = query(1, bl[belong[x]], bl[x]); ans = t ? t : 0; if (ans) break; x = fa[belong[x]]; &#125; int t = query(1, bl[belong[x]], bl[x]); ans = t ? t : 0; printf("%d\n", ans);&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;Q); deep[0] = -1; for (int i = 1; i &lt; n; i++) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); add_edge(x, y); add_edge(y, x); &#125; dfs1(1); dfs2(1, 1); build(1, 1, dfn); while (Q--) &#123; char op[5]; scanf("%s", op); if (op[0] == 'Q') &#123; int x; scanf("%d", &amp;x); ask(x, 1); &#125; else &#123; int x; scanf("%d", &amp;x); tag[x] = 1; modify(1, bl[x], x); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3998][TJOI2015]弦论-后缀自动机]]></title>
      <url>%2F2017%2F03%2F24%2Fbzoj3998-TJOI2015-%E5%BC%A6%E8%AE%BA-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
      <content type="text"><![CDATA[Brief Description 给定一个字符串, 您需要求出他的严格k小子串或非严格k小子串. Algorithm Design 考察使用后缀自动机. 首先原串建SAM, 然后如果考察每个状态代表的子串的出现次数. 可以知道, 在parent树上某个节点的出现次数就是他的所有儿子的出现次数之和. 所以, 我们可以按照len基数排序, 然后根据这种拓扑序把出现次数计算出来, 同时, 我们也统计出了以某个节点为根的子树的出现次数总和. 有了每个状态的出现次数之后, 我们运行后缀自动机, 每次选择字典序最小的转移, 如果转移到达的状态所为根的子树的总出现次数大于k, 我们就可以输出这个字符, 同时k-=sum[trans[x][i]]. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 5e5 + 1e2;const int maxm = maxn &lt;&lt; 1;int N, T, k;char str[maxn];struct Suffix_Automaton &#123; int rt, last, trans[maxm][26], fa[maxm], sz, len[maxm], cnt[maxm]; int v[maxn], q[maxm], sum[maxm]; void init() &#123; sz = 0; rt = last = ++sz; &#125; void insert(int x) &#123; int p = last, np = last = ++sz; len[np] = len[p] + 1; cnt[np] = 1; while (!trans[p][x] &amp;&amp; p) &#123; trans[p][x] = np; p = fa[p]; &#125; if (!p) &#123; fa[np] = 1; &#125; else &#123; int q = trans[p][x]; if (len[q] == len[p] + 1) &#123; fa[np] = q; &#125; else &#123; int nq = ++sz; len[nq] = len[p] + 1; memcpy(trans[nq], trans[q], sizeof(trans[q])); fa[nq] = fa[q]; fa[q] = fa[np] = nq; while (trans[p][x] == q) &#123; trans[p][x] = nq; p = fa[p]; &#125; &#125; &#125; return; &#125; void pre() &#123; for (int i = 1; i &lt;= sz; i++) v[len[i]]++; for (int i = 1; i &lt;= ::N; i++) v[i] += v[i - 1]; for (int i = sz; i; i--) q[v[len[i]]--] = i; for (int i = sz; i; i--) &#123; int t = q[i]; if (T == 1) cnt[fa[t]] += cnt[t]; else cnt[t] = 1; &#125; cnt[1] = 0; for (int i = sz; i; i--) &#123; int t = q[i]; sum[t] = cnt[t]; for (int j = 0; j &lt; 26; j++) sum[t] += sum[trans[t][j]]; &#125; &#125; void dfs(int x, int k) &#123; if (k &lt;= cnt[x]) return; k -= cnt[x]; for (int i = 0; i &lt; 26; i++) if (int t = trans[x][i]) &#123; if (k &lt;= sum[t]) &#123; putchar(i + 'a'); dfs(t, k); return; &#125; k -= sum[t]; &#125; &#125;&#125; sam;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%s", str + 1); N = strlen(str + 1); scanf("%d %d", &amp;T, &amp;k); sam.init(); for (int i = 1; i &lt;= N; i++) &#123; sam.insert(str[i] - 'a'); &#125; sam.pre(); if (k &gt; sam.sum[1]) printf("-1\n"); else sam.dfs(1, k); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj4567][Scoi2016]背单词-Trie+贪心+模型转化]]></title>
      <url>%2F2017%2F03%2F23%2Fbzoj4567-Scoi2016-%E8%83%8C%E5%8D%95%E8%AF%8D-Trie-%E8%B4%AA%E5%BF%83-%E6%A8%A1%E5%9E%8B%E8%BD%AC%E5%8C%96%2F</url>
      <content type="text"><![CDATA[Brief Description 给你N个互不相同的字符串，记\(S_i\)为第i个字符串，现在要求你指定N个串的出现顺序，我们用\(V_i\)表示第i个字符串是第几个出现的，则V为1到N的一个排列。我们希望你指定的出现顺序可以使总代价最小 一个出现顺序的代价的计算方法如下依次考虑第i个串\(S_i\)对代价的贡献： 假如存在一个串\(S_j\), \(S_j\)为\(S_i\)的后缀： 假如存在一个串\(S_j\), \(S_j\)为\(S_i\)的后缀，且\(V_j&gt;V_i\)则第i个串对代价的贡献为\(N\times N\) 否则，记\(P_i\)为所有满足\(S_j\)为\(S_i\)的后缀的j中\(V_j\)的最大值，第i个串对代价的贡献为\(V_i-P_i\) 否则，如果不存在一个串\(S_j\)，使得\(S_j\)为\(S_i\)的后缀，则第i个串对代价的贡献为\(V_i\) 你需要输出这个最小的总代价. Algorithm Design 首先可以证明第一个条件是没有用处的. 然后我们视后缀为一种偏序关系, 那么字符串就构成了一颗树, 那么问题就转化成了给树上每个节点标号使得他的标号减去他的父亲的标号的和最小. 这是一个经典的贪心问题. 我们选择每次都选择最小的size子树进行标号, 不难证明这样做的correctness. Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define ll long long#define pa std::pair&lt;int, int&gt;const int maxn = 100000 + 100;const int maxlen = 520000 + 100;int n;struct edge &#123; int to, next;&#125; e[maxn &lt;&lt; 1];char str[maxlen];int rt = 1, sz = 1, ch[maxlen][26], len, id[maxlen], tot, head[maxn], size[maxn], f[maxn], cnt, fa[maxn];std::vector&lt;pa&gt; v[maxn &lt;&lt; 1];inline void ins(int id) &#123; int p = rt; for (int i = len; i &gt;= 1; i--) &#123; int x = str[i] - 'a'; if (!ch[p][x]) &#123; ch[p][x] = ++sz; &#125; p = ch[p][x]; &#125; ::id[p] = id;&#125;inline void add_edge(int u, int v) &#123; e[++tot].to = v; e[tot].next = head[u]; fa[v] = u; head[u] = tot;&#125;void dfs(int x, int fa) &#123; if (id[x]) &#123; add_edge(fa, id[x]); fa = id[x]; &#125; for (int i = 0; i &lt; 26; i++) &#123; if (ch[x][i]) dfs(ch[x][i], fa); &#125;&#125;void dfs2(int x) &#123; size[x] = 1; for (int i = head[x]; i; i = e[i].next) &#123; int y = e[i].to; dfs2(y); v[x].push_back(std::make_pair(size[y], y)); size[x] += size[y]; &#125; std::sort(v[x].begin(), v[x].end());&#125;void getf(int x) &#123; if (x) f[x] = ++cnt; for (int i = 0; i &lt; v[x].size(); i++) getf(v[x][i].second);&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", str + 1); len = strlen(str + 1); ins(i); &#125; dfs(1, 0); dfs2(0); getf(0); ll ans = 0; for (int i = 1; i &lt;= n; i++) ans += f[i] - f[fa[i]]; printf("%lld", ans);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线性规划与网络流24题解题报告]]></title>
      <url>%2F2017%2F03%2F23%2F%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
      <content type="text"><![CDATA[网络流24题是一套经典的网络流题目, 来自1.本题解参考了教材的官方答疑2, 和几位神犇orz的博客345. 1. 飞行员配对方案问题 最大流, 二分图最大匹配 裸的二分图最大匹配. 2. 太空飞行计划问题 最小割 有一些实验, 实验需要一些仪器, 购置仪器的费用为\(c_k\), 实验做出来可以获得\(p_k\)美元. 选择购置哪些仪器使得 \[\max \sum p_k - \sum c_k\] 显然这个题目是一个决策每个方案是否选择的问题, 可以转化成最小割模型, 我们由\(s\)向每个仪器连一条容量为\(c_k\)的边, 由实验向汇连一条容量为\(p_k\)的边, 这样, \[\sum_{E_j \in T} p_j - \sum_{I_k \in T}c_k=\sum p_j - \sum_{E_j \in S}p_j - \sum_{I_k \in T}c_k\\=\sum p_j - cap[S,T]\] 3. \(\star\)最小路径覆盖问题 二分图最大匹配, 网络流 给定有向图\(G=(V,E)\), 设\(P\)是\(G\)的一个简单路径(顶点不相交)的集合, 如果\(V\)中的每个点都在\(P\)的一条路径上, 那么称\(P\)是原图的一个路径覆盖. \(G\)的最小路径覆盖是\(G\)的所含路径条数最少的路径覆盖. 求DAG\(G\)的最小路径覆盖. 我们考察一个路径覆盖的性质: 1. 每个顶点属于且仅属于一个路径. 2. 路径上除了终点, 每个点都恰好有且仅有一条边指向路径上另一个点. 可以发现这种性质类似二分图性质, 我们把点拆成两个点, 一个作为起点, 一个作为终点, 那么每一条原图中的边都对应着二分图中的一个匹配, 因为一个点仅能被一条边覆盖, 所以在二分图中每一个合法的匹配都唯一地代表了一种路径覆盖方式. 最开始的时候, 我们可以看作每个点都自身作为一个路径, 这样, 每增加一个二分图匹配, 集合的基数就减少一, 那么我们只要算出二分图的最大匹配, 用点的个数减去它就可以了. 这个题目的关键就是发现潜在的二分图性质. 注意, 这种建模方式仅限于DAG, 因为如果有环, 那么可能对应了一些环覆盖, 而不是路径覆盖. 4. 魔术球问题 最小路径覆盖, 最大流 假设有n根柱子, 按照以下规则在这n根柱子中依次放入编号为1,2,3的球, 1. 每次只能在某根柱子的最上面放球 2. 满足相邻任何一根柱子上相邻两个球的编号之和为完全平方数 如果存在\(i &lt; j\)使得\(i+j\)是完全平方数, 连边\(i \rightarrow j\) 那么对于有这样\(n\)个顶点的图\(G\), 显然地\(G\)的最小路径覆盖确定了柱子数 我们可以二分答案使用上面的方法验证 也可以证明, \(n\)个柱子能够放入的最多球数为\(\lfloor \frac {n^2+2n-1}2 \rfloor\).(我不会证) 5. 圆桌问题 最大流 有\(n\)个来自不同单位的代表, 每个单位的代表数分别为\(r_i\), 会议餐厅共有\(m\)个餐桌, 每个餐桌可以容纳\(c_i\)人, 同时同一个单位的代表不能在同一个餐桌用餐. 不难建图: \(s \xrightarrow{r_i}\)单位 单位\(\xrightarrow{1}\)餐桌 餐桌\(\xrightarrow{c_i}t\) 跑一遍最大流即可 6. 最长递增子序列问题 最大流 给定正整数序列, 求从给定的序列中最多可以取出多少个长度为\(s\)的LIS. 和SDOI某年一道题很相似 首先如果对于\(i &lt; j, f_i &lt; f_j\)连边\(i \rightarrow j\) 然后有两种做法, 一种是拆点放限制, 一种是在边上搞, 其实都无所谓. 7. 试题库问题 最大流 有\(n\)道试题, 知道他们所属的类型, 求一种算法使得可以出一套有\(m\)个题目的试卷包含\(k_i\)个某种类型的题目. 建图: s到每种类型, 容量\(k_i\) 每个试题到t, 容量1 试题到类型连边容量1 8. 机器人路径规划问题 未解决 机器人在一个树上自由移动, 给定树上两点s和t, 树上有若干可移动的障碍物, 任何时刻两个物品不能在同一个节点上. 移动某个物品(机器人或障碍)的代价是1. 您需要使用最小的代价移动机器人从s到t. 本题是一个著名的树形路径上的路径规划问题, 成为了“网络流24题”中唯一没有得到解决的问题. 事实上, 这个问题并不是一个网络流问题, 虽然有一个\(O(n^9)\)的算法, 但是非常缓慢6, 有兴趣的同学可以参考文献[6]. 9. 方格取数问题 最大流, 拆点, 二分图最大独立集 在一个\(m \times n\)的棋盘中, 每一个方格中有一个正整数, 现要从方格中取数使得取到的任意两个数不相邻, 且取出的数总和最大. 一看见棋盘, 不管它问什么, 我们就要先黑白染色(笑). 这样, 显然格子组成了一个二分图, 然后将每个方格节点按照方格中的正整数\(x\)拆成\(x\)个顶点. 原来链接方格顶点\(x\)和\(y\)的边增加为\(x \times y\)条边. 由此构成的图\(G&#39;\)仍然是二分图. 这样就等价于求二分图的最大独立集. 对于图, 我们有: 最大独立集 + 最小顶点覆盖 = V 对于二分图, 我们有: 最小顶点覆盖 = 最大匹配78 所以我们跑一遍Dinic就解决了本题. 10. \(\star\)餐巾计划问题 最小费用流, 拆点, 决策分析 一个餐厅在连续的\(N\)天中, 每天需要使用的餐巾个数不尽相同. 餐厅每天有三种决策: 买一块新餐巾, 代价p 旧餐巾送到快洗店, m天后使用, 代价f 旧餐巾送到慢洗店, n天后使用, 代价s 设计一个计划使得总花费最小. 构造网络\(G\), 每天对应图\(G\)的两个顶点\(X_i\)和\(Y_i\).\(X_i\)表示干净, \(Y_i\)表示脏. 顶点\(X_i\)和\(X_{i+1}\)连一条容量为\(\infty\), 费用为\(0\)的边, 表示保留旧餐巾的决策. 当\(i+m \leqslant N\)时, 顶点\(X_i\)和\(Y_{i+m}\)连一条容量为\(\infty\), 费用为\(f\)的边, 表示快洗决策. 当\(i+n \leqslant N\)时, 顶点\(X_i\)和\(Y_{i+m}\)连一条容量为\(\infty\), 费用为\(s\)的边, 表示慢洗决策. 另外增加源\(s\)和汇\(t\), 以及附加顶点\(k\) 从s向每个顶点\(X_i\)连一条边, 容量为第i天餐巾需求量\(r_i\), 费用0. 从附加顶点\(k\)向每个顶点\(Y_i\)连一条容量为\(\infty\), 费用为\(p\), 表示购买决策. 从顶点\(Y_i\)向\(t\)连一条容量为\(r_i\), 费用为0. 求网络\(G\)的最小网络流. 11. 航空路线问题 拆点, 费用流 给定一个带边权有向图, 求一条从\(s\)到\(t\)又从\(t\)到\(s\)的路径使得: 每个点只经过一次 每条边只经过一次 总权最大 这种每个点只能经过一次的显然要拆点建最大流模型, 又因為有边权的设定, 所以我们跑一个最大费用最大流就好了. 12. 软件补丁问题 最小转移代价, 最短路 某软件有\(n\)个bug, \(m\)个补丁, 每一种补丁都有两个与之对应的bug集合\(B_1[i]\)和\(B_2[i]\), 设当前bug集合为\(S\), 补丁\(i\)可以发挥作用当且仅当 \[S \cup B_1[i] = S \ and\ S \cap B_2[i] = \varnothing \] 每个补丁可以修复的bug集合为\(F_1[i]\), 会带来的新bug集合为\(F_2[i]\), 另外, 每个补丁修复都需要一定的时间. 试设计一个算法, 利用\(m\)个补丁把原程序修复成一个没有bug的软件, 并且使得总时间最小. 参考文献9中说这道题可以使用网络流解决, 但在我看来不如使用在隐式图中spfa解决, 具体的, 我们把状态压缩成一个二进制串, 用一个节点表示集合, 这样状态的转移对应了图中的边, 跑一遍spfa就可以解决了. 13. 星际转移问题 最大流, 拆点, 利用之前增广结果 给定一个有向图, 图上的边周期性开放, 边有费用和容量, 现在求最小代价从\(s\)转移所有人到\(t\). 首先考察原问题的反问题: 给定时间\(T\), 最多可以运送多少人? 我们把一个点拆成\(T\)个点建图, 如果有一条边\((i,j)\), 那么新图中有一条边\((i, t) \xrightarrow{c(i,j)} (j, t+1)\), 同时, 又有边\((i,t) \xrightarrow{\infty} (i,t+1)\), 那么跑一下最大流就好了. 然后考察两种方法: 一种是二分时间\(T\), 一种是从小到大枚举\(T\). 看似二分好一些, 但是第二种方法可以利用之前的结果进行增广, 反而效率会高. 14. 孤岛营救问题 分层图最短路 题目与黑书10上的第61页的题目相同, 来自CTSC 1999 建分层图跑一遍spfa就好了. 15. 汽车加油行驶问题 分层图最短路 设状态为\((x,y,z)\), 以状态为点, 各种决策为边建图, 跑spfa即可. 16. 数字梯形问题 费用流 给定一个由n 行数字组成的数字梯形如下图所示。梯形的第一行有m 个数字。从梯形的顶部的m 个数字开始，在每个数字处可以沿左下或右下方向移动，形成一条从梯形的顶至底的路径。 规则一: 互不相交: 拆点费用流 规则二: 仅在数字处相交: 限制边, 费用流 规则三: 允许在数字处相交或边相交: DP 17. 运输问题 费用流 W 公司有m个仓库和n 个零售商店。第i 个仓库有ai个单位的货物；第j 个零售商店需要bj个单位的货物。货物供需平衡，即ai的和=bj的和。从第i 个仓库运送每单位货物到第j个零售商店的费用为cij。试设计一个将仓库中所有货物运送到零售商店的运输方案， 使总运输费用最少。 源连仓库流量ai费用0，商店连汇流量bj费用0，每个仓库连每个商店流量无限大费用cij，跑网络流. 18. 分配工作问题 有n件工作要分配给n个人做。第i 个人做第j 件工作产生的效益为cij 。试设计一个将n件工作分配给n个人做的分配方案，使产生的总效益最大。 二分图最大权匹配, KM算法. 19. 负载平衡问题 G公司有\(n\)个环形排列的仓库, 每个仓库存储的货物数量不相等, 如何使用最少搬运量可以使\(n\)个仓库库存数量相同.只能在相邻仓库之间搬运 不难发现任意两个仓库之间都可以视为直接搬运. 那么每个仓库的目标就是\(\frac{\sum x_i}n\). 跑费用流就好了. 20. 深海机器人问题 给定每个深海机器人的出发位置和目标位置, 以及每条边上生物标本的价值, 计算深海机器人们的最有移动方案使得深海机器人到达目的地后采集到的标本价值最高. 把一条边拆成两条边, 第一条边容量为1, 费用为\(c_i\), 第二条边容量为\(\infty\), 费用为0. 建超级源汇, 跑最大费用最大流. 21. \(\star\)最长\(k\)可重区间集问题 最大费用流, 最大权不相交路径 给定实直线\(L\)上\(n\)个开区间组成的集合\(I\)和一个正整数\(k\), 试设计一个算法, 从\(I\)中选出\(S \subseteq I\), 使得在实直线上的任意一点\(x\), S中包含点\(x\)的开区间个数不超过\(k\), 且\(\sum_{z \in S}|z|\)达到最大, 这样的集合\(S\)称为开区间集合\(I\)的最长\(k\)可重区间集. \(\sum_{z \in S}|z|\)称为最长\(k\)可重区间集的长度. 若把每个线段看做点，一组不相交的线段集合就可以看做路径。这样问题就转化为选k条路径使得权值和最大，并且路径不能重叠（一个线段只能选一次）。 设给定的开区间集合共有\(m\)个不同的端点. 将这\(m\)个端点从小到大排序为: \(x_1, x_2, \cdots, x_m\), 构造网络\(G=(V,E)\)如下: 每个端点\(x_i\)对应一个顶点, 新增源\(s\)和汇\(t\). 对于每一个区间\((x_i, x_j)\), 连边\(x_i \xrightarrow {1, x_j-x_i} x_j\). 每对顶点\((x_i, x_{i+1})\)若没有边, 则增加一条有向边, 容量为\(k\), 费用为\(0\). \(s \xrightarrow{k, 0} x_1\)和\(x_m \xrightarrow{k,0} t\). 求网络的最大费用流. 转换思路：端点为点。同样是限制流量。而这次目标针对了【每个点至多出现k次】，而区间则成了一段有价值的点，所以可以端点之间连边来表示。并且这个做法边数更少，更优。 22. 最长\(k\)可重线段集问题 基本同21 23. 火星探险问题 用一个P*Q 网格表示登陆舱与传送器之间的位置。登陆舱的位置在(X1,Y1)处，传送器的位置在(XP ,YQ)处。登陆舱着陆后，探测车将离开登陆舱向先期到达的传送器方向移动。探测车在移动中还必须采集岩石标本。每一块岩石标本由最先遇到它的探测车完成采集。每块岩石标本只能被采集一次。岩石标本被采集后，其他探测车可以从原来岩石标本所在处通过。探测车不能通过有障碍的地面。本题限定探测车只能从登陆处沿着向南或向东的方向朝传送器移动，而且多个探测车可以在同一时间占据同一位置。如果某个探测车在到达传送器以前不能继续前进，则该车所采集的岩石标本将全部损失.给定每个位置的状态，计算探测车的最优移动方案，使到达传送器的探测车的数量最多，而且探测车采集到的岩石标本的数量最多。 把每个位置拆成两个点: 对于原图中的边, 连\(i&#39; \xrightarrow{\infty ,0} j\) 对于岩石顶点, 连\(i \xrightarrow{1,1}i&#39;\) 对于每个非障碍顶点, 连\(i \xrightarrow{\infty, 0} i&#39;\). \(s \rightarrow\)登陆舱, 容量探测车数, 费用0, 传送器\(\rightarrow t\), 容量探测车数, 费用0 最大费用最大流 24. 骑士共存问题 二分图最大独立集 象棋棋盘上有障碍, 最多能放置多少马使得他们之间不相互攻击. 二分图染色, 最大独立集. \(\mathtt{COPYRIGHT}© \mathtt{2017,KONJAC,MIT\ LICENSE}\) 计算机设计与分析, 王晓东, 第三版↩ 计算机设计与分析-习题解答, 王晓东, 第三版↩ 自写网络流24题总结, orzGEOTCBRL↩ 黄学长的博客, hzwer↩ 線性規劃與網絡流24題 解題報告, BYVoid↩ 机器人路径规划问题(TMP1R)题解, 陈俊锟↩ 浅谈线性规划与对偶问题, 董克凡↩ 最小割模型在信息学竞赛中的应用, 胡伯涛↩ 计算机设计与分析-习题解答, 王晓东, 第三版↩ 算法设计与信息学竞赛, 刘汝佳, 黄亮↩]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj4569][SCOI2016]萌萌哒-并查集+倍增]]></title>
      <url>%2F2017%2F03%2F22%2Fbzoj4569-SCOI2016-%E8%90%8C%E8%90%8C%E5%93%92-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E5%80%8D%E5%A2%9E%2F</url>
      <content type="text"><![CDATA[Brief Description 一个长度为n的大数，用S1S2S3…Sn表示，其中Si表示数的第i位,S1是数的最高位，告诉你一些限制条件，每个条 件表示为四个数，l1，r1，l2，r2，即两个长度相同的区间，表示子串Sl1Sl1+1Sl1+2…Sr1与Sl2Sl2+1Sl2+2…S r2完全相同。比如n=6时，某限制条件l1=1，r1=3，l2=4，r2=6，那么123123，351351均满足条件，但是12012，13 1141不满足条件，前者数的长度不为6，后者第二位与第五位不同。问满足以上所有条件的数有多少个。 Algorithm Design 朴素的想法是使用并查集合并相同位置元素, 那么设集合的个数是\(cnt\), 那么答案就是 \[9*10^{cnt-1}\]. 这样的话有许多重复计算, 观察数据范围, 我们发现我们大致需要一个\(O(mlogn)\)的算法, 然后, 首先想到了使用线段树, 但是线段树分割不灵活, 可以证明, 复杂度仍然是\(O(mn)\)的, 与朴素算法无异, 而且这个上界比较紧. 考虑使用类似ST表的算法, 令\(f[i][j]\)表示从i开始长度为\(2^j\)的区间, 那么每一个限制都可以拆成两个区间分别merge. 我们把这些f按照j的大小建树, 某个节点的两个孩子拼起来可以得到自身.这样的话可以证明复杂度是\(O(mlogn)\)的. 操作处理完了之后, 我们以区间长度为关键字从大到小依次考察每个区间, 如果他并不是一个独立的区间, 那么我们把对于他的限制下放到他的两个儿子那里去, 直到区间长度为1, 然后统计一下集合的个数就好了. 时间复杂度\(O(nlogn\alpha(n)+m\alpha (n))\) # Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;const int mod = 1e9 + 7;const int maxn = 1e5 + 1e2;int n, m, cnt;int f[maxn][18], log_2[maxn], lc[maxn * 18], rc[maxn * 18], fa[maxn * 18];void init() &#123; cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; if ((1 &lt;&lt; (cnt + 1)) &lt;= i) cnt++; log_2[i] = cnt; &#125; cnt = 0; for (int j = 0; (1 &lt;&lt; j) &lt;= n; j++) &#123; for (int i = 1; i + (1 &lt;&lt; (j)) - 1 &lt;= n; i++) &#123; f[i][j] = ++cnt; if (j) &#123; lc[cnt] = f[i][j - 1]; rc[cnt] = f[i + (1 &lt;&lt; (j - 1))][j - 1]; &#125; &#125; &#125; for (int i = 1; i &lt;= cnt; i++) fa[i] = i;&#125;int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125;void merge(int a, int b) &#123; int x = find(a), y = find(b); if (x != y) fa[x] = y;&#125;int main() &#123; scanf("%d %d", &amp;n, &amp;m); init(); while (m--) &#123; int s1, s2, e1, e2; scanf("%d %d %d %d", &amp;s1, &amp;e1, &amp;s2, &amp;e2); int len = log_2[e1 - s1 + 1]; merge(f[s1][len], f[s2][len]); merge(f[e1 - (1 &lt;&lt; len) + 1][len], f[e2 - (1 &lt;&lt; len) + 1][len]); &#125; int t; for (int i = cnt; i &gt; n; i--) &#123; if ((t = find(i)) != i) &#123; merge(lc[i], lc[t]); merge(rc[i], rc[t]); &#125; &#125; t = 0; for (int i = 1; i &lt;= n; i++) &#123; t += ((find(i)) == i); &#125; int ans = 9; for (int i = 1; i &lt; t; i++) ans = (1ll * ans * 10) % mod; printf("%d\n", ans);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1002]轮状病毒-矩阵树定理]]></title>
      <url>%2F2017%2F03%2F22%2Fbzoj1002-%E8%BD%AE%E7%8A%B6%E7%97%85%E6%AF%92-%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86%2F</url>
      <content type="text"><![CDATA[Brief Description 求外圈有\(n\)个点的, 形态如图所示的无向图的生成树个数. Algorithm Design \[f(n) = (3*f(n-1)-f(n-2)+2)\] Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;int mod = 10;struct data &#123; int a[50], len;&#125; f[3];int n;inline int min(int a, int b) &#123; return a &lt; b ? a : b; &#125;data mul(data a, int k) &#123; for (int i = 1; i &lt;= a.len; i++) a.a[i] *= k; for (int i = 1; i &lt;= a.len; i++) &#123; a.a[i + 1] += a.a[i] / mod; a.a[i] %= mod; &#125; while (a.a[a.len + 1]) &#123; a.len++; a.a[a.len + 1] += a.a[a.len] / mod; a.a[a.len] %= mod; &#125; return a;&#125;data sub(data a, const data &amp;b) &#123; a.a[1] += 2; for (int i = 1; i &lt;= min(a.len, b.len); i++) &#123; a.a[i] -= b.a[i]; if (a.a[i] &lt; 0) &#123; a.a[i] += 10; a.a[i + 1]--; &#125; &#125; while (a.a[a.len] == 0) a.len--; return a;&#125;void print(const data &amp;a) &#123; for (int i = a.len; i &gt;= 1; i--) printf("%d", a.a[i]);&#125;int main() &#123; f[0].len = f[1].len = 1; f[0].a[1] = 1; f[1].a[1] = 5; scanf("%d", &amp;n); int p = 1, pp = 0, now = 2; for (int i = 3; i &lt;= n; i++) &#123; data x = mul(f[p], 3); f[now] = sub(x, f[pp]); (++now) %= 3; (++p) %= 3; (++pp) %= 3; &#125; print(f[(now + 2) % 3]);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1005][HNOI2008]明明的烦恼-Prufer编码+高精度]]></title>
      <url>%2F2017%2F03%2F22%2Fbzoj1005-HNOI2008-%E6%98%8E%E6%98%8E%E7%9A%84%E7%83%A6%E6%81%BC-Prufer%E7%BC%96%E7%A0%81-%E9%AB%98%E7%B2%BE%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[Brief Description 给出标号为1到N的点,以及某些点最终的度数,允许在 任意两点间连线,可产生多少棵度数满足要求的树? #Algorithm Design 结论题. 首先可以参考这篇文章了解一下什么是Prufer编码: Cayley公式是说，一个完全图\(K_n\)有\(n^{n-2}\)棵生成树，换句话说n个节点的带标号的无根树有\(n^{n-2}\)个。今天我学到了Cayley公式的一个非常简单的证明，证明依赖于Prüfer编码，它是对带标号无根树的一种编码方式。 给定一棵带标号的无根树，找出编号最小的叶子节点，写下与它相邻的节点的编号，然后删掉这个叶子节点。反复执行这个操作直到只剩两个节点为止。由于节点数n&gt;2的树总存在叶子节点，因此一棵n个节点的无根树唯一地对应了一个长度为n-2的数列，数列中的每个数都在1到n的范围内。下面我们只需要说明，任何一个长为n-2、取值范围在1到n之间的数列都唯一地对应了一棵n个节点的无根树，这样我们的带标号无根树就和Prüfer编码之间形成一一对应的关系，Cayley公式便不证自明了。 注意到，如果一个节点A不是叶子节点，那么它至少有两条边；但在上述过程结束后，整个图只剩下一条边，因此节点A的至少一个相邻节点被去掉过，节点A的编号将会在这棵树对应的Prüfer编码中出现。反过来，在Prüfer编码中出现过的数字显然不可能是这棵树（初始时）的叶子。于是我们看到，没有在Prüfer编码中出现过的数字恰好就是这棵树（初始时）的叶子节点。找出没有出现过的数字中最小的那一个（比如④），它就是与Prüfer编码中第一个数所标识的节点（比如③）相邻的叶子。接下来，我们递归地考虑后面n-3位编码（别忘了编码总长是n-2）：找出除④以外不在后n-3位编码中的最小的数（左图的例子中是⑦），将它连接到整个编码的第2个数所对应的节点上（例子中还是③）。再接下来，找出除④和⑦以外后n-4位编码中最小的不被包含的数，做同样的处理……依次把③⑧②⑤⑥与编码中第3、4、5、6、7位所表示的节点相连。最后，我们还有①和⑨没处理过，直接把它们俩连接起来就行了。由于没处理过的节点数总比剩下的编码长度大2，因此我们总能找到一个最小的没在剩余编码中出现的数，算法总能进行下去。这样，任何一个Prüfer编码都唯一地对应了一棵无根树，有多少个n-2位的Prüfer编码就有多少个带标号的无根树。 一个有趣的推广是，n个节点的度依次为D1, D2, …, Dn的无根树共有\(\frac{(n-2)!}{\prod{(D_i-1)!}}\)个，因为此时Prüfer编码中的数字i恰好出现Di-1次。 然后, 根据排列组合和计数原理的相关知识, 设没有限制的节点数为\(m\), 答案就是 然后在分子和分母上分解因式, 把次数加加减减就好了. #Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define ll long longconst int maxn = 3000;const ll mod = 1000000000000000;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') f = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; return x * f;&#125;int n, m, tot, cnt;ll d[maxn], num[maxn], prime[maxn], check[maxn], ans[maxn], l = 1;void getprime() &#123; for (int i = 2; i &lt;= 1000; i++) &#123; if (!check[i]) prime[cnt++] = i; for (int j = 0; j &lt; cnt; j++) &#123; if (i * prime[j] &gt; 1000) break; check[i * prime[j]] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;void solve(int a, int f) &#123; for (int k = 1; k &lt;= a; k++) &#123; int x = k; for (int i = 0; i &lt; cnt; i++) &#123; if (x &lt;= 1) break; while (x % prime[i] == 0) &#123; num[i] += f; x /= prime[i]; &#125; &#125; &#125;&#125;void mul(int x) &#123; for (int i = 1; i &lt;= l; i++) ans[i] *= x; for (int i = 1; i &lt;= l; i++) &#123; ans[i + 1] += ans[i] / mod; ans[i] %= mod; &#125; while (ans[l + 1]) &#123; l++; ans[l + 1] += ans[l] / mod; ans[l] %= mod; &#125;&#125;void print() &#123; for (int i = l; i; i--) if (i == l) printf("%lld", ans[i]); else printf("%06lld", ans[i]);&#125;int main() &#123; getprime(); ans[1] = 1; n = read(); if (n == 1) &#123; int x = read(); if (!x || x == -1) printf("1"); else printf("0"); return 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; d[i] = read(); if (!d[i]) &#123; printf("0"); return 0; &#125; if (d[i] == -1) m++; else &#123; d[i]--; tot += d[i]; &#125; &#125; if (tot &gt; n - 2) &#123; printf("0"); return 0; &#125; solve(n - 2, 1); solve(n - 2 - tot, -1); for (int i = 1; i &lt;= n; i++) solve(d[i], -1); for (int i = 0; i &lt; cnt; i++) while (num[i]--) mul(prime[i]); for (int i = 1; i &lt;= n - 2 - tot; i++) mul(m); print(); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3995][SDOI2015]道路修建-线段树]]></title>
      <url>%2F2017%2F03%2F22%2Fbzoj3995-SDOI2015-%E9%81%93%E8%B7%AF%E4%BF%AE%E5%BB%BA-%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
      <content type="text"><![CDATA[Brief Description 某国有2N个城市，这2N个城市构成了一个2行N列的方格网。现在该国政府有一个旅游发展计划，这个计划需要选定L、R两列(L&lt;=R)，修建若干条专用道路，使得这两列之间（包括这两列）的所有2(R-L+1)个城市中每个城市可以只通过专用道路就可以到达这2(R-L+1)个城市中的任何一个城市。这种专用道路只能在同一行相邻两列的城市或者同一列的两个城市之间修建，且修建需要花费一定的费用。由于该国政府决定尽量缩减开支，因此政府决定，选定L、R后，只修建2(R-L+1)-1条专用道路，使得这些专用道路构成一个树结构。现在你需要帮助该国政府写一个程序，完成这个任务。具体地，该任务包含M个操作，每个操作的格式如下： 1. C x0 y0 x1 y1 w：由于重新对第x0行第y0列的城市和第x1行第y1列的城市之间的情况进行了考察，它们之间修建一条专用道路的花费变成了w； 2. Q L R：若政府选定的两列分别为L、R，询问政府的最小开支。 Algorithm Design 我们考虑使用线段树维护区间\([l,r]\)的最小生成树. 考察区间合并: 可以发现, 区间合并时一共有五种本质不同的情况: 其中相同颜色的是同一个联通块. 然后合并的时候有两种选择, 一种是加一条边, 一种是加两条边, 枚举所有合并情况就好了, 维护这些所有的状态. 其实这个题目和SHOI某年一个题非常相似. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 60110;int l[maxn][2], r[maxn][2], u[maxn], d[maxn];int N, M;struct seg &#123; int a[5]; int l, r;&#125; t[maxn &lt;&lt; 2];void up(int &amp;a, int b) &#123; a = std::min(a, b); &#125;void update(int a[5], int l[5], int r[5], int se, int de) &#123; memset(a, 0x3f, sizeof(t[0].a)); up(a[0], l[0] + r[0] + se); up(a[1], l[0] + r[1] + se); up(a[0], l[0] + r[2] + de); up(a[0], l[0] + r[3] + de); up(a[1], l[0] + r[3] + se); up(a[1], l[0] + r[4] + de); up(a[0], l[1] + r[0] + de); up(a[1], l[1] + r[1] + de); up(a[1], l[1] + r[3] + de); up(a[2], l[2] + r[0] + se); up(a[4], l[2] + r[1] + se); up(a[2], l[2] + r[2] + de); up(a[4], l[2] + r[3] + se); up(a[2], l[2] + r[3] + de); up(a[4], l[2] + r[4] + de); up(a[2], l[3] + r[0] + se); up(a[0], l[3] + r[0] + de); up(a[4], l[3] + r[1] + se); up(a[1], l[3] + r[1] + de); up(a[2], l[3] + r[2] + de); up(a[4], l[3] + r[3] + se); up(a[3], l[3] + r[3] + de); up(a[4], l[3] + r[4] + de); up(a[2], l[4] + r[0] + de); up(a[4], l[4] + r[1] + de); up(a[4], l[4] + r[3] + de);&#125;void build(int k, int l, int r) &#123; t[k].l = l, t[k].r = r; if (l == r) &#123; t[k].a[0] = d[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(k &lt;&lt; 1, l, mid); build(k &lt;&lt; 1 | 1, mid + 1, r); int se = std::min(::r[mid][0], ::r[mid][1]), de = ::r[mid][0] + ::r[mid][1]; update(t[k].a, t[k &lt;&lt; 1].a, t[k &lt;&lt; 1 | 1].a, se, de);&#125;void query(int k, int x, int y, int res[5]) &#123; int l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; memcpy(res, t[k].a, sizeof(t[k].a)); return; &#125; int se = std::min(::r[mid][0], ::r[mid][1]), de = ::r[mid][0] + ::r[mid][1]; int r1[5], r2[5]; if (x &lt;= mid) &#123; if (y &gt; mid) &#123; query(k &lt;&lt; 1, x, y, r1); query(k &lt;&lt; 1 | 1, x, y, r2); update(res, r1, r2, se, de); &#125; else query(k &lt;&lt; 1, x, y, res); &#125; else query(k &lt;&lt; 1 | 1, x, y, res);&#125;void change(int k, int x, int y) &#123; int l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; if (l == r) &#123; t[k].a[0] = d[l]; return; &#125; else &#123; int se = std::min(::r[mid][0], ::r[mid][1]), de = ::r[mid][0] + ::r[mid][1]; update(t[k].a, t[k &lt;&lt; 1].a, t[k &lt;&lt; 1 | 1].a, se, de); &#125; &#125; else &#123; int se = std::min(::r[mid][0], ::r[mid][1]), de = ::r[mid][0] + ::r[mid][1]; if (x &lt;= mid) change(k &lt;&lt; 1, x, y); if (y &gt; mid) change(k &lt;&lt; 1 | 1, x, y); update(t[k].a, t[k &lt;&lt; 1].a, t[k &lt;&lt; 1 | 1].a, se, de); &#125;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d %d", &amp;N, &amp;M); for (int i = 1; i &lt; N; i++) &#123; int x; scanf("%d", &amp;x); r[i][0] = l[i + 1][0] = x; &#125; for (int i = 1; i &lt; N; i++) &#123; int x; scanf("%d", &amp;x); r[i][1] = l[i + 1][1] = x; &#125; for (int i = 1; i &lt;= N; i++) &#123; int x; scanf("%d", &amp;x); u[i] = d[i] = x; &#125; build(1, 1, N); while (M--) &#123; char ch[5]; scanf("%s", ch); if (ch[0] == 'Q') &#123; int A[5], x, y; scanf("%d %d", &amp;x, &amp;y); query(1, x, y, A); printf("%d\n", A[0]); &#125; else &#123; int x0, y0, x1, y1, v; scanf("%d %d %d %d %d", &amp;x0, &amp;y0, &amp;x1, &amp;y1, &amp;v); x0--, x1--; if (x0 == x1) &#123; if (y0 &gt; y1) std::swap(y0, y1); r[y0][x0] = l[y1][x0] = v; change(1, y0, y1); &#125; else &#123; u[y0] = d[y0] = v; change(1, y0, y1); &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3993][SDOI2015]星际战争-二分+最大流]]></title>
      <url>%2F2017%2F03%2F21%2Fbzoj3993-SDOI2015-%E6%98%9F%E9%99%85%E6%88%98%E4%BA%89-%E4%BA%8C%E5%88%86-%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
      <content type="text"><![CDATA[Brief Description 3333年，在银河系的某星球上，X军团和Y军团正在激烈地作战。在战斗的某一阶段，Y军团一共派遣了N个巨型机器人进攻X军团的阵地，其中第i个巨型机器人的装甲值为Ai。当一个巨型机器人的装甲值减少到0或者以下时，这个巨型机器人就被摧毁了。X军团有M个激光武器，其中第i个激光武器每秒可以削减一个巨型机器人Bi的装甲值。激光武器的攻击是连续的。这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y军团看到自己的巨型机器人被X军团一个一个消灭，他们急需下达更多的指令。为了这个目标，Y军团需要知道X军团最少需要用多长时间才能将Y军团的所有巨型机器人摧毁。但是他们不会计算这个问题，因此向你求助。 Algorithm Design 明明是非常水的套路题却卡了很久, 看来是太长时间没有做网络流的题目手生了, 我真的是思博啊, 我这样的人就应该早点滚粗吧Orz 我们考虑直接二分答案, 这样所有武器能输出的最大火力就有了, 按照火力建模, 随便搞搞就有了. 我真是思博啊. 数组开小了…然后不爽一下子开150万就过了Orz Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;const double eps = 1e-9;#define ld long doubleconst int maxn = 110 &lt;&lt; 1;const int inf = 0x3f3f3f;struct edge &#123; int to, next; ld cap; edge(int a = 0, int b = 0, ld c = 0) : to(a), next(b), cap(c) &#123;&#125;&#125; e[1500005];int cnt = 1, n, m, s, t, v;ld L, R;int head[maxn], mi[maxn], A[maxn], B[maxn], tod;ld dist[maxn];void add_edge(int u, int v, ld c) &#123; e[++cnt] = edge(v, head[u], c); head[u] = cnt;&#125;void add(int u, int v, ld c) &#123; add_edge(u, v, c); add_edge(v, u, 0);&#125;void bfs(int s) &#123; std::fill(dist, dist + v, -1); dist[s] = 0; std::queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; i; i = e[i].next) &#123; if (dist[e[i].to] == -1 &amp;&amp; e[i].cap &gt; eps) &#123; dist[e[i].to] = dist[u] + e[i].cap; q.push(e[i].to); &#125; &#125; &#125;&#125;ld dfs(int s, int t, ld flow) &#123; if (s == t) return flow; for (int i = head[s]; i; i = e[i].next) &#123; // printf("%.2f ", e[i].cap); if (e[i].cap &gt; eps &amp;&amp; dist[e[i].to] &gt; dist[s]) &#123; ld d = dfs(e[i].to, t, std::min(e[i].cap, flow)); if (d &gt; eps) &#123; e[i].cap -= d; e[i ^ 1].cap += d; return d; &#125; &#125; &#125; return 0;&#125;ld dinic(int s, int t) &#123; ld flow = 0; while (1) &#123; bfs(s); if (dist[t] == -1) return flow; ld d; while ((d = dfs(s, t, inf))) flow += d; &#125; return flow;&#125;bool check(ld mid) &#123; for (int i = 2; i &lt;= cnt; i += 2) e[i].cap += e[i ^ 1].cap, e[i ^ 1].cap = 0; for (int i = head[s]; i; i = e[i].next) e[i].cap = mid * B[e[i].to]; ld flow = dinic(s, t); return std::fabs(flow - (ld)tod) &lt;= eps;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;m); s = 0, t = n + m + 1, v = t + 1, L = 0, R = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;A[i]); mi[i] = inf; &#125; for (int i = 1; i &lt;= m; i++) scanf("%d", &amp;B[i]); for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; int x; scanf("%d", &amp;x); if (x == 1) &#123; add(i, j + m, inf); mi[j] = std::min(mi[j], B[i]); &#125; &#125; add(0, i, inf); &#125; for (int i = 1; i &lt;= n; i++) &#123; R += A[i] / mi[i]; add(i + m, t, A[i]); tod += A[i]; &#125; // printf("%d\n", tod); R = 5e6; while (R - L &gt; eps) &#123; ld mid = (L + R) / 2; if (check(mid)) R = mid; else L = mid; &#125; printf("%.7Lf", (L + R) / 2);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3994][SDOI2015]约数个数和-数论]]></title>
      <url>%2F2017%2F03%2F21%2Fbzoj3994-SDOI2015-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C-%E6%95%B0%E8%AE%BA%2F</url>
      <content type="text"><![CDATA[Brief Description 计算\(\sum_{i\leqslant n}\sum_{j\leqslant m}\sigma_0(ij)\). Algorithm Design 首先证明一个结论 \[d(ij) = \sum_{i\leqslant n}\sum_{j \leqslant m}[(i,j)=1]\] 我们不显式地证明它, 仅仅直观地考虑每个质数对于答案的贡献就好. 有了这个结论我们开始推式子: \[ \begin{aligned} \sum_{i\leqslant n}\sum_{j\leqslant m}\sigma_0(ij) &amp; = \sum_{i\leqslant n}\sum_{j\leqslant m} \sum_{a|i} \sum_{b|j} [(i,j)=1]\\ &amp; =\sum_{i\leqslant n}\sum_{j\leqslant m}\sum_{a|i}\sum_{b|j}\sum_{x|(i,j)}\mu(x)\\&amp; =\sum_{i\leqslant n}\sum_{j \leqslant m}\sum_{x|i+j}\mu(x)\sigma_0(\frac ix)\sigma_0(\frac jx) \\ &amp;=\sum_{x \leqslant n} \mu(x)\sum_{i \leqslant \lfloor \frac nx \rfloor} \sigma_0(i)\sum_{j \leqslant \lfloor \frac mx \rfloor}\sigma_0(j) \end{aligned} \] 有了最后的式子, 我们就可以开始乱搞了. 复杂度\(O(n+T\sqrt n)\) Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#define ll long longconst int maxn = 50000 + 10;int prime[maxn], tot;int mu[maxn], sigma[maxn], summu[maxn];ll sumsigma[maxn];bool check[maxn];int read() &#123; int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') f = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; return x * f;&#125;void shake() &#123; int minPrimeCnt[maxn]; mu[1] = 1, sigma[1] = 1; for (int i = 2; i &lt; maxn; i++) &#123; if (!check[i]) &#123; prime[tot++] = i; mu[i] = -1; sigma[i] = 2; minPrimeCnt[i] = 1; &#125; for (int j = 0; j &lt; tot; j++) &#123; int x = i * prime[j]; if (x &gt;= maxn) break; check[x] = 1; if (i % prime[j] == 0) &#123; mu[x] = 0; minPrimeCnt[x] = minPrimeCnt[i] + 1; sigma[x] = sigma[i] / (minPrimeCnt[i] + 1) * (minPrimeCnt[x] + 1); break; &#125; else &#123; mu[x] = -mu[i]; sigma[x] = sigma[i] &lt;&lt; 1; minPrimeCnt[x] = 1; &#125; &#125; &#125; summu[0] = 0; for (int i = 1; i &lt; maxn; i++) summu[i] = summu[i - 1] + mu[i]; for (int i = 1; i &lt; maxn; i++) sumsigma[i] = sumsigma[i - 1] + sigma[i];&#125;ll F(int n, int m) &#123; if (n &gt; m) std::swap(n, m); ll ans = 0; for (int i = 1, last = 1; i &lt;= n; i = last + 1) &#123; last = std::min(n / (n / i), m / (m / i)); ans += (summu[last] - summu[i - 1]) * sumsigma[n / i] * sumsigma[m / i]; &#125; return ans;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif shake(); int kase = read(); while (kase--) &#123; int n = read(), m = read(); printf("%lld\n", F(n, m)); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3990][SDOI2015]排序-搜索]]></title>
      <url>%2F2017%2F03%2F21%2Fbzoj3990-SDOI2015-%E6%8E%92%E5%BA%8F-%E6%90%9C%E7%B4%A2%2F</url>
      <content type="text"><![CDATA[Brief Description 小A有一个1-2N的排列A[1..2^N],他希望将A数组从小到大排序,小A可以执行的操作有N种,每种操作最多可以执行一次,对于所有的i(1&lt;=i&lt;=N),第i中操作为将序列从左到右划分为2{N-i+1}段,每段恰好包括2^{i-1}个数,然后整体交换其中两段.小A想知道可以将数组A从小到大排序的不同的操作序列有多少个,小A认为两个操作序列不同,当且仅当操作个数不同,或者至少一个操作不同(种类不同或者操作位置不同). Algorithm Design 首先不难发现操作顺序不影响答案, 我们只需要考察每种操作是否选中, 若选中交换哪两块就好了. 一个合法的操作序列如果有\(n\)个操作, 那么可以给答案\(contribute\ n!\). 我们从小到大考察每一种操作, 首先, 可以知道, 对于操作\(2^i\), 序列肯定已经被分成了\(2^{n-i+1}\)个有序数列, 我们首先检查是否有序, 如果有问题直接\(return\). 然后扫描每个块, 每两个块都必须是有序的, 否则要交换. 如果\(tot \geqslant 4\)那么一定不合法. 代码表达的非常清楚. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;algorithm&gt;#include &lt;cstdio&gt;#define ll long longconst int maxn = 1 &lt;&lt; 13;int n;int a[maxn];ll po[13];ll ans;bool check(int k) &#123; for (int i = 1; i &lt;= (1 &lt;&lt; (n - k)); i++) if (a[(i - 1) * (1 &lt;&lt; k) + 1] + (1 &lt;&lt; (k - 1)) != a[(i - 1) * (1 &lt;&lt; k) + (1 &lt;&lt; (k - 1)) + 1]) return 0; return 1;&#125;void swap(int i, int j, int k) &#123; for (int m = 1; m &lt;= k; m++) std::swap(a[i + m - 1], a[j + m - 1]);&#125;void dfs(int now, int num) &#123; if (now &amp;&amp; !check(now)) return; if (now == n) &#123; ans += po[num]; return; &#125; dfs(now + 1, num); int tmp[5], tot = 0; for (int i = 1; i &lt;= (1 &lt;&lt; (n - now)); i += 2) if (a[i * (1 &lt;&lt; now) + 1] != a[(i - 1) * (1 &lt;&lt; now) + 1] + (1 &lt;&lt; now)) &#123; if (tot == 4) return; tmp[++tot] = i; tmp[++tot] = i + 1; &#125; if (!tot) return; for (int i = 1; i &lt;= tot; i++) for (int j = i + 1; j &lt;= tot; j++) &#123; swap((1 &lt;&lt; now) * (tmp[i] - 1) + 1, (1 &lt;&lt; now) * (tmp[j] - 1) + 1, 1 &lt;&lt; now); dfs(now + 1, num + 1); swap((1 &lt;&lt; now) * (tmp[i] - 1) + 1, (1 &lt;&lt; now) * (tmp[j] - 1) + 1, 1 &lt;&lt; now); &#125;&#125;int main() &#123; // freopen("input", "r", stdin); po[0] = 1; for (int i = 1; i &lt;= 12; i++) po[i] = po[i - 1] * i; scanf("%d", &amp;n); for (int i = 1; i &lt;= 1 &lt;&lt; n; i++) scanf("%d", &amp;a[i]); dfs(0, 0); printf("%lld", ans);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj4518][Sdoi2016]征途-斜率优化]]></title>
      <url>%2F2017%2F03%2F20%2Fbzoj4518-Sdoi2016-%E5%BE%81%E9%80%94-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[Brief Description Pine开始了从S地到T地的征途。 从S地到T地的路可以划分成n段，相邻两段路的分界点设有休息站。 Pine计划用m天到达T地。除第m天外，每一天晚上Pine都必须在休息站过夜。所以，一段路必须在同一天中走完。 Pine希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。 帮助Pine求出最小方差是多少。 设方差是v，可以证明，v×m2是一个整数。为了避免精度误差，输出结果时输出v×m2。 Algorithm Design 不难设计出DP方程, \[f(i, j) = f(i-1, k) + w(j,k)\] \[w(j, k)=f(i-1,k)+(s[k]-s[j])^2\] 很容易得到斜率优化的式子: \[\frac{f(i-1,j)-f(i-1,k)+s_j^2-s_k^2}{2(s_j-s_k)}\leqslant s_i\] 然后乱搞就好辣 # Notice 注意特判分母为0 QAQ 另外吐嘈一下,这个题写\(O(n^3)\)的暴力居然有60分!!! # Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#define ll long longconst ll inf = 99999999999;const int maxn = 60010;// const int maxm = 30010;ll f[2][maxn];int n, m, now = 1;ll s[maxn];ll sq(ll x) &#123; return x * x; &#125;;ll read() &#123; int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') f = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; return x * f;&#125;inline double calck(int i, int j) &#123; if (s[j] - s[i] == 0) return inf; return (f[now ^ 1][j] - f[now ^ 1][i] + sq(s[j]) - sq(s[i])) / ((s[j] - s[i]) * 2);&#125;int que[maxn], head, size, tail;int main() &#123; /* freopen("menci_journey.in", "r", stdin); freopen("menci_journey.out", "w", stdout); */ n = read(); m = read(); for (int i = 1; i &lt;= n; i++) s[i] = read(); for (int i = 1; i &lt;= n; i++) s[i] += s[i - 1]; for (int i = 1; i &lt;= n; i++) f[0][i] = inf; for (int i = 1; i &lt;= m; i++) &#123; head = tail = 0; size = 1; for (int j = 1; j &lt;= n; j++) &#123; while (size &gt;= 2) &#123; int a = que[head]; int b = que[head + 1]; if (calck(a, b) &lt; s[j]) &#123; head++; size--; if (size &lt; 2) break; &#125; else break; &#125; int k = que[head]; f[now][j] = f[now ^ 1][k] + sq(s[j] - s[k]); if (size &gt;= 2) &#123; int x = que[tail]; int y = que[tail - 1]; while (calck(y, x) &gt; calck(x, j)) &#123; tail--; size--; if (size &lt; 2) break; x = que[tail]; y = que[tail - 1]; &#125; &#125; que[++tail] = j; size++; &#125; now ^= 1; &#125; // printf("%lld\n", f[now ^ 1][n]); ll ans = m * f[now ^ 1][n] - s[n] * s[n]; printf("%lld\n", ans);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj4515][Sdoi2016]游戏-树链剖分+李超线段树]]></title>
      <url>%2F2017%2F03%2F20%2Fbzoj4515-Sdoi2016-%E6%B8%B8%E6%88%8F-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
      <content type="text"><![CDATA[Brief Description Alice 和 Bob 在玩一个游戏。 游戏在一棵有 n 个点的树上进行。最初，每个点上都只有一个数字，那个数字是 123456789123456789。 有时，Alice 会选择一条从 s 到 t 的路径，在这条路径上的每一个点上都添加一个数字。对于路径上的一个点 r， 若 r 与 s 的距离是 dis，那么 Alice 在点 r 上添加的数字是 a×dis+b。有时，Bob 会选择一条从 s 到 t 的路径。 他需要先从这条路径上选择一个点，再从那个点上选择一个数字。 Bob 选择的数字越小越好，但大量的数字让 Bob 眼花缭乱。Bob 需要你帮他找出他能够选择的最小的数字。 Algorithm Design 良心题解 Note 写线段树的时候一定要思考使用三段式还是两段式…因为这个被卡了一天. 数据结构题一定要多出几组数据看一看. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;#define ll long longconst ll inf = 123456789123456789LL;const ll maxn = 200100;ll ans;ll n, m, cnt = 1;struct edge &#123; ll to, next; ll w;&#125; e[maxn &lt;&lt; 1];ll head[maxn], size[maxn], belong[maxn], vis[maxn], fa[maxn][18];ll deep[maxn], dep[maxn];ll pl[maxn], que[maxn], sz = 0, fu = 0;void add_edge(ll u, ll v, ll w) &#123; e[++cnt].to = v; e[cnt].w = w; e[cnt].next = head[u]; head[u] = cnt;&#125;void add(ll u, ll v, ll w) &#123; add_edge(u, v, w); add_edge(v, u, w);&#125;void dfs1(ll x) &#123; vis[x] = size[x] = 1; for (ll i = 1; i &lt;= 17; i++) &#123; if (dep[x] &lt; (1 &lt;&lt; i)) break; fa[x][i] = fa[fa[x][i - 1]][i - 1]; &#125; for (ll i = head[x]; i; i = e[i].next) &#123; if (!vis[e[i].to]) &#123; deep[e[i].to] = deep[x] + e[i].w; dep[e[i].to] = dep[x] + 1; fa[e[i].to][0] = x; dfs1(e[i].to); size[x] += size[e[i].to]; &#125; &#125;&#125;void dfs2(ll x, ll chain) &#123; pl[x] = ++sz; que[sz] = x; belong[x] = chain; ll k = 0; for (ll i = head[x]; i; i = e[i].next) if (dep[e[i].to] &gt; dep[x] &amp;&amp; size[k] &lt; size[e[i].to]) k = e[i].to; if (!k) return; dfs2(k, chain); for (ll i = head[x]; i; i = e[i].next) &#123; if (e[i].to != k &amp;&amp; dep[e[i].to] &gt; dep[x]) dfs2(e[i].to, e[i].to); &#125;&#125;struct seg &#123; ll l, r; ll minn, id;&#125; t[maxn &lt;&lt; 2];struct Line &#123; ll k, b; ll id; Line(ll a = 0, ll bb = 0, ll i = 0) : k(a), b(bb), id(i) &#123;&#125; inline ll getf(ll x) &#123; return k * deep[x] + b; &#125;&#125; lim[maxn &lt;&lt; 2];inline bool cmp(Line a, Line b, ll x) &#123; return a.getf(x) != b.getf(x) ? a.getf(x) &lt; b.getf(x) : a.id &lt; b.id;&#125;void build(ll k, ll l, ll r) &#123; t[k].l = l, t[k].r = r, t[k].minn = inf; if (l == r) &#123; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(k &lt;&lt; 1, l, mid); build(k &lt;&lt; 1 | 1, mid + 1, r);&#125;void up(ll k) &#123; ll l = t[k].l, r = t[k].r; if (l &lt; r) &#123; t[k].minn = std::min(t[k &lt;&lt; 1 | 1].minn, t[k &lt;&lt; 1].minn); &#125; else t[k].minn = inf; if (t[k].id) &#123; t[k].minn = std::min(t[k].minn, std::min(lim[t[k].id].getf(que[l]), lim[t[k].id].getf(que[r]))); &#125;&#125;void update(ll k, Line v) &#123; ll l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; if (t[k].id == 0) &#123; t[k].id = v.id; &#125; else &#123; Line tmp = lim[t[k].id]; ll x1 = v.getf(que[l]), y1 = v.getf(que[r]); ll x2 = tmp.getf(que[l]), y2 = tmp.getf(que[r]); if (x1 &lt;= x2 &amp;&amp; y1 &lt;= y2) &#123; t[k].id = v.id; &#125; else if (x1 &gt;= x2 &amp;&amp; y1 &gt;= y2) return; else if (v.k &lt; tmp.k) &#123; ll tp = (v.b - tmp.b) / (tmp.k - v.k) + 1; if (tp &lt;= deep[que[mid]]) &#123; Line wtf = lim[t[k].id]; t[k].id = v.id; v = wtf; update(k &lt;&lt; 1, v); &#125; else update(k &lt;&lt; 1 | 1, v); &#125; else &#123; ll tp = (tmp.b - v.b - 1) / (v.k - tmp.k); if (tp &gt; deep[que[mid]]) &#123; Line wtf = lim[t[k].id]; t[k].id = v.id; v = wtf; update(k &lt;&lt; 1 | 1, v); &#125; else update(k &lt;&lt; 1, v); &#125; &#125; up(k);&#125;void Insert(ll k, ll x, ll y, Line v) &#123; ll l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; update(k, v); return; &#125; if (x &lt;= mid) Insert(k &lt;&lt; 1, x, y, v); if (y &gt; mid) Insert(k &lt;&lt; 1 | 1, x, y, v); up(k);&#125;void Alice(ll s, ll t, Line v) &#123; while (belong[s] != belong[t]) &#123; Insert(1, pl[belong[s]], pl[s], v); s = fa[belong[s]][0]; &#125; Insert(1, pl[t], pl[s], v);&#125;ll lca(ll x, ll y) &#123; for (; belong[x] != belong[y]; x = fa[belong[x]][0]) if (deep[belong[x]] &lt; deep[belong[y]]) std::swap(x, y); return (deep[x] &lt; deep[y]) ? x : y;&#125;void query(ll k, ll x, ll y) &#123; ll l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; if (x == l &amp;&amp; r == y) &#123; ans = std::min(ans, t[k].minn); return; &#125; if (t[k].id) ans = std::min( ans, std::min(lim[t[k].id].getf(que[x]), lim[t[k].id].getf(que[y]))); if (y &lt;= mid) query(k &lt;&lt; 1, x, y); else if (x &gt; mid) query(k &lt;&lt; 1 | 1, x, y); else &#123; query(k &lt;&lt; 1, x, mid); query(k &lt;&lt; 1 | 1, mid + 1, y); &#125;&#125;void Bob(ll x, ll f) &#123; while (belong[x] != belong[f]) &#123; query(1, pl[belong[x]], pl[x]); x = fa[belong[x]][0]; &#125; query(1, pl[f], pl[x]);&#125;int main() &#123; freopen("menci_game.in", "r", stdin); freopen("menci_game.out", "w", stdout); scanf("%lld %lld", &amp;n, &amp;m); for (ll i = 1; i &lt; n; i++) &#123; ll u, v; ll w; scanf("%lld %lld %lld", &amp;u, &amp;v, &amp;w); add(u, v, w); &#125; dfs1(1); dfs2(1, 1); build(1, 1, sz); while (m--) &#123; ll opt, s, t; scanf("%lld %lld %lld", &amp;opt, &amp;s, &amp;t); if (opt == 1) &#123; ll a, b; scanf("%lld %lld", &amp;a, &amp;b); fu++; lim[fu] = Line(-a, b + a * deep[s], fu); ll l = lca(s, t); Alice(s, l, lim[fu]); fu++; lim[fu] = Line(a, lim[fu - 1].b - 2 * a * deep[l], fu); Alice(t, l, lim[fu]); &#125; else &#123; ans = inf; for (; belong[s] != belong[t]; s = fa[belong[s]][0]) &#123; if (deep[belong[s]] &lt; deep[belong[t]]) std::swap(s, t); query(1, pl[belong[s]], pl[s]); &#125; if (deep[s] &gt; deep[t]) std::swap(s, t); query(1, pl[s], pl[t]); printf("%lld\n", ans); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3004][SDOI2012]吊灯——樹形DP]]></title>
      <url>%2F2017%2F03%2F19%2Fbzoj3004-SDOI2012-%E5%90%8A%E7%81%AF%E2%80%94%E2%80%94%E6%A8%B9%E5%BD%A2DP%2F</url>
      <content type="text"><![CDATA[Brief Description 給定一棵樹, 判斷是否可以將其分成\(\frac{n}{k}\)個聯通塊, 其中每個聯通塊的大小均爲k. Algorithm Design 我們有一個結論: k可行iff存在\(\frac{n}{k}\)個點, 以這些點爲根的子樹大小爲k或k的倍數. 讀者可以自行yy一下證明. 有了這個結論之後, 我們可以算出每個size, 用一個桶統計一下就好了. Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1200000;int fa[maxn], n, divide[maxn], size[maxn], f[maxn], tot = 0;void fuck(int n) &#123; int i; for (i = 1; i * i &lt; n; i++) &#123; if (n % i == 0) &#123; divide[tot++] = i; divide[tot++] = n / i; &#125; &#125; if (i * i == n) divide[tot++] = i; std::sort(divide, divide + tot);&#125;int main() &#123; // freopen("sdoi12_divide.in", "r", stdin); // freopen("sdoi12_divide.out", "w", stdout); scanf("%d", &amp;n); char ch = getchar(); int cnt = 0; while (cnt &lt; (n - 1)) &#123; int x = 0; while (!isdigit(ch)) ch = getchar(); while (isdigit(ch)) &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; cnt++; fa[cnt + 1] = x; &#125; fuck(n); for (int T = 1; T &lt;= 10; T++) &#123; printf("Case #%d:\n", T); memset(size, 0, sizeof(size)); memset(f, 0, sizeof(f)); for (int i = 2; i &lt;= n; i++) &#123; if (T != 1) &#123; fa[i] = (fa[i] + 19940105) % (i - 1) + 1; &#125; &#125; for (int i = n; i; i--) size[fa[i]] += ++size[i]; for (int i = 1; i &lt;= n; i++) f[size[i]]++; for (int i = 0; i &lt; tot; i++) &#123; int tmp = 0; for (int j = divide[i]; j &lt;= n; j += divide[i]) tmp += f[j]; if (tmp == n / divide[i]) &#123; printf("%d\n", divide[i]); &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SDOI 2012 Round 2 Day 1(bzoj3004~bzoj3006)测试总结+简单题解]]></title>
      <url>%2F2017%2F03%2F18%2FSDOI-2012-Round-2-Day-1-bzoj3004-bzoj3006-%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93-%E7%AE%80%E5%8D%95%E9%A2%98%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[上午7:00到12:00胡策了sdoi 2012 round 2 day1的题目,感觉非常难,同时感觉做题习惯非常不好. 考试开始之后, 我首先通读了一遍题目. 第一题一开始看不出来是什么类型的题目, 想要枚举一下, 再check答案. 第二题一眼就是数据结构题目, 我想了想, 发现使用splay也许可以做… 然后迅速地扫一眼第三题, 发现好象是计算几何? 我不会计算几何啊, 所以就放弃第三题了. 我开始的想法是: 使用splay维护每个区间最开始加的和之后每一次加的, 然后感觉可以pushdown, 就开始写了…(然而后来发现不可以Orz) 然后两个小时以后, splay的最初版本写完了, 然而bug一大堆, 调试了3个小时, 发现简直不可维护, 因为max值无法维护….然后就弃疗了… 最后是40分,在当年的sdoi排rank26吧…然而现在的sdoi已经今非昔比了, 厉害的选手越来越多,这样下去根本不行啊…. 已经在考虑放弃oi了… 总结: * 拿到题目以后已经要先通读一遍, 把所有能写的暴力写完, 假设第一题和第三题我都写了暴力, 分数也许能上150 * 一定要想好再写!!!不要把splay写完了以后才发现信息根本无法维护!!!要使用思考量取代代码量!!! * 模板还是不熟悉. splay写那么长时间真的非常沙茶… * 想不出好的维护方法的数据结构一定要考虑分块!!!! 明天还有Day2,希望可以翻盘.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3238][Ahoi2013]差异——后缀自动机]]></title>
      <url>%2F2017%2F03%2F15%2Fbzoj3238-Ahoi2013-%E5%B7%AE%E5%BC%82%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
      <content type="text"><![CDATA[Brief Description # Algorithm Design 下面给出后缀自动机的一个性质： &gt;两个子串的最长公共后缀，位于这两个串对应的状态在parent树上的lca状态上。并且最长公共后缀的长度就是lca状态的len。 证明：对于一个串，他的所有祖先节点都是他的后缀，并且深度越大，长度越长，由此不难说明两个子串的最长公共后缀一定在lca状态上。考察这个lca，他代表的所有子串一定都是两个子串的公共后缀，我们直接取最大的就可以了。 有了这个性质，我们就可以开始乱搞了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define ll long longconst ll maxn = 500100 &lt;&lt; 1;char s[maxn], str[maxn];ll head[maxn], f[maxn];ll ans;ll n, cnt = 1;struct edge &#123; ll to, next;&#125; e[maxn];void add_edge(ll u, ll v) &#123; e[++cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;&#125;struct Suffix_Automaton &#123; ll fa[maxn], trans[maxn][26], len[maxn], right[maxn]; ll last, root, sz; bool flag[maxn]; void init() &#123; memset(flag, 0, sizeof(flag)); sz = 0; last = root = ++sz; &#125; void insert(ll x) &#123; ll p = last, np = last = ++sz; len[np] = len[p] + 1; flag[np] = 1; right[np] = right[p] + 1; for (; !trans[p][x]; p = fa[p]) trans[p][x] = np; if (p == 0) fa[np] = root; else &#123; ll q = trans[p][x]; if (len[q] == len[p] + 1) &#123; fa[np] = q; &#125; else &#123; ll nq = ++sz; fa[nq] = fa[q]; memcpy(trans[nq], trans[q], sizeof(trans[q])); len[nq] = len[p] + 1; fa[q] = fa[np] = nq; for (; trans[p][x] == q; p = fa[p]) trans[p][x] = nq; &#125; &#125; &#125; void pre() &#123; for (ll i = 1; i &lt;= sz; i++) &#123; if (fa[i]) add_edge(fa[i], i); &#125; &#125; void print() &#123; for (ll i = 1; i &lt;= sz; i++) &#123; printf("%3lld ", i); &#125; printf("\n"); for (ll i = 1; i &lt;= sz; i++) &#123; printf("%3lld ", len[i]); &#125; printf("\n"); for (ll i = 1; i &lt;= sz; i++) if (flag[i]) &#123; printf("%lld:", i); for (ll j = 1; j &lt;= len[i]; j++) printf("%c", str[right[i] - (len[i] - j + 1) + 1]); printf("\n"); &#125; printf("\n"); &#125;&#125; sam;void dfs(ll x) &#123; ll ct = 0; f[x] = sam.flag[x] ? 1 : 0; for (ll i = head[x]; i; i = e[i].next) &#123; dfs(e[i].to); ans -= 1ll * 2 * (1ll * f[e[i].to] * ct) * (sam.len[x]); ct += f[e[i].to]; &#125; if (f[x] == 1) &#123; ans -= 1ll * 2 * (1ll * ct) * (sam.len[x]); &#125; f[x] += ct;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%s", s + 1); n = strlen(s + 1); sam.init(); for (ll i = 1; i &lt;= n; i++) &#123; ans += (n * i) - i * i + ((n * n - i * i + n - i) &gt;&gt; 1); str[i] = s[n - i + 1]; &#125; for (ll i = 1; i &lt;= n; i++) sam.insert(str[i] - 'a'); sam.pre(); // sam.print(); // printf("%lld\n", ans); dfs(sam.root); printf("%lld\n", ans);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BZOJ 100题纪念]]></title>
      <url>%2F2017%2F03%2F15%2FBZOJ-100%E9%A2%98%E7%BA%AA%E5%BF%B5%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3676][Apio2014]回文串——Manacher+后缀自动机+倍增]]></title>
      <url>%2F2017%2F03%2F15%2Fbzoj3676-Apio2014-%E5%9B%9E%E6%96%87%E4%B8%B2%E2%80%94%E2%80%94Manacher-%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%80%8D%E5%A2%9E%2F</url>
      <content type="text"><![CDATA[Brief Description 一个回文串的value定义为这个回文串的长度乘以出现次数。给定一个字符串，求\(value_{max}\)。 Algorithm Design 我们使用Manacher暴力算出所有的回文子串，放在SAM里倍增，大力算贡献就好了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;algorithm&gt;#include &lt;cstdio&gt;#define ll long long#include &lt;cstring&gt;const int maxn = 600010;int n;ll ans;int p[maxn];char str[maxn];struct Suffix_Automaton &#123; int trans[maxn][26], fa[maxn][20], pos[maxn], len[maxn], size[maxn]; int last, root, sz; int v[maxn], q[maxn], dep[maxn]; void init() &#123; sz = 0; last = root = ++sz; &#125; void insert(int x, int id) &#123; int p = last, np = last = ++sz; len[np] = len[p] + 1; pos[id] = np; size[np] = 1; for (; !trans[p][x]; p = fa[p][0]) trans[p][x] = np; if (p == 0) fa[np][0] = root; else &#123; int q = trans[p][x]; if (len[q] == len[p] + 1) &#123; fa[np][0] = q; &#125; else &#123; int nq = ++sz; for (int i = 0; i &lt; 26; i++) trans[nq][i] = trans[q][i]; fa[nq][0] = fa[q][0]; len[nq] = len[p] + 1; fa[q][0] = fa[np][0] = nq; for (; trans[p][x] == q; p = fa[p][0]) trans[p][x] = nq; &#125; &#125; &#125; void pre() &#123; for (int i = 1; i &lt;= sz; i++) v[len[i]]++; for (int i = 1; i &lt;= n; i++) v[i] += v[i - 1]; for (int i = sz; i &gt;= 1; i--) q[v[len[i]]--] = i; for (int i = sz; i &gt;= 1; i--) &#123; int t = q[i]; size[fa[t][0]] += size[t]; &#125; for (int i = 1; i &lt;= sz; i++) &#123; int t = q[i]; dep[t] = dep[fa[t][0]] + 1; for (int j = 1; (1 &lt;&lt; j) &lt;= dep[t]; j++) fa[t][i] = fa[fa[t][i - 1]][i - 1]; &#125; &#125; void query(int l, int r) &#123; int ret = pos[r]; for (int i = 19; i &gt;= 0; i--) &#123; int t = fa[ret][i]; if (len[t] &gt;= r - l + 1) ret = t; &#125; ans = std::max(ans, (ll)size[ret] * (r - l + 1)); &#125;&#125; sam;void manacher() &#123; int mx = 1, id = 1; for (int i = n; i; i--) str[i * 2] = '#', str[i * 2 - 1] = str[i]; n &lt;&lt;= 1; for (int i = 1; i &lt;= n; i++) &#123; p[i] = std::min(p[id * 2 - i], mx - i); while (i - p[i] &gt; 0 &amp;&amp; str[i - p[i]] == str[i + p[i]]) &#123; int al = (i - p[i]) / 2 + 1; int ar = (i + p[i] + 1) / 2; // printf("%d %d\n", al, ar); sam.query(al, ar); p[i]++; &#125; if (i + p[i] &gt; mx) mx = i + p[i], id = i; &#125;&#125;int main() &#123;#ifndef ONLINE_JUDGE// freopen("input", "r", stdin);#endif scanf("%s", str + 1); n = strlen(str + 1); str[0] = '+', str[n + 1] = '-'; sam.init(); for (int i = 1; i &lt;= n; i++) &#123; sam.insert(str[i] - 'a', i); &#125; sam.pre(); manacher(); printf("%lld\n", ans);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3277==bzoj3473]出现k次子串计数——广义后缀自动机+STL]]></title>
      <url>%2F2017%2F03%2F15%2Fbzoj3277-bzoj3473-%E5%87%BA%E7%8E%B0k%E6%AC%A1%E5%AD%90%E4%B8%B2%E8%AE%A1%E6%95%B0%E2%80%94%E2%80%94%E5%B9%BF%E4%B9%89%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-STL%2F</url>
      <content type="text"><![CDATA[Brief Description 给定n个字符串，对于每个字符串，您需要求出在所有字符串中出现次数大于等于k次的子串个数。 Algorithm Design 先建立一个广义后缀自动机，什么是广义后缀自动机？就是所有主串一起建立的一个后缀自动机。 广义后缀自动机的建立很简单，对于每个串，该怎么增量建立自动机就怎么建立，只不过为每个节点维护一个set保存这个节点的状态在那些字符串中出现过。当一个串增量构建完毕后，将后缀自动机的last指针指向后缀自动机的根即可进行下一发字符串的增量构建，这样就建出来了一发广义后缀自动机。 考虑一个节点，如果他在x个字符串中出现过，那么他的fa指针所指向的节点所代表的状态出现过的次数一定不小于他。 并且我们已经为每个节点维护了一个set来记录在那些字符串中出现过，那么我们只需要自下向上合并set集合即可，在这之前需要整理出parent树的具体形态，然后一遍dfs，逆序处理set的启发式合并即可。 统计答案只需把每个字符串在自动机上跑，跑到一个节点发现出现次数&lt;K就往fa指针那里跳，直到符合条件。这时候贡献的答案就是当前节点的len属性的值了. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;string&gt;const int maxn = 200010;using std::set;using std::string;#define ll long longset&lt;int&gt; d[maxn];set&lt;int&gt;::iterator it;int n, K, tot = 1, head[maxn], sum[maxn];struct edge &#123; int to, next;&#125; e[maxn * 6];string str[maxn];struct Suffix_Automaton &#123; int trans[maxn][26], len[maxn], sz; int fa[maxn], last, root; void init() &#123; tot = 0; last = root = ++sz; &#125; void add(int c, int id) &#123; int p = last, np = last = ++sz; len[np] = len[p] + 1; d[np].insert(id); while (p &amp;&amp; !trans[p][c]) trans[p][c] = np, p = fa[p]; if (!p) fa[np] = root; else &#123; int q = trans[p][c]; if (len[q] == len[p] + 1) fa[np] = q; else &#123; int nq = ++sz; len[nq] = len[p] + 1; fa[nq] = fa[q]; for (int i = 0; i &lt; 26; i++) trans[nq][i] = trans[q][i]; fa[q] = fa[np] = nq; while (trans[p][c] == q) trans[p][c] = nq, p = fa[p]; &#125; &#125; &#125; void print() &#123; for (int i = 1; i &lt;= sz; i++) &#123; std::cout &lt;&lt; fa[i] &lt;&lt; ' '; &#125; std::cout &lt;&lt; std::endl; for (int i = 1; i &lt;= sz; i++) printf("%d ", sum[i]); printf("\n"); &#125;&#125; sam;void dfs(int x) &#123; for (int i = head[x]; i; i = e[i].next) &#123; int v = e[i].to; dfs(v); for (it = d[v].begin(); it != d[v].end(); it++) d[x].insert(*it); &#125; sum[x] = d[x].size();&#125;void add_edge(int from, int to) &#123; e[++tot].to = to; e[tot].next = head[from]; head[from] = tot;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;K); sam.init(); for (int i = 1; i &lt;= n; i++) &#123; std::cin &gt;&gt; str[i]; int len = str[i].length(); for (int j = 0; j &lt; len; j++) sam.add(str[i][j] - 'a', i); sam.last = sam.root; &#125; for (int i = 1; i &lt;= sam.sz; i++) if (sam.fa[i]) add_edge(sam.fa[i], i); dfs(sam.root); // sam.print(); if (K &gt; n) &#123; for (int i = 1; i &lt;= n; i++) printf("0 "); return 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; ll ans = 0; int now = sam.root, len = str[i].length(); for (int j = 0; j &lt; len; j++) &#123; now = sam.trans[now][str[i][j] - 'a']; while (sum[now] &lt; K) now = sam.fa[now]; ans += sam.len[now]; &#125; printf("%lld ", ans); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[后缀自动机学习笔记]]></title>
      <url>%2F2017%2F03%2F15%2F%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[昨天看了一下午后缀自动机，终于有了一点心得，特地来做一下笔记。 #Definitions 首先不加证明地给出几个定义和引理： ##DFA(有限状态自动机) 有限状态自动机的功能是识别字符串，令一个自动机A，若它能识别字符串S，就记为A(S)=True，否则A(S)=False。 自动机由五个部分组成，alpha：字符集，state：状态集合，init：初始状态，end：结束状态集合，trans：状态转移函数。 不妨令trans(s,ch)表示当前状态是s，在读入字符ch之后，所到达的状态。 如果trans(s,ch)这个转移不存在，为了方便，不妨设其为null，同时null只能转移到null。 null表示不存在的状态。 同时令trans(s,str)表示当前状态是s，在读入字符串str之后，所到达的状态。 ##后缀自动机 就是能够识别一个串的所有后缀的自动机。后面我们可以知道，他也可以识别子串。 ##right集合 对于一个状态，我们认为这个状态代表了一个前缀长度为\((len_{fa}, len_s]\)的所有后缀，他们的right集合都是相同的。 对于right集合，我们有两个状态的right集合要么不相交，要么一个是另一个的子集。所以我们结合这种关系，可以构造出一棵parent树，其中fa是right阶最小的包含孩子的状态。可以发现，考虑到每个状态到start的路径是连续的，所以这个parent树就是反串的后缀树。 后缀自动机的目标就是去维护所有状态的上述性质，并且考虑到状态是连续的子串，我们还需要去维护他们之间的转移。 #How to construct 我们采用增量法来构造后缀自动机。 假设现在的状态为p，新的状态为np，从p的所有子串映射到np的所有子串要添加的字符为c，我们显然首先要添加一条从p到np标号为c的边，然后，因为每个状态到根的路径都代表了上一个字符的后缀，所以，这条路径上的所有节点增加一个字符之后，都可以成为新串的后缀，都有可能带来right集合的改变，既然我们要维护right集合，我们就要去查看这些状态。 考察这条路径上的节点\(p_i\)，假设\(p_i\)没有一条标号为c的边，那很好，我们直接连边\(p_i\)到q即可。 对于节点\(p_i\)已经有了一条标号为c的边，我们设原来可以转移到状态q，那么我们新增的字符c就一定会带来q的改变。 有两种情况： 1. 如果\(len_q = len_{p_i}+1\)，那么q的所有子串都是由p转移过来的，那么我们直接在right集合中新增一个最后的节点就好了。 2. 如果\(len_q &gt; len_{p_i} + 1\)，在这种情况下，q的子串不一定从p转移过来，我们把这些子串拆成两个集合，第一个集合为从p转移过来的，记为nq，即\(len_{nq} = len_{p_i}+1\)，考虑到p的所有fa都是p的后缀，所以我们把所有的fa全部把连向q的边改为连向nq，根据之前的推理，q仍然有边连向。nq的除了right的所有属性与q一致。 考虑这样做之后的par树关系，不难发现，我们应该设\(fa_q = fa_{np} = q\)。 Application 下面不加证明地给出几个SAM的性质。 1. 每个状态s代表的串的长度是区间\((len_{fa_s}, len_s]\)。 2. 每个状态s代表的所有串在原串中的出现次数及right集合相同。 right集合可以使用平衡树启发式合并来求。 3. 在parent树中，每个状态的right集合是他的父状态right集合的子集。 4. SAM的parent树是原串的反向前缀树。 反向前缀树的定义是：把每一个前缀的反串插入到一个trie中，并且把没有分支的链合并。 这个性质是容易发现的。考虑一个前缀在后缀自动机上的状态，我们一直沿fa指针走，每次都会变成当前串的一个后缀，直到空串，反过来看这个过程，就是在沿着反向前缀树从上往下走。 那么，如果我们求出反串的SAM，那么他的parent树就是原串的后缀树。 Materials 下面列出了我在学习SAM的时候使用的一些学习资料。 [1]陈立杰冬令营营员交流 [2]fanhq的博客 [3]后缀自动机及其应用——张天扬,2015国家队论文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj4516][Sdoi2016]生成魔咒——后缀自动机]]></title>
      <url>%2F2017%2F03%2F14%2Fbzoj4516-Sdoi2016-%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
      <content type="text"><![CDATA[Brief Description 魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 1、2 拼凑起来形成一个魔咒串 [1,2]。 一个魔咒串 S 的非空字串被称为魔咒串 S 的生成魔咒。 例如 S=[1,2,1] 时，它的生成魔咒有 [1]、[2]、[1,2]、[2,1]、[1,2,1] 五种。S=[1,1,1] 时，它的生成魔咒有 [1]、 [1,1]、[1,1,1] 三种。最初 S 为空串。共进行 n 次操作，每次操作是在 S 的结尾加入一个魔咒字符。每次操作后都 需要求出，当前的魔咒串 S 共有多少种生成魔咒。 Algorithm Design 后缀自动机。每次加入一个新的节点的时候统计。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;map&gt;const int maxn = 100010;int n, m, tot = 1, last = 1;#define ll long longll ans;int len[maxn &lt;&lt; 1], fa[maxn &lt;&lt; 1];std::map&lt;int, int&gt; ch[maxn &lt;&lt; 1];int calc(int x) &#123; return len[x] - len[fa[x]]; &#125;void insert(int x) &#123; int p = last, np = last = ++tot; len[np] = len[p] + 1; while (p &amp;&amp; !ch[p][x]) ch[p][x] = np, p = fa[p]; if (!p) fa[np] = 1, ans += calc(np); else &#123; int q = ch[p][x]; if (len[p] + 1 == len[q]) fa[np] = q, ans += calc(np); else &#123; int nq = ++tot; len[nq] = len[p] + 1; ch[nq] = ch[q]; fa[nq] = fa[q]; ans += calc(nq) - calc(q); fa[q] = fa[np] = nq; ans += calc(np) + calc(q); while (p &amp;&amp; ch[p][x] == q) ch[p][x] = nq, p = fa[p]; &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); insert(x); printf("%lld\n", ans); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1692][Usaco2007 Dec]队列变换——贪心+后缀数组]]></title>
      <url>%2F2017%2F03%2F14%2Fbzoj1692-Usaco2007-Dec-%E9%98%9F%E5%88%97%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
      <content type="text"><![CDATA[Brief Description 给定一个数列，您每次可以把数列的最前面的数或最后面的数移动到新数列的开头，使得新数列字典序最小。输出这个新序列。 Algorithm Design 首先我们可以使用贪心得到一个\(O(n^2)\)的算法。 然后我们可以使用后缀数组把这个题目做成\(\Theta(nlogn)\)（倍增）或者\(\Theta(n)\)（DC3） 不过这个题目数据太水，第一种方法就可以水过了，简直坑。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int maxn = 30010 &lt;&lt; 1;int n, p, q, pp, qq, k;int v[maxn], a[maxn], sa[2][maxn], rank[2][maxn];void getsa(int sa[maxn], int rank[maxn], int Sa[maxn], int Rank[maxn]) &#123; for (int i = 1; i &lt;= n; i++) v[rank[sa[i]]] = i; for (int i = n; i &gt;= 1; i--) if (sa[i] &gt; k) Sa[v[rank[sa[i] - k]]--] = sa[i] - k; for (int i = n - k + 1; i &lt;= n; i++) Sa[v[rank[i]]--] = i; for (int i = 1; i &lt;= n; i++) Rank[Sa[i]] = Rank[Sa[i - 1]] + (rank[Sa[i - 1]] != rank[Sa[i]] || rank[Sa[i - 1] + k] != rank[Sa[i] + k]);&#125;void da() &#123; p = 0, q = 1, k = 1; for (int i = 1; i &lt;= n; i++) v[a[i]]++; for (int i = 1; i &lt;= 26; i++) v[i] += v[i - 1]; for (int i = 1; i &lt;= n; i++) sa[p][v[a[i]]--] = i; for (int i = 1; i &lt;= n; i++) rank[p][sa[p][i]] = rank[p][sa[p][i - 1]] + (a[sa[p][i]] != a[sa[p][i - 1]]); while (k &lt; n) &#123; getsa(sa[p], rank[p], sa[q], rank[q]); p ^= 1; q ^= 1; k &lt;&lt;= 1; &#125;&#125;void solve() &#123; int l = 1, r = n &gt;&gt; 1, cnt = 0; while (l != r) &#123; pp = a[l], qq = a[r]; if (pp != qq) &#123; if (pp &lt; qq) &#123; printf("%c", pp + 'A' - 1); l++; &#125; else &#123; printf("%c", qq + 'A' - 1); r--; &#125; cnt++; &#125; else &#123; int r1 = rank[p][l], r2 = rank[p][n - r + 1]; if (r1 &lt; r2) &#123; printf("%c", pp + 'A' - 1); l++; &#125; else &#123; printf("%c", qq + 'A' - 1); r--; &#125; cnt++; &#125; if (cnt == 80) &#123; printf("\n"); cnt = 0; &#125; &#125; printf("%c", a[l] + 'A' - 1);&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; char ch[10]; scanf("%s", ch); a[i] = ch[0] - 'A' + 1; a[n * 2 - i + 1] = a[i]; &#125; n &lt;&lt;= 1; da(); solve();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2251][2010Beijing Wc]外星联络——后缀数组+暴力求解]]></title>
      <url>%2F2017%2F03%2F14%2Fbzoj2251-2010Beijing-Wc-%E5%A4%96%E6%98%9F%E8%81%94%E7%BB%9C%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84-%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[Brief Description 找到 01 串中所有重复出现次数大于 1 的子串。并按字典序输出他们的出现次数。 Algorithm Design 求出后缀数组之后，枚举每一个后缀，对于每个后缀从height[i]+1枚举（因为height[i]之前已经计算过了），然后对于这样的每个前缀看一看上下能够分别延伸到哪里。 我不会分析复杂度，但是这个算法还是能跑得过得。 Notice 开始想了一个复杂度低但是错误的算法，然后思路就被局限住了。所以，以后想不到好的算法的时候一定要先想一个最暴力的暴力，说不定就过了呢。。。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 3010;int a[maxn], sa[2][maxn], rank[2][maxn], height[maxn];int n, p, q, k, K;char str[maxn];int v[maxn];void getsa(int sa[maxn], int rank[maxn], int Sa[maxn], int Rank[maxn]) &#123; for (int i = 1; i &lt;= n; i++) v[rank[sa[i]]] = i; for (int i = n; i &gt;= 1; i--) if (sa[i] &gt; k) Sa[v[rank[sa[i] - k]]--] = sa[i] - k; for (int i = n - k + 1; i &lt;= n; i++) Sa[v[rank[i]]--] = i; for (int i = 1; i &lt;= n; i++) Rank[Sa[i]] = Rank[Sa[i - 1]] + (rank[Sa[i - 1]] != rank[Sa[i]] || rank[Sa[i - 1] + k] != rank[Sa[i] + k]);&#125;void getheight(int sa[maxn], int rank[maxn]) &#123; int i, k = 0; for (i = 1; i &lt;= n; height[rank[i++]] = k) &#123; if (k) k--; int j = sa[rank[i] - 1]; while (a[i + k] == a[j + k]) k++; &#125;&#125;void da() &#123; p = 0, q = 1, k = 1; for (int i = 1; i &lt;= n; i++) v[a[i]]++; for (int i = 1; i &lt;= 2; i++) v[i] += v[i - 1]; for (int i = 1; i &lt;= n; i++) sa[p][v[a[i]]--] = i; for (int i = 1; i &lt;= n; i++) rank[p][sa[p][i]] = rank[p][sa[p][i - 1]] + (a[sa[p][i - 1]] != a[sa[p][i]]); while (k &lt; n) &#123; getsa(sa[p], rank[p], sa[q], rank[q]); p ^= 1; q ^= 1; k &lt;&lt;= 1; &#125; getheight(sa[p], rank[p]);&#125;void solve() &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = height[i] + 1; sa[p][i] + j - 1 &lt;= n; j++) &#123; int l, r; for (l = i; l &gt;= 1 &amp;&amp; height[l] &gt;= j; l--) ; for (r = i + 1; r &lt;= n &amp;&amp; height[r] &gt;= j; r++) ; if (r - l &gt; 1) printf("%d\n", r - l); &#125; &#125;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d %s", &amp;n, str + 1); for (int i = 1; i &lt;= n; i++) a[i] = str[i] - '0'; a[0] = 3; for (int i = n + 1; i &lt; maxn; i++) a[i] = 3; da(); solve();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1717][Usaco2006 Dec]Milk Patterns 产奶的模式——后缀数组]]></title>
      <url>%2F2017%2F03%2F13%2Fbzoj1717-Usaco2006-Dec-Milk-Patterns-%E4%BA%A7%E5%A5%B6%E7%9A%84%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
      <content type="text"><![CDATA[Brief Description 给定一个字符串，求至少出现k次的最长重复子串。 Algorithm Design 先二分答案，然后将后缀分成若干组。判断有没有一个组的后缀个数不小于k。如果有，那么存在k个相同的子串满足条件，否则不存在。这个做法的时间复杂度为\(\Theta(nlgn)\). Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;const int maxn = 20010;int a[maxn], sa[2][maxn], rank[2][maxn], height[maxn];int n, K, k, m, p, q;int v[1000100];void calc(int sa[maxn], int rank[maxn], int Sa[maxn], int Rank[maxn]) &#123; for (int i = 1; i &lt;= n; i++) v[rank[sa[i]]] = i; for (int i = n; i &gt;= 1; i--) if (sa[i] &gt; k) Sa[v[rank[sa[i] - k]]--] = sa[i] - k; for (int i = n - k + 1; i &lt;= n; i++) Sa[v[rank[i]]--] = i; for (int i = 1; i &lt;= n; i++) Rank[Sa[i]] = Rank[Sa[i - 1]] + (rank[Sa[i]] != rank[Sa[i - 1]] || rank[Sa[i] + k] != rank[Sa[i - 1] + k]);&#125;void calh(int sa[maxn], int rank[maxn]) &#123; int i, j, k = 0; for (i = 1; i &lt;= n; height[rank[i++]] = k) for (k ? k-- : 0, j = sa[rank[i] - 1]; a[i + k] == a[j + k]; k++) ; return;&#125;void da() &#123; m = 1000010, p = 0, q = 1, k = 1; for (int i = 1; i &lt;= n; i++) v[a[i]]++; for (int i = 1; i &lt;= m; i++) v[i] += v[i - 1]; for (int i = 1; i &lt;= n; i++) sa[p][v[a[i]]--] = i; for (int i = 1; i &lt;= n; i++) rank[p][sa[p][i]] = rank[p][sa[p][i - 1]] + (a[sa[p][i - 1]] != a[sa[p][i]]); while (k &lt; n) &#123; calc(sa[p], rank[p], sa[q], rank[q]); p ^= 1; q ^= 1; k &lt;&lt;= 1; &#125; calh(sa[p], rank[p]);&#125;bool check(int x) &#123; int l = 1, r = 1; for (int i = 2; i &lt;= n + 1; i++) if (height[i] &gt;= x) r++; else if (r - l + 1 &gt;= K) return true; else &#123; l = i; r = i; continue; &#125; return false;&#125;void solve() &#123; int l = 0, r = n; while (r - l &gt; 1) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) l = mid; else r = mid; &#125; printf("%d\n", check(r) ? r : l);&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;K); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); da(); solve();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1031][JSOI2007]字符加密Cipher——后缀数组]]></title>
      <url>%2F2017%2F03%2F13%2Fbzoj1031-JSOI2007-%E5%AD%97%E7%AC%A6%E5%8A%A0%E5%AF%86Cipher%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
      <content type="text"><![CDATA[Brief Description 给定一个长度为n的字符串，你需要对其进行加密。 1. 把字符串围成一个环 2. 显然从任意一个位置开始都可以有一个长度为n的串 3. 把产生的n个串按字典序排序，把这n个串的最后一个字符顺接起来就得到了加密后的串。 Algorithm Design 看到环的题目，可以想到破环为链，我们把原串复制一份贴在后面，求这个串的SA，可以知道这个新串的SA扫一遍就得到了解。 然后这个题就做完了。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 200010;char ch[maxn];int a[maxn], n, k;int v[maxn], sa[2][maxn], rank[2][maxn];void init() &#123; scanf("%s", ch + 1); n = strlen(ch + 1); for (int i = 1; i &lt;= n; i++) &#123; a[i] = (int)ch[i]; a[i + n] = a[i]; ch[i + n] = ch[i]; &#125; n &lt;&lt;= 1;&#125;void calcsa(int sa[maxn], int rank[maxn], int SA[maxn], int RANK[maxn]) &#123; for (int i = 1; i &lt;= n; i++) v[rank[sa[i]]] = i; for (int i = n; i &gt;= 1; i--) if (sa[i] &gt; k) SA[v[rank[sa[i] - k]]--] = sa[i] - k; for (int i = n - k + 1; i &lt;= n; i++) SA[v[rank[i]]--] = i; for (int i = 1; i &lt;= n; i++) &#123; RANK[SA[i]] = RANK[SA[i - 1]] + (rank[SA[i - 1]] != rank[SA[i]] || rank[SA[i - 1] + k] != rank[SA[i] + k]); &#125;&#125;void work() &#123; int p = 0, q = 1; for (int i = 1; i &lt;= n; i++) v[a[i]]++; for (int i = 1; i &lt;= 256; i++) v[i] += v[i - 1]; for (int i = 1; i &lt;= n; i++) sa[p][v[a[i]]--] = i; for (int i = 1; i &lt;= n; i++) rank[p][sa[p][i]] = rank[p][sa[p][i - 1]] + (a[sa[p][i]] != a[sa[p][i - 1]]); k = 1; while (k &lt; n) &#123; calcsa(sa[p], rank[p], sa[q], rank[q]); p ^= 1; q ^= 1; k &lt;&lt;= 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (sa[p][i] &lt;= n / 2) printf("%c", ch[sa[p][i] + n / 2 - 1]); &#125; printf("\n");&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif init(); work(); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1030][JSOI2007]文本生成器——AC自动机]]></title>
      <url>%2F2017%2F03%2F13%2Fbzoj1030-JSOI2007-%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90%E5%99%A8%E2%80%94%E2%80%94AC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
      <content type="text"><![CDATA[Brief Description 给定一些模式串，您需要求出满足以下要求的字符串的个数。 1. 长度为m 2. 包含任意一个模式串 Algorithm Design 以下内容来自神犇博客 首先运用补集转换，转而求不含这些串的个数，最后用26^M减掉就行 根据输入的字符串建立AC自动机 dp[i][j]表示当前考虑了i位，当前停留在AC自动机的j号节点 每一次可以由dp[i][j]转移到dp[i+1][k]，k是枚举第i+1为后作为j的儿子在AC自动机上的编号 枚举k，就是第i+1为填什么，然后进行下列操作： 首先看看这位能不能填k，判断方法是从j开始向fail[j]跳，看是不是有一个j有一个k儿子，并且k儿子上还有结束标记，只要有一个就证明如果i+1位填k就会让整个字符串出现AC自动机上的字符串，所以不能填k 如果能放，再看看要修改哪个dp数组。 还是从j开始向fail[j]跳，如果j有k这个儿子就直接修改dp[i+1][j的k儿子]就好 每次修改要对修改目标加上dp[i][j] 答案是所有dp[m][x]（x是所有AC自动机上的节点）的和 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define mod 10007const int maxn = 6010;int a[maxn][27], f[101][maxn], point[maxn];int n, m, sz = 1;char s[101];bool leaf[maxn];void insert(char s[101]) &#123; int now = 1, c; for (int i = 0; i &lt; strlen(s); i++) &#123; c = s[i] - 'A' + 1; if (a[now][c]) now = a[now][c]; else now = a[now][c] = ++sz; &#125; leaf[now] = 1;&#125;void ac() &#123; std::queue&lt;int&gt; q; q.push(1); point[1] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 1; i &lt;= 26; i++) &#123; if (!a[u][i]) continue; int k = point[u]; while (!a[k][i]) k = point[k]; point[a[u][i]] = a[k][i]; if (leaf[a[k][i]]) leaf[a[u][i]] = 1; q.push(a[u][i]); &#125; &#125;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= 26; i++) a[0][i] = 1; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", s); insert(s); &#125; ac(); f[0][1] = 1; for (int x = 1; x &lt;= m; x++) for (int i = 1; i &lt;= sz; i++) &#123; if (leaf[i] || !f[x - 1][i]) continue; for (int j = 1; j &lt;= 26; j++) &#123; int k = i; while (!a[k][j]) k = point[k]; f[x][a[k][j]] = (f[x][a[k][j]] + f[x - 1][i]) % mod; &#125; &#125; int ans1 = 0, ans2 = 1; for (int i = 1; i &lt;= m; i++) ans2 = (ans2 * 26) % mod; for (int i = 1; i &lt;= sz; i++) &#123; if (!leaf[i]) ans1 = (ans1 + f[m][i]) % mod; &#125; // printf("%d %d\n", ans2, ans1); printf("%d\n", (ans2 - ans1 + mod) % mod); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1009][HNOI2008]GT考试——KMP+矩阵乘法]]></title>
      <url>%2F2017%2F03%2F13%2Fbzoj1009-HNOI2008-GT%E8%80%83%E8%AF%95%E2%80%94%E2%80%94KMP-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Brief Description 给定一个长度为m的禁止字符串，求出长度为n的字符串的个数，满足： 这个字符串的任何一个字串都不等于给定字符串。 本题是POJ3691的弱化版本。 Algorithm Design 考察使用动态规划（递推）。 记录f[i][j]为当前已经做了i个字符，这个字符串长度为j的后缀与禁止字符串的前缀匹配，的字符串个数。 如果我们知道对于一个后缀而言加入一个字符之后可以转移到的状态我们就可以转移了。 我们可以知道KMP算法做的就是这样的事情。 又因為他满足矩阵乘法的一般方法，所以使用矩阵乘法加速。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;const int maxn = 25;int p[maxn], a[maxn][maxn], b[maxn][maxn];int n, m, mod;char ch[maxn];void mul(int a[maxn][maxn], int b[maxn][maxn], int ans[maxn][maxn]) &#123; int tmp[maxn][maxn]; for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; m; j++) &#123; tmp[i][j] = 0; for (int k = 0; k &lt; m; k++) tmp[i][j] = (tmp[i][j] + a[i][k] * b[k][j]) % mod; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; m; j++) ans[i][j] = tmp[i][j]; &#125;&#125;int main() &#123; // freopen("input", "r", stdin); scanf("%d %d %d", &amp;n, &amp;m, &amp;mod); scanf("%s", ch + 1); int j = 0; for (int i = 2; i &lt;= m; i++) &#123; while (j &gt; 0 &amp;&amp; ch[j + 1] != ch[i]) j = p[j]; if (ch[j + 1] == ch[i]) j++; p[i] = j; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt;= 9; j++) &#123; int t = i; while (t &gt; 0 &amp;&amp; ch[t + 1] - '0' != j) t = p[t]; if (ch[t + 1] - '0' == j) t++; if (t != m) b[t][i] = (b[t][i] + 1) % mod; &#125; &#125; for (int i = 0; i &lt; m; i++) a[i][i] = 1; while (n) &#123; if (n &amp; 1) mul(a, b, a); mul(b, b, b); n &gt;&gt;= 1; &#125; int sum = 0; for (int i = 0; i &lt; m; i++) sum = (sum + a[i][0]) % mod; printf("%d\n", sum); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2038][2009国家集训队]小Z的袜子(hose)——莫队算法]]></title>
      <url>%2F2017%2F03%2F10%2Fbzoj2038-2009%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90-hose-%E2%80%94%E2%80%94%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Brief Description 给定一个序列，您需要处理m个询问，每个询问形如[l,r]，您需要回答在区间[l,r]中任意选取两个数相同的概率。 Algorithm Design 莫队算法入门题目。 这篇博客讲的不错 对于L,R的询问。设袜子的个数为\(cnt_i\) 那么答案即为\[\frac{\sum_i C_{cnt}^2}{\frac{(R-L+1)*(R-L)}{2}}\] 其中\(C_n^m\)为组合数。 化简得:\[\frac{\sum_i cnt^2 -(R-L+1)}{(R-L+1)*(R-L)}\] 所以这道题目的关键是求一个区间内每种颜色数目的平方和。 如果你知道了[L,R]的答案。你可以在O(1)的时间下得到[L,R-1]和[L,R+1]和[L-1,R]和[L+1,R]的答案的话。就可以使用莫队算法。 对于莫队算法我感觉就是暴力。只是预先知道了所有的询问。可以合理的组织计算每个询问的顺序以此来降低复杂度。要知道我们算完[L,R]的答案后现在要算[L’,R’]的答案。由于可以在O(1)的时间下得到[L,R-1]和[L,R+1]和[L-1,R]和[L+1,R]的答案.所以计算[L’,R’]的答案花的时间为|L-L’|+|R-R’|。如果把询问[L,R]看做平面上的点a(L,R).询问[L’,R’]看做点b(L’,R’)的话。那么时间开销就为两点的曼哈顿距离。所以对于每个询问看做一个点。我们要按一定顺序计算每个值。那开销就为曼哈顿距离的和。要计算到每个点。那么路径至少是一棵树。所以问题就变成了求二维平面的最小曼哈顿距离生成树。 关于二维平面最小曼哈顿距离生成树。感兴趣的可以参考胡泽聪大佬的这篇文章 这样只要顺着树边计算一次就ok了。可以证明时间复杂度为\(n* \sqrt n\)。 但是这种方法编程复杂度稍微高了一点。所以有一个比较优雅的替代品。那就是先对序列分块。然后对于所有询问按照L所在块的大小排序。如果一样再按照R排序。然后按照排序后的顺序计算。为什么这样计算就可以降低复杂度呢。 一、i与i+1在同一块内，r单调递增，所以r是O(n)的。由于有n0.5块,所以这一部分时间复杂度是n1.5。 二、i与i+1跨越一块，r最多变化n，由于有n0.5块，所以这一部分时间复杂度是n1.5 三、i与i+1在同一块内时变化不超过n^0.5，跨越一块也不会超过2*n0.5，不妨看作是n0.5。由于有n个数，所以时间复杂度是n^1.5 于是就变成了\(\Theta(n^{1.5})\)了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;const int maxn = 50010;#define ll long longll num[maxn], up[maxn], dw[maxn], ans, aa, bb, cc;int col[maxn], pos[maxn];struct qnode &#123; int l, r, id;&#125; qu[maxn];bool cmp(qnode a, qnode b) &#123; if (pos[a.l] == pos[b.l]) return a.r &lt; b.r; else return pos[a.l] &lt; pos[b.l];&#125;ll gcd(ll x, ll y) &#123; ll tp; while ((tp = x % y)) &#123; x = y; y = tp; &#125; return y;&#125;void update(int x, int d) &#123; ans -= num[col[x]] * num[col[x]]; num[col[x]] += d; ans += num[col[x]] * num[col[x]];&#125;int main() &#123; int n, m, bk, pl, pr, id;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;m); memset(num, 0, sizeof(num)); bk = ceil(sqrt(1.0 * n)); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;col[i]); pos[i] = (i - 1) / bk; &#125; for (int i = 0; i &lt; m; i++) &#123; scanf("%d %d", &amp;qu[i].l, &amp;qu[i].r); qu[i].id = i; &#125; std::sort(qu, qu + m, cmp); pl = 1, pr = 0; ans = 0; for (int i = 0; i &lt; m; i++) &#123; id = qu[i].id; if (qu[i].l == qu[i].r) &#123; up[id] = 0, dw[id] = 1; continue; &#125; if (pr &lt; qu[i].r) &#123; for (int j = pr + 1; j &lt;= qu[i].r; j++) update(j, 1); &#125; else &#123; for (int j = pr; j &gt; qu[i].r; j--) update(j, -1); &#125; pr = qu[i].r; if (pl &lt; qu[i].l) &#123; for (int j = pl; j &lt; qu[i].l; j++) update(j, -1); &#125; else &#123; for (int j = pl - 1; j &gt;= qu[i].l; j--) update(j, 1); &#125; pl = qu[i].l; aa = ans - qu[i].r + qu[i].l - 1; bb = (ll)(qu[i].r - qu[i].l + 1) * (qu[i].r - qu[i].l); cc = gcd(aa, bb); aa /= cc, bb /= cc; up[id] = aa, dw[id] = bb; &#125; for (int i = 0; i &lt; m; i++) printf("%lld/%lld\n", up[i], dw[i]);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3669][Noi2014]魔法森林——lct]]></title>
      <url>%2F2017%2F03%2F10%2Fbzoj3669-Noi2014-%E9%AD%94%E6%B3%95%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94lct%2F</url>
      <content type="text"><![CDATA[Brief description 给定一个无向图，求从1到n的一条路径使得这条路径上最大的a和b最小。 Algorithm Design 以下内容选自某HN神犇的blog &gt;双瓶颈的最小生成树的感觉，可以首先按a值排序，然后一条边一条边的加入． &gt; 如果之前连接的两点还未连通，那么连上先满足最后连通性的必要． &gt; 如果之前连接的两点已经连通，那么就在原来的路径上找到一条b值最大的，然后删掉原来的，加上现在的边，保证最优性的需要． &gt; 这样会导致最大的b值的减小，但是如果之前1,n已经连通，也会造成最大的a值的增大 &gt; [因为是按a排序，在连通前的操作都是不管a值的，只以最后一次加的边为最大[所以之前的替换操作只会让这个路径更优]，但是连通后，添加的边就会让a值增大[不一定会更优]]，这就需要在多种方案间选出最优． &gt; 上面说得很轻巧，现在我们想想怎么完成上述操作． &gt; 总共要对每条边处理一次，每次需要连边或者在两点之前的链上找最大值．找到之后有删边的操作． &gt; 支持这么多操作的数据结构有什么?[注意我们连接的一定是一棵树[或是一片森林]…不然就浪费了…] &gt; lca似乎不兹瓷啊，因为是动态的，哦，那就是动态树了． &gt; 动态树中带边权的怎么处理呢?可以将所有实点的值定为0，连(u,v)边改为连(u,x)和(x,v)，x的值代表这条边的边权． &gt; [p.s]有的同学会觉得我连(u,v)把值记在u上或者v上就可以了…每次splay的时候，只有根节点保留的是在原树中连接上个部分的边权，其它的在splay的时候交换．[&lt;-这一步是可以实现的] &gt; 有的同学觉得我这样不就可以了么?然而…你还有个东西叫Access()，你每次会将原来本来是链的顶部才能连的边，给了当前splay的根，然后连通之后再splay，鬼才找的到原来的边是什么?..当然上面的＂有的同学＂都是说的笔者..有的大神说不定还是可以不加虚拟边点过的… Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;algorithm&gt;#include &lt;cstdio&gt;int n, m;const int maxn = 50010;const int maxm = 100010;const int maxv = maxn + maxm;struct edge &#123; int u, v, a, b;&#125; e[maxm &lt;&lt; 1];bool cmp1(edge a, edge b) &#123; return a.a &lt; b.a; &#125;int f[maxn], val[maxv], fa[maxv], ch[maxv][2], rev[maxv], max[maxv];int findf(int x) &#123; return f[x] == x ? x : f[x] = findf(f[x]); &#125;void pushdown(int x) &#123; if (rev[x]) &#123; rev[x] ^= 1; rev[ch[x][0]] ^= 1; rev[ch[x][1]] ^= 1; std::swap(ch[x][0], ch[x][1]); &#125;&#125;void update(int x) &#123; max[x] = x; if (val[max[ch[x][0]]] &gt; val[max[x]]) max[x] = max[ch[x][0]]; if (val[max[ch[x][1]]] &gt; val[max[x]]) max[x] = max[ch[x][1]];&#125;bool isroot(int x) &#123; return (ch[fa[x]][0] != x) &amp;&amp; (ch[fa[x]][1] != x); &#125;void zig(int x) &#123; int y = fa[x], z = fa[y], l = (ch[y][1] == x), r = l ^ 1; if (!isroot(y)) ch[z][ch[z][1] == y] = x; fa[ch[y][l] = ch[x][r]] = y; fa[ch[x][r] = y] = x; fa[x] = z; update(y); update(x);&#125;void splay(int x) &#123; int s[maxv], top = 0; s[++top] = x; for (int i = x; !isroot(i); i = fa[i]) s[++top] = fa[i]; while (top) pushdown(s[top--]); for (int y; !isroot(x); zig(x)) if (!isroot(y = fa[x])) zig((ch[y][0] == x) == (ch[fa[y]][0] == y) ? y : x); update(x);&#125;void access(int x) &#123; for (int t = 0; x; t = x, x = fa[x]) &#123; splay(x); ch[x][1] = t; update(x); &#125;&#125;void makeroot(int x) &#123; access(x); splay(x); rev[x] ^= 1;&#125;void link(int x, int y) &#123; makeroot(x); fa[x] = y;&#125;void cut(int x, int y) &#123; makeroot(x); access(y); splay(y); ch[y][0] = fa[x] = 0; update(y);&#125;void split(int x, int y) &#123; makeroot(y); access(x); splay(x);&#125;int ans = 0x3f3f3f;int main() &#123; freopen("input", "r", stdin); scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) f[i] = i; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d %d %d %d", &amp;e[i].u, &amp;e[i].v, &amp;e[i].a, &amp;e[i].b); &#125; std::sort(e + 1, e + 1 + m, cmp1); for (int i = 1; i &lt;= m; i++) &#123; int u = e[i].u, v = e[i].v, x = findf(u), y = findf(v); if (x == y) &#123; split(u, v); int t = max[u]; if (val[t] &gt; e[i].b) &#123; cut(e[t - n].u, t); cut(e[t - n].v, t); &#125; else &#123; if (findf(1) == findf(n)) &#123; split(1, n); int t = max[1]; ans = std::min(ans, e[i].a + val[t]); &#125; continue; &#125; &#125; if (x != y) &#123; f[x] = y; &#125; val[n + i] = e[i].b; max[n + i] = n + i; link(u, i + n); link(v, i + n); if (findf(1) == findf(n)) &#123; split(1, n); int t = max[1]; ans = std::min(ans, e[i].a + val[t]); &#125; &#125; printf("%d\n", ans == 0x3f3f3f ? -1 : ans);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj4034][HAOI2015]树上操作——树状数组+dfs序]]></title>
      <url>%2F2017%2F03%2F10%2Fbzoj4034-HAOI2015-%E6%A0%91%E4%B8%8A%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-dfs%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[Brief Description 您需要设计一种数据结构支持以下操作： 1. 把某个节点 x 的点权增加 a 。 2. 把某个节点 x 为根的子树中所有点的点权都增加 a 。 3. 询问某个节点 x 到根的路径中所有点的点权和。 Algorithm Design 我们考察操作对于查询的贡献。 对于操作1，如果节点y是节点x的后代，那么可以贡献\(a\) 对于操作2，如果节点y是节点x的后代，那么可以贡献\(a*(dep_y-dep_x+1)\) 我们可以使用两个树状数组来维护贡献。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#define lowbit(i) (i) &amp; -(i)const int maxn = 101000;#define ll long longll bit[2][maxn];ll n, m, cnt = 0;void change(ll id, ll pos, ll val) &#123; for (ll i = pos; i &lt;= n; i += lowbit(i)) &#123; bit[id][i] += val; &#125;&#125;ll query(ll id, ll pos) &#123; ll ans = 0; for (ll i = pos; i; i -= lowbit(i)) &#123; ans += bit[id][i]; &#125; return ans;&#125;struct edge &#123; ll to, next;&#125; e[maxn &lt;&lt; 1];ll l[maxn], r[maxn], dfn = 0, val[maxn], deep[maxn], head[maxn], q[maxn];void add(ll x, ll y) &#123; e[++cnt].to = y; e[cnt].next = head[x]; head[x] = cnt;&#125;void add_edge(ll x, ll y) &#123; add(x, y); add(y, x);&#125;void dfs(ll x, ll fa) &#123; l[x] = ++dfn; q[dfn] = x; for (ll i = head[x]; i; i = e[i].next) &#123; if (e[i].to != fa) &#123; deep[e[i].to] = deep[x] + 1; dfs(e[i].to, x); &#125; &#125; r[x] = dfn;&#125;int main() &#123; // freopen("haoi2015_t2.in", "r", stdin); // freopen("haoi2015_t2.out", "w", stdout); scanf("%lld %lld", &amp;n, &amp;m); for (ll i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;val[i]); &#125; for (ll i = 1; i &lt; n; i++) &#123; ll x; ll y; scanf("%lld %lld", &amp;x, &amp;y); add_edge(x, y); &#125; dfs(1, 0); for (ll i = 1; i &lt;= n; i++) &#123; change(1, l[i], val[i]); change(1, r[i] + 1, -val[i]); &#125; while (m--) &#123; ll opt, x, y; scanf("%lld %lld", &amp;opt, &amp;x); if (opt == 1) &#123; scanf("%lld", &amp;y); change(1, l[x], y); change(1, r[x] + 1, -y); &#125; if (opt == 2) &#123; scanf("%lld", &amp;y); change(0, l[x], y); change(1, l[x], -deep[x] * y + y); change(0, r[x] + 1, -y); change(1, r[x] + 1, deep[x] * y - y); &#125; if (opt == 3) &#123; printf("%lld\n", query(0, l[x]) * deep[x] + query(1, l[x])); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2594][Wc2006]水管局长数据加强版——lct+离线]]></title>
      <url>%2F2017%2F03%2F10%2Fbzoj2594-Wc2006-%E6%B0%B4%E7%AE%A1%E5%B1%80%E9%95%BF%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%BA%E7%89%88%E2%80%94%E2%80%94lct-%E7%A6%BB%E7%BA%BF%2F</url>
      <content type="text"><![CDATA[Brief Description 您有一个无向带权图，您需要支持两种操作。 1. 询问两个点之间的最大权最小路径。 2. 删除一条边。 Algorithm Design 我们首先提出一个猜想：最优路径一定在原图的一个最小生成森林上，证明如下： 假设最优路径有\(\phi\)条边不再最小生成森林上，我们考察其中的一条边，根据定义，生成森林中一定有一条路径链接这条边的顶点且权值和小于这条边，那么我们如果使用这条路径代替这条边，\(\phi\)会减小而最大权不会增加，所以根据反证法我们就可以知道这个结论的正确性。 有了这个引理之后我们可以把原题转化为维护一个最小生成森林，这显然可以使用lct维护。 考虑细节。因为lct不是太支持删一条边，所以我们离线地倒过来做。 另外我们需要记录每条边是否被删。我开始使用了map，然而不知道为什么一直RE。后来改用二分查找就好了。所以—— ## 抵制STL从我做起！（逃# Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;const int maxv = 1500005;int read() &#123; int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') f = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; return x * f;&#125;struct data &#123; int from, to, dat, br, id; data(int x = 0, int y = 0, int z = 0, int i = 0, int j = 0) : from(x), to(y), dat(z), br(i), id(j) &#123;&#125; bool operator&lt;(const data b) const &#123; return this-&gt;from &lt; b.from || ((this-&gt;from == b.from) &amp;&amp; (this-&gt;to &lt; b.to)); &#125;&#125; a[1000005];struct req &#123; int opt, x, y, id, ans; req(int x = 0, int y = 0, int z = 0, int k = 0, int fuck = 0) &#123; this-&gt;opt = x; this-&gt;x = y; this-&gt;y = z; this-&gt;id = k; this-&gt;ans = fuck; &#125;&#125; q[100005];bool cmp(data a, data b) &#123; return a.dat &lt; b.dat; &#125;bool cmp2(data a, data b) &#123; return a.id &lt; b.id; &#125;int n, m, qaq, f[maxv], max[maxv], val[maxv], tot, maxnum[maxv];int fa[maxv], ch[maxv][2];bool rev[maxv];int bisearch(int u, int v) &#123; int l = 1, r = m; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (a[mid].from &lt; u || (a[mid].from == u &amp;&amp; a[mid].to &lt; v)) l = mid + 1; else if (a[mid].from == u &amp;&amp; a[mid].to == v) return mid; else r = mid - 1; &#125; return -1;&#125;bool isroot(int x) &#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125;void pushdown(int k) &#123; if (rev[k]) &#123; rev[k] ^= 1; rev[ch[k][0]] ^= 1; rev[ch[k][1]] ^= 1; std::swap(ch[k][0], ch[k][1]); &#125;&#125;void update(int x) &#123; maxnum[x] = x; int l = maxnum[ch[x][0]], r = maxnum[ch[x][1]]; if (val[l] &gt; val[maxnum[x]]) maxnum[x] = l; if (val[r] &gt; val[maxnum[x]]) maxnum[x] = r; max[x] = val[maxnum[x]];&#125;void zig(int x) &#123; int y = fa[x], z = fa[y], l = (ch[y][1] == x), r = l ^ 1; if (!isroot(y)) ch[z][ch[z][1] == y] = x; fa[ch[y][l] = ch[x][r]] = y; fa[ch[x][r] = y] = x; fa[x] = z; update(y); update(x);&#125;void splay(int x) &#123; int s[maxv], top = 0; s[++top] = x; for (int i = x; !isroot(i); i = fa[i]) s[++top] = fa[i]; while (top) pushdown(s[top--]); for (int y; !isroot(x); zig(x)) &#123; if (!isroot(y = fa[x])) &#123; zig((ch[fa[y]][0] == y) == (ch[y][0] == x) ? y : x); &#125; &#125; update(x);&#125;void access(int x) &#123; for (int t = 0; x; t = x, x = fa[x]) &#123; splay(x); ch[x][1] = t; update(x); &#125;&#125;void makeroot(int x) &#123; access(x); splay(x); rev[x] ^= 1;&#125;void split(int x, int y) &#123; makeroot(y); access(x); splay(x);&#125;void link(int x, int y) &#123; makeroot(x); fa[x] = y;&#125;void cut(int x, int y) &#123; makeroot(x); access(y); splay(y); ch[y][0] = fa[x] = 0;&#125;void init() &#123; memset(val, 0, sizeof(val)); n = read(); m = read(); qaq = read(); for (int i = 1; i &lt;= n; i++) f[i] = i; for (int i = 1; i &lt;= m; i++) &#123; int x = read(), y = read(), z = read(); if (x &gt; y) std::swap(x, y); a[i] = data(x, y, z); &#125; std::sort(a + 1, a + 1 + m, cmp); for (int i = 1; i &lt;= m; i++) &#123; a[i].id = i; val[n + i] = a[i].dat; maxnum[n + i] = n + i; &#125; std::sort(a + 1, a + 1 + m); for (int i = 1; i &lt;= qaq; i++) &#123; int x = read(), y = read(), z = read(); q[i] = req(x, y, z); if (x == 2) &#123; if (q[i].x &gt; q[i].y) std::swap(q[i].x, q[i].y); int t = bisearch(q[i].x, q[i].y); a[t].br = 1; q[i].id = a[t].id; &#125; &#125;&#125;int find(int x) &#123; return f[x] == x ? x : f[x] = find(f[x]); &#125;void kruskal() &#123; std::sort(a + 1, a + m + 1, cmp2); tot = 0; for (int i = 1; i &lt;= m; i++) &#123; if (!a[i].br) &#123; int u = a[i].from, v = a[i].to, x = find(u), y = find(v); if (x != y) &#123; f[x] = y; link(u, i + n); link(v, i + n); tot++; if (tot == n - 1) break; &#125; &#125; &#125;&#125;void solve() &#123; for (int i = qaq; i &gt;= 1; i--) &#123; int op = q[i].opt, x = q[i].x, y = q[i].y; if (op == 1) &#123; split(x, y); q[i].ans = val[maxnum[x]]; &#125; if (op == 2) &#123; int k = q[i].id; split(x, y); int t = maxnum[x]; if (a[k].dat &lt; val[t]) &#123; cut(a[t - n].from, t); cut(a[t - n].to, t); link(x, k + n); link(y, k + n); &#125; &#125; &#125; for (int i = 1; i &lt;= qaq; i++) &#123; if (q[i].opt == 1) printf("%d\n", q[i].ans); &#125;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif init(); kruskal(); solve(); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2631]tree——lct]]></title>
      <url>%2F2017%2F03%2F10%2Fbzoj2631-tree%E2%80%94%E2%80%94lct%2F</url>
      <content type="text"><![CDATA[Brief Description 一棵n个点的树，每个点的初始权值为1。对于这棵树有q个操作，每个操作为以下四种操作之一： + u v c：将u到v的路径上的点的权值都加上自然数c； - u1 v1 u2 v2：将树中原有的边(u1,v1)删除，加入一条新边(u2,v2)，保证操作完之后仍然是一棵树； * u v c：将u到v的路径上的点的权值都乘上自然数c； / u v：询问u到v的路径上的点的权值和，求出答案对于51061的余数。 Algorithm Design lct裸题。考察标记下传，先下传乘法，再下传加法。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#define ll unsigned intconst int maxn = 100005;#define mod 51061inline int read() &#123; int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') &#123; f = -1; &#125; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; return x * f;&#125;int n, m, top, cnt;int ch[maxn][2], fa[maxn], size[maxn];bool rev[maxn];ll sum[maxn], val[maxn], at[maxn], mt[maxn];inline bool isroot(int x) &#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125;inline void cal(int k, int m, int a) &#123; if (k) &#123; val[k] = (val[k] * m + a) % mod; sum[k] = (sum[k] * m + a * size[k]) % mod; at[k] = (at[k] * m + a) % mod; mt[k] = (mt[k] * m) % mod; &#125;&#125;inline void update(int k) &#123; int l = ch[k][0], r = ch[k][1]; sum[k] = (sum[l] + sum[r] + val[k]) % mod; size[k] = (size[l] + size[r] + 1) % mod;&#125;inline void pushdown(int k) &#123; int &amp;l = ch[k][0], &amp;r = ch[k][1]; if (rev[k]) &#123; rev[k] ^= 1, rev[l] ^= 1, rev[r] ^= 1; std::swap(l, r); &#125; int m = mt[k], a = at[k]; mt[k] = 1, at[k] = 0; if (m != 1 || a != 0) &#123; cal(l, m, a); cal(r, m, a); &#125;&#125;inline void zig(int x) &#123; int y = fa[x], z = fa[y], l = (ch[y][1] == x), r = l ^ 1; if (!isroot(y)) ch[z][ch[z][1] == y] = x; fa[ch[y][l] = ch[x][r]] = y; fa[ch[x][r] = y] = x; fa[x] = z; update(y); update(x);&#125;inline void splay(int x) &#123; int s[maxn], top = 0; s[++top] = x; for (int i = x; !isroot(i); i = fa[i]) s[++top] = fa[i]; while (top) pushdown(s[top--]); for (int y; !isroot(x); zig(x)) if (!isroot(y = fa[x])) zig((ch[fa[y]][0] == y) == (ch[y][0] == x) ? y : x);&#125;inline void access(int x) &#123; for (int t = 0; x; t = x, x = fa[x]) &#123; splay(x); ch[x][1] = t; update(x); &#125;&#125;inline void makeroot(int x) &#123; access(x); splay(x); rev[x] ^= 1;&#125;inline void split(int x, int y) &#123; makeroot(y); access(x); splay(x);&#125;inline void link(int x, int y) &#123; makeroot(x); fa[x] = y;&#125;inline void cut(int x, int y) &#123; makeroot(x); access(y); splay(y); ch[y][0] = fa[x] = 0;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif n = read(), m = read(); int u, v, c; for (int i = 1; i &lt;= n; i++) val[i] = sum[i] = size[i] = mt[i] = 1; for (int i = 1; i &lt; n; i++) &#123; u = read(), v = read(); link(u, v); &#125; char st[5]; while (m--) &#123; scanf("%s", st); u = read(), v = read(); if (st[0] == '+') &#123; c = read(); split(u, v); cal(u, 1, c); &#125; if (st[0] == '-') &#123; cut(u, v); u = read(), v = read(), link(u, v); &#125; if (st[0] == '*') &#123; c = read(); split(u, v); cal(u, c, 0); &#125; if (st[0] == '/') &#123; split(u, v); printf("%d\n", sum[u]); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2002][Hnoi2010]Bounce弹飞绵羊——分块]]></title>
      <url>%2F2017%2F03%2F09%2Fbzoj2002-Hnoi2010-Bounce%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A%E2%80%94%E2%80%94%E5%88%86%E5%9D%97%2F</url>
      <content type="text"><![CDATA[Brief description 某天，Lostmonkey发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。游戏一开始，Lostmonkey在地上沿着一条直线摆上n个装置，每个装置设定初始弹力系数ki，当绵羊达到第i个装置时，它会往后弹ki步，达到第i+ki个装置，若不存在第i+ki个装置，则绵羊被弹飞。绵羊想知道当它从第i个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。 Algorithm design 因为太弱不会用lct，所以我们使用分块做Orz 考察暴力解法： 第一种暴力做法就是修改的时候直接\(\Theta(1)\)修改，查询的时候要\(\Theta(n)\)查询。 第二种暴力做法就是修改的时候把所有的答案重新递推出来，复杂度\(\Theta(n)\)，查询的时候就可以\(\Theta(1)\)查询了。 我们考虑分块把两种方法结合起来。设分块的大小为\(h(n)\)。 首先我们预处理出来每个点跳出当前块需要多少步，并且跳出之后会落在哪里。 考虑修改。对于每个点，如果我们修改，会导致所有可以到达它的点的答案变化。我们只修改块内的答案，不难证明这样做是可行的。复杂度\(\Theta(h(n))\) 考虑查询。根据预处理信息，我们可以方便的查询。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 200100;const int inf = 0x3f3f3f;int n, m, f[maxn], g[maxn], h[maxn], k[maxn], block;int id(int x) &#123; if (block != 0) return (x - 1) / block + 1; return 1;&#125;int main(int argc, char const *argv[]) &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d", &amp;n); block = (int)sqrt(n); memset(f, -1, sizeof(f)); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); f[i] = i + x; if (f[i] &gt; n) f[i] = -1; k[i] = -1; h[i] = -1; g[i] = inf; &#125; k[n + 1] = 0; for (int i = n; i &gt;= 1; i--) &#123; if (f[i] != -1) &#123; k[i] = k[f[i]] + 1; if (id(i) == id(f[i])) &#123; g[i] = g[f[i]] + 1; h[i] = h[f[i]]; &#125; else &#123; g[i] = 1; h[i] = f[i]; &#125; &#125; else &#123; k[i] = 1; g[i] = 1; h[i] = -1; &#125; &#125; scanf("%d", &amp;m); while (m--) &#123; int opt; scanf("%d", &amp;opt); if (opt == 1) &#123; if (block == 0) &#123; printf("0\n"); continue; &#125; int x; scanf("%d", &amp;x); x++; int ans = 1; while (f[x] != -1) &#123; if (h[x] != -1) &#123; ans += g[x]; x = h[x]; &#125; else &#123; x = f[x]; ans++; &#125; &#125; printf("%d\n", ans); &#125; if (opt == 2) &#123; if (block == 0) continue; int x, y; scanf("%d %d", &amp;x, &amp;y); x++; f[x] = x + y; k[x] = k[y] + 1; if (f[x] &gt; n) f[x] = -1; if (id(y) == id(x)) g[x] = g[y] + 1, h[x] = h[y]; else g[x] = y, h[x] = 1; for (int i = x; id(i) == id(x) &amp;&amp; i; i--) &#123; if (f[i] != -1) &#123; k[i] = k[f[i]] + 1; if (id(i) == id(f[i])) &#123; g[i] = g[f[i]] + 1; h[i] = h[f[i]]; &#125; else &#123; g[i] = 1; h[i] = f[i]; &#125; &#125; else &#123; k[i] = 1; g[i] = 1; h[i] = -1; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2049][Sdoi2008]Cave 洞穴勘测——lct]]></title>
      <url>%2F2017%2F03%2F08%2Fbzoj2049-Sdoi2008-Cave-%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B%E2%80%94%E2%80%94lct%2F</url>
      <content type="text"><![CDATA[Brief Description 给定一个森林，您需要支持两种操作： 1. 链接两个节点。 2. 断开两个节点之间的链接。 Algorithm Design 对于树上的操作，我们现在已经有了树链剖分可以处理这些问题。然而树链剖分不支持动态维护树上的拓扑结构。所以我们需要Link-Cut Tree(lct)来解决这种动态树问题。顺带一提的是，动态树也是Tarjan发明的。 首先我们介绍一个概念：Preferred path（实边），其他的边都是虚边。我们使用splay来实时地维护这条路径。 lct的核心操作是access。access操作可以把虚边变为实边，通过改变splay的拓扑结构来维护实边。 有了这个数据结构，我们依次来考虑两个操作。 对于链接两个节点，我们需要首先把x节点变为他所在树的根节点，然后直接令fa[x] = y即可。 怎样换根呢？稍微思考一下可以发现，我们直接把从根到他的路径反转即可。 对于第二种操作，我们直接断开拓扑关系即可。 另外实现的时候要注意，splay的根节点的父亲是他的上一个节点。所以zig和splay的写法应该格外注意。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;stack&gt;using std::stack;const int maxn = 10005;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') f = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; return x * f;&#125;int n, m;int fa[maxn], ch[maxn][2];bool rev[maxn];inline bool isroot(int x) &#123; return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; &#125;void pushdown(int k) &#123; if (rev[k]) &#123; rev[k] = 0; rev[ch[k][0]] ^= 1; rev[ch[k][1]] ^= 1; std::swap(ch[k][0], ch[k][1]); &#125;&#125;void zig(int x) &#123; int y = fa[x], z = fa[y], l = (ch[y][1] == x), r = l ^ 1; if (!isroot(y)) ch[z][ch[z][1] == y] = x; fa[ch[y][l] = ch[x][r]] = y; fa[ch[x][r] = y] = x; fa[x] = z;&#125;void splay(int x) &#123; stack&lt;int&gt; st; st.push(x); for (int i = x; !isroot(i); i = fa[i]) st.push(fa[i]); while (!st.empty()) &#123; pushdown(st.top()); st.pop(); &#125; for (int y = fa[x]; !isroot(x); zig(x), y = fa[x]) if (!isroot(y)) zig((ch[fa[y]][0] == y) == (ch[y][0] == x) ? y : x);&#125;void access(int x) &#123; int t = 0; while (x) &#123; splay(x); ch[x][1] = t; t = x; x = fa[x]; &#125;&#125;void rever(int x) &#123; access(x); splay(x); rev[x] ^= 1;&#125;void link(int x, int y) &#123; rever(x); fa[x] = y; splay(x);&#125;void cut(int x, int y) &#123; rever(x); access(y); splay(y); ch[y][0] = fa[x] = 0;&#125;int find(int x) &#123; access(x); splay(x); int y = x; while (ch[y][0]) y = ch[y][0]; return y;&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen("input", "r", stdin); #endif char ch[10]; int x, y; n = read(), m = read(); for (int i = 1; i &lt;= m; i++) &#123; scanf("%s", ch); x = read(); y = read(); if (ch[0] == 'C') link(x, y); else if (ch[0] == 'D') cut(x, y); else &#123; if (find(x) == find(y)) printf("Yes\n"); else printf("No\n"); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj4765]普通计算姬——分块]]></title>
      <url>%2F2017%2F03%2F08%2Fbzoj4765-%E6%99%AE%E9%80%9A%E8%AE%A1%E7%AE%97%E5%A7%AC%E2%80%94%E2%80%94%E5%88%86%E5%9D%97%2F</url>
      <content type="text"><![CDATA[Brief Description 给定一棵n个节点的带权树，节点编号为1到n，以root为根，设sum[p]表示以点p为根的这棵子树中所有节点的权 值和。支持下列两种操作: 1 给定两个整数u,v，修改点u的权值为v。 2 给定两个整数l,r，计算sum[l]+sum[l+1]+….+sum[r-1]+sum[r] Algorithm Design 我们考察暴力算法： 对于查询，我们如果处理出所有的sum[i]就可以处理了。考虑到是树上的子树查询，我们考虑使用dfs序，使用BIT维护即可，这个算法是\(\Theta(log n)\)的。 对于修改，如果我们能够记录每个点是否可以被这个修改的点影响，我们就可以扫一遍就ok了。这样的复杂度是\(\Theta(nlogn)\)的。 我们可以看到修改的复杂度比较大，我们考虑使用分块平衡一下这两个算法，假设我们\(h(n)\)分一块， 对于查询，我们可以把查询区间分为\(\Theta(\frac{n}{h(n)})\)个区间，对于每个区间直接统计，对于两边的区间直接统计复杂度\(\Theta(h(n)log(h(n))\) 对于修改，我们统计每一个区域会被修改的点修改几次，直接统计影响即可。复杂度是\(\Theta(\frac{n}{h(n)})\) 这样，算法总的复杂度就是\(\Theta(h(n)log(h(n))+\frac{n}{h(n)})\)，为了方便，我们设\(h(n) = \sqrt n\)。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cmath&gt;#include &lt;cstdio&gt;#define ll unsigned long longconst ll maxn = 100010;const ll maxm = 320;ll value[maxn], bit[maxn &lt;&lt; 1], wtf[maxn];int f[maxn][maxm];int t[maxm], l[maxn], r[maxn], head[maxn], b[maxn];ll n, m, rt, ind = 0, cnt = 0, blockm, block;struct edge &#123; ll to, next;&#125; e[maxn &lt;&lt; 2];ll lowbit(ll x) &#123; return x &amp; -x; &#125;void change(ll pos, ll x) &#123; for (ll i = pos; i &lt;= n; i += lowbit(i)) bit[i] += x;&#125;ll sum(ll pos) &#123; ll ans = 0; for (ll i = pos; i &gt; 0; i -= lowbit(i)) ans += bit[i]; return ans;&#125;void insert(ll x, ll y) &#123; e[++cnt].to = y; e[cnt].next = head[x]; head[x] = cnt; e[++cnt].to = x; e[cnt].next = head[y]; head[y] = cnt;&#125;void dfs(ll x, ll fa) &#123; t[b[x]]++; for (ll i = 1; i &lt;= blockm; i++) f[x][i] = t[i]; l[x] = ++ind; change(l[x], value[x]); for (ll i = head[x]; i; i = e[i].next) &#123; if (e[i].to != fa) dfs(e[i].to, x); &#125; r[x] = ind; t[b[x]]--;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%llu %llu", &amp;n, &amp;m); block = (int)sqrt(n); blockm = (n - 1) / block + 1; for (ll i = 1; i &lt;= n; i++) &#123; scanf("%llu", &amp;value[i]); &#125; for (ll i = 1; i &lt;= n; i++) b[i] = (i - 1) / block + 1; for (ll i = 1; i &lt;= n; i++) &#123; ll u, v; scanf("%llu %llu", &amp;u, &amp;v); if (u == 0) rt = v; else insert(u, v); &#125; dfs(rt, 0); for (ll i = 1; i &lt;= n; i++) wtf[b[i]] += sum(r[i]) - sum(l[i] - 1); for (ll i = 1; i &lt;= m; i++) &#123; ll op, u, v; scanf("%llu %llu %llu", &amp;op, &amp;u, &amp;v); if (op == 1) &#123; change(l[u], v - value[u]); for (ll j = 1; j &lt;= blockm; j++) wtf[j] += 1ll * f[u][j] * (v - value[u]); value[u] = v; &#125; else &#123; ll ans = 0; if (b[u] == b[v]) for (ll j = u; j &lt;= v; j++) ans += sum(r[j]) - sum(l[j] - 1); else &#123; for (ll j = b[u] + 1; j &lt;= b[v] - 1; j++) ans += wtf[j]; for (ll j = u; b[j] == b[u] &amp;&amp; j &lt;= n; j++) ans += sum(r[j]) - sum(l[j] - 1); for (ll j = v; b[j] == b[v] &amp;&amp; j; j--) ans += sum(r[j]) - sum(l[j] - 1); &#125; printf("%llu\n", ans); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj4766]文艺计算姬——完全二分图生成树个数]]></title>
      <url>%2F2017%2F03%2F08%2Fbzoj4766-%E6%96%87%E8%89%BA%E8%AE%A1%E7%AE%97%E5%A7%AC%E2%80%94%E2%80%94%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%88%86%E5%9B%BE%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%AA%E6%95%B0%2F</url>
      <content type="text"><![CDATA[Brief Description 求\(K_{n,m}\) Algorithm Design 首先我们有(Matrix Tree)定理，可以暴力生成几组答案，发现一些规律： \[K_{n,m} = n^{m-1} * m^{n-1}\] 然而直接乘法会爆longlong，所以使用快速乘 Code 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#define ll long longll n, m, p;inline ll mul(ll a, ll b) &#123; ll x = 0; while (b) &#123; if (b &amp; 1) x = (x + a) % p; a = (a &lt;&lt; 1) % p; b &gt;&gt;= 1; &#125; return x;&#125;inline ll pow(ll a, ll b, ll p) &#123; ll x = 1; while (b) &#123; if (b &amp; 1) x = mul(x, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return x;&#125;int main() &#123; scanf("%lld %lld %lld", &amp;n, &amp;m, &amp;p); if (n == 0 || m == 0) &#123; printf("0\n"); return 0; &#125; printf("%lld\n", mul(pow(n, m - 1, p), pow(m, n - 1, p))); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2243][SDOI2011]染色——树链剖分+线段树]]></title>
      <url>%2F2017%2F03%2F07%2Fbzoj2243-SDOI2011-%E6%9F%93%E8%89%B2%E2%80%94%E2%80%94%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
      <content type="text"><![CDATA[Brief Description 给定一棵树，每个点有颜色，您需要支持两种操作： 1. 把某两个点路径上的所有点的颜色设为某种颜色。 2. 查询两个点路径上的颜色块的个数。 例如，颜色块:22112233视为4个颜色块。 Algorithm Design 树链剖分裸题。 我们需要在线段树上记录区间最左边的颜色与区间最右边的颜色以方便合并。 Notice 注意要多update，因为这个WA了3次 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int maxn = 100010;int head[maxn], value[maxn], que[maxn], deep[maxn];int vis[maxn], size[maxn], fa[maxn][20], pl[maxn], belong[maxn];int n, m, cnt, sz;struct seg &#123; int l, r, lc, rc, s, tag; // s:颜色的个数, tag:标记, l:最左端的颜色, r:最右边的颜色&#125; t[maxn &lt;&lt; 2];struct edge &#123; int to, next;&#125; e[maxn &lt;&lt; 1];void insert(int u, int v) &#123; e[++cnt].to = v; e[cnt].next = head[u]; head[u] = cnt; e[++cnt].to = u; e[cnt].next = head[v]; head[v] = cnt;&#125;void dfs1(int x) &#123; vis[x] = size[x] = 1; for (int i = 1; i &lt;= 17; i++) &#123; if (deep[x] &lt; (1 &lt;&lt; i)) break; fa[x][i] = fa[fa[x][i - 1]][i - 1]; &#125; for (int i = head[x]; i; i = e[i].next) &#123; if (!vis[e[i].to]) &#123; deep[e[i].to] = deep[x] + 1; fa[e[i].to][0] = x; dfs1(e[i].to); size[x] += size[e[i].to]; &#125; &#125;&#125;void dfs2(int x, int chain) &#123; pl[x] = ++sz; que[sz] = x; belong[x] = chain; int k = 0; for (int i = head[x]; i; i = e[i].next) if (deep[e[i].to] &gt; deep[x] &amp;&amp; size[k] &lt; size[e[i].to]) k = e[i].to; if (!k) return; dfs2(k, chain); for (int i = head[x]; i; i = e[i].next) if (e[i].to != k &amp;&amp; deep[e[i].to] &gt; deep[x]) dfs2(e[i].to, e[i].to);&#125;void update(int k) &#123; int tmp = !(t[k &lt;&lt; 1].rc ^ t[k &lt;&lt; 1 | 1].lc); t[k].s = t[k &lt;&lt; 1].s + t[k &lt;&lt; 1 | 1].s - tmp; t[k].lc = t[k &lt;&lt; 1].lc; t[k].rc = t[k &lt;&lt; 1 | 1].rc;&#125;void build(int k, int l, int r) &#123; t[k].l = l, t[k].r = r, t[k].s = 1, t[k].tag = -1; if (l == r) &#123; t[k].lc = t[k].rc = value[que[l]]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(k &lt;&lt; 1, l, mid); build(k &lt;&lt; 1 | 1, mid + 1, r); update(k);&#125;int lca(int x, int y) &#123; if (deep[x] &lt; deep[y]) std::swap(x, y); int t = deep[x] - deep[y]; for (int i = 0; i &lt;= 17; i++) &#123; if (t &amp; (1 &lt;&lt; i)) x = fa[x][i]; &#125; for (int i = 17; i &gt;= 0; i--) &#123; if (fa[x][i] != fa[y][i]) &#123; x = fa[x][i]; y = fa[y][i]; &#125; &#125; if (x == y) return x; else return fa[x][0];&#125;void pushdown(int k) &#123; int tmp = t[k].tag; t[k].tag = -1; if (tmp == -1 || t[k].l == t[k].r) return; t[k &lt;&lt; 1].s = t[k &lt;&lt; 1 | 1].s = 1; t[k &lt;&lt; 1].tag = t[k &lt;&lt; 1 | 1].tag = tmp; t[k &lt;&lt; 1].lc = t[k &lt;&lt; 1].rc = tmp; t[k &lt;&lt; 1 | 1].lc = t[k &lt;&lt; 1 | 1].rc = tmp; update(k);&#125;int query(int k, int x, int y) &#123; pushdown(k); int l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; return t[k].s; &#125; int tmp = !(t[k &lt;&lt; 1].rc ^ t[k &lt;&lt; 1 | 1].lc) &amp;&amp; (x &lt;= mid) &amp;&amp; (y &gt; mid), ans = 0; if (x &lt;= mid) ans += query(k &lt;&lt; 1, x, y); if (y &gt; mid) ans += query(k &lt;&lt; 1 | 1, x, y); return ans - tmp;&#125;int getcolor(int k, int pos) &#123; pushdown(k); int l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; if (l == r) return t[k].lc; if (pos &lt;= mid) return getcolor(k &lt;&lt; 1, pos); else return getcolor(k &lt;&lt; 1 | 1, pos);&#125;int solvesum(int x, int f) &#123; int sum = 0; while (belong[x] != belong[f]) &#123; sum += query(1, pl[belong[x]], pl[x]); if (getcolor(1, pl[belong[x]]) == getcolor(1, pl[fa[belong[x]][0]])) sum--; x = fa[belong[x]][0]; &#125; sum += query(1, pl[f], pl[x]); return sum;&#125;void change(int k, int x, int y, int c) &#123; pushdown(k); int l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; t[k].lc = t[k].rc = c; t[k].s = 1; t[k].tag = c; return; &#125; if (x &lt;= mid) change(k &lt;&lt; 1, x, y, c); if (y &gt; mid) change(k &lt;&lt; 1 | 1, x, y, c); update(k);&#125;void solvechange(int x, int f, int c) &#123; while (belong[x] != belong[f]) &#123; change(1, pl[belong[x]], pl[x], c); x = fa[belong[x]][0]; &#125; change(1, pl[f], pl[x], c);&#125;void solve() &#123; dfs1(1); dfs2(1, 1); build(1, 1, n); for (int i = 1; i &lt;= m; i++) &#123; char ch[10]; scanf("%s", ch); if (ch[0] == 'Q') &#123; int a, b; scanf("%d %d", &amp;a, &amp;b); int t = lca(a, b); printf("%d\n", solvesum(a, t) + solvesum(b, t) - 1); &#125; else &#123; int a, b, c; scanf("%d %d %d", &amp;a, &amp;b, &amp;c); int t = lca(a, b); solvechange(a, t, c); solvechange(b, t, c); &#125; &#125;&#125;void init() &#123; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;value[i]); for (int i = 1; i &lt; n; i++) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); insert(x, y); &#125;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif init(); solve(); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3306]树——树上倍增+dfs序+线段树]]></title>
      <url>%2F2017%2F03%2F07%2Fbzoj3306-%E6%A0%91%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E-dfs%E5%BA%8F-%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
      <content type="text"><![CDATA[Brief Description 您需要写一种数据结构，支持： 1. 更改一个点的点权 2. 求一个子树的最小点权 3. 换根 Algorithm Design 我们先忽略第三个要求。 看到要求子树的最小点权，我们想到使用dfs序。容易看到，一个节点的子树在dfs序中的范围就是\([l(x),r(x)]\)，所以我们把树结构变成了线性结构，从而变成了一个RMQ问题，我们使用线段树即可求解。 对于换根，我们不必重新求出拓扑结构。我们考察换根会影响到的节点。对于新根的子树中的节点，一定没有影响，对于不是新根祖先的节点，一定也没有影响。所以我们只考虑新根的祖先。 我们可以看出，换成新根以后，祖先的覆盖范围就变成了全树抛去新根到祖先路径上距离祖先距离最近的节点的子树大小，设这个点为y，那么dfs序中的范围就是\([1,l[y]-1] \cup [r[y]+1, n]\)。 所以问题就变成了如何求树上离某个点距离最近的儿子。显然可以使用树上倍增来求。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;algorithm&gt;#include &lt;cstdio&gt;using std::max;using std::min;const int maxn = 100010;int q[maxn], ind = 0, l[maxn], r[maxn], n, m, root, val[maxn], deep[maxn], fa[maxn][20];int cnt = 0;struct edge &#123; int to, next;&#125; e[maxn];int last[maxn];struct seg &#123; int l, r, mn;&#125; t[maxn &lt;&lt; 2];void insert(int x, int y) &#123; e[++cnt].to = y; e[cnt].next = last[x]; last[x] = cnt;&#125;void update(int k) &#123; t[k].mn = min(t[k &lt;&lt; 1].mn, t[k &lt;&lt; 1 | 1].mn); &#125;void dfs(int x) &#123; l[x] = ++ind; q[ind] = x; for (int i = 1; i &lt;= 16; i++) &#123; if (deep[x] &lt; (1 &lt;&lt; i)) break; fa[x][i] = fa[fa[x][i - 1]][i - 1]; &#125; for (int i = last[x]; i; i = e[i].next) &#123; fa[e[i].to][0] = x; deep[e[i].to] = deep[x] + 1; dfs(e[i].to); &#125; r[x] = ind;&#125;void build(int k, int l, int r) &#123; t[k].l = l, t[k].r = r; int mid = (l + r) &gt;&gt; 1; if (l == r) &#123; t[k].mn = val[q[l]]; return; &#125; build(k &lt;&lt; 1, l, mid); build(k &lt;&lt; 1 | 1, mid + 1, r); t[k].mn = min(t[k &lt;&lt; 1].mn, t[k &lt;&lt; 1 | 1].mn);&#125;void modify(int k, int pos, int val) &#123; int l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; if (l == r) &#123; t[k].mn = val; return; &#125; if (pos &lt;= mid) modify(k &lt;&lt; 1, pos, val); else modify(k &lt;&lt; 1 | 1, pos, val); update(k);&#125;int query(int k, int x, int y) &#123; int l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; if (x &lt;= l &amp;&amp; r &lt;= y) return t[k].mn; int ans = 0x3f3f3f; if (x &lt;= mid) ans = min(ans, query(k &lt;&lt; 1, x, y)); if (y &gt; mid) ans = min(ans, query(k &lt;&lt; 1 | 1, x, y)); return ans;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int f; scanf("%d %d", &amp;f, &amp;val[i]); if (f) insert(f, i); &#125; dfs(root = 1);#ifndef ONLINE_JUDGE for (int i = 1; i &lt;= ind; i++) printf("%d ", q[i]); printf("\n");#endif build(1, 1, n); while (m--) &#123; char ch[5]; int x; scanf("%s %d", ch, &amp;x); if (ch[0] == 'V') &#123; int val; scanf("%d", &amp;val); modify(1, l[x], val); &#125; else if (ch[0] == 'E') root = x; else &#123; if (root == x) printf("%d\n", t[1].mn); else if (l[x] &lt;= l[root] &amp;&amp; r[x] &gt;= r[root]) &#123; // x is the father of root int y = root, d = deep[y] - deep[x] - 1; for (int i = 0; i &lt;= 16; i++) if (d &amp; (1 &lt;&lt; i)) y = fa[y][i]; printf("%d\n", min(query(1, 1, l[y] - 1), query(1, r[y] + 1, n))); &#125; else printf("%d\n", query(1, l[x], r[x])); &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1977][BeiJing2010组队]次小生成树 Tree——树上倍增+lca]]></title>
      <url>%2F2017%2F03%2F07%2Fbzoj1977-BeiJing2010%E7%BB%84%E9%98%9F-%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Tree%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E-lca%2F</url>
      <content type="text"><![CDATA[Brief Description 求一个无向图的严格次小生成树。 Algorithm Design 考察最小生成树的生成过程。对于一个非树边而言，如果我们使用这一条非树边去替换原MST的路径上的最大边，可以证明仍然满足生成树性质，而且这个生成树的大小一定不小于原生成树，那么枚举所有这样的非树边，尝试去替换，找到最小值就可以了。 那么问题就转化成了求树上两个点的最大/最小距离，这是树上倍增的经典应用，可以知道： \[Max(x,i) = max(Max(x,i-1), Max(fa(x,i-1),i-1))\] 我们可以通过递推用\(\Theta(nlogn)\)时间预处理出来这些信息。 问题解决了吗？还没有。原题要求严格小于原树。所以我们顺便预处理一下树上两个点的次大值就可以了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;algorithm&gt;#include &lt;cstdio&gt;using std::max;using std::min;const int maxn = 100001;const int maxm = 300001;const int inf = 0x3f3f3f;#define ll long longint n, m, tot, cnt, mn = inf;ll ans;int f[maxn], head[maxn], deep[maxn], fa[maxn][17], d1[maxn][17], d2[maxn][17];struct data &#123; int x, y, v; bool sel; bool operator&lt;(const data b) const &#123; return this-&gt;v &lt; b.v; &#125;&#125; a[maxm];struct edge &#123; int to, next, v;&#125; e[maxn &lt;&lt; 1];void ins(int u, int v, int w) &#123; e[++cnt].to = v; e[cnt].next = head[u]; e[cnt].v = w; head[u] = cnt;&#125;int find(int x) &#123; return f[x] == x ? x : f[x] = find(f[x]); &#125;void dfs(int x, int f) &#123; for (int i = 1; i &lt;= 16; i++) &#123; if (deep[x] &lt; (1 &lt;&lt; i)) break; fa[x][i] = fa[fa[x][i - 1]][i - 1]; d1[x][i] = max(d1[x][i - 1], d1[fa[x][i - 1]][i - 1]); if (d1[x][i - 1] == d1[fa[x][i - 1]][i - 1]) d2[x][i] = max(d2[x][i - 1], d2[fa[x][i - 1]][i - 1]); else &#123; d2[x][i] = min(d1[x][i - 1], d1[fa[x][i - 1]][i - 1]); d2[x][i] = max(d2[x][i], d2[x][i - 1]); d2[x][i] = max(d2[x][i], d2[fa[x][i - 1]][i - 1]); &#125; &#125; for (int i = head[x]; i; i = e[i].next) &#123; if (e[i].to != f) &#123; fa[e[i].to][0] = x; d1[e[i].to][0] = e[i].v; deep[e[i].to] = deep[x] + 1; dfs(e[i].to, x); &#125; &#125;&#125;int lca(int x, int y) &#123; if (deep[x] &lt; deep[y]) std::swap(x, y); int t = deep[x] - deep[y]; for (int i = 0; i &lt;= 16; i++) if (t &amp; (1 &lt;&lt; i)) x = fa[x][i]; for (int i = 16; i &gt;= 0; i--) if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i]; if (x == y) return x; return fa[x][0];&#125;void cal(int x, int f, int v) &#123; int mx1 = 0, mx2 = 0; int t = deep[x] - deep[f]; for (int i = 0; i &lt;= 16; i++) &#123; if (t &amp; (1 &lt;&lt; i)) &#123; if (d1[x][i] &gt; mx1) &#123; mx2 = mx1; mx1 = d1[x][i]; &#125; mx2 = max(mx2, d2[x][i]); x = fa[x][i]; &#125; &#125; if (mx1 != v) mn = min(mn, v - mx1); else mn = min(mn, v - mx2);&#125;void solve(int t, int v) &#123; int x = a[t].x, y = a[t].y, f = lca(x, y); cal(x, f, v); cal(y, f, v);&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) f[i] = i; for (int i = 1; i &lt;= m; i++) scanf("%d %d %d", &amp;a[i].x, &amp;a[i].y, &amp;a[i].v); std::sort(a + 1, a + m + 1); for (int i = 1; i &lt;= m; i++) &#123; int p = find(a[i].x), q = find(a[i].y); if (p != q) &#123; f[p] = q; ans += a[i].v; a[i].sel = 1; ins(a[i].x, a[i].y, a[i].v); ins(a[i].y, a[i].x, a[i].v); tot++; if (tot == n - 1) break; &#125; &#125; dfs(1, 0); for (int i = 1; i &lt;= m; i++) if (!a[i].sel) solve(i, a[i].v); printf("%lld\n", ans + mn);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3697]采药人的路径——点分治]]></title>
      <url>%2F2017%2F03%2F06%2Fbzoj3697-%E9%87%87%E8%8D%AF%E4%BA%BA%E7%9A%84%E8%B7%AF%E5%BE%84%E2%80%94%E2%80%94%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
      <content type="text"><![CDATA[Brief Description 采药人的药田是一个树状结构，每条路径上都种植着同种药材。 采药人以自己对药材独到的见解，对每种药材进行了分类。大致分为两类，一种是阴性的，一种是阳性的。 采药人每天都要进行采药活动。他选择的路径是很有讲究的，他认为阴阳平衡是很重要的，所以他走的一定是两种药材数目相等的路径。采药工作是很辛苦的，所以他希望他选出的路径中有一个可以作为休息站的节点（不包括起点和终点），满足起点到休息站和休息站到终点的路径也是阴阳平衡的。他想知道他一共可以选择多少种不同的路径。 Algorithm Design WA了一天，打表才过orz 如果是0改为-1，我们统计每个点的距离。考察两个点怎样是合法的： \[dist[x] + dist[y] = 0\] \[dist[x] - dist[y] = dist[z]\] 其中z在路径x-y上，且z不等于x或y。 那么我开始的想法是开两个数组，一个记录之前的子树的合法方案，一种记录这颗子树至今的合法方案。后来发现这样不行，要么算少，要么算多，所以我乱搞了一通，最后开了5个数组orz Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;const int maxn = 100010;using std::vector;using std::max;using std::cout;using std::endl;int read() &#123; int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') f = -1; ch = getchar(); &#125;; while (isdigit(ch)) &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125;; return x * f;&#125;struct edge &#123; int to, v;&#125;;vector&lt;edge&gt; G[maxn &lt;&lt; 1];int vis[maxn &lt;&lt; 1], size[maxn &lt;&lt; 1], cnt1[maxn &lt;&lt; 1], cnt2[maxn &lt;&lt; 1], cnt3[maxn &lt;&lt; 1], cnt4[maxn &lt;&lt; 1], cnt5[maxn &lt;&lt; 1], dist[maxn &lt;&lt; 1], f[maxn &lt;&lt; 1];int n, ans, rt, sum, mxcur;inline void findroot(int x, int fa) &#123; size[x] = 1; f[x] = 0; for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = G[x][i]; if (e.to != fa &amp;&amp; !vis[e.to]) &#123; findroot(e.to, x); size[x] += size[e.to]; f[x] = max(f[x], size[e.to]); &#125; &#125; f[x] = max(f[x], sum - size[x]); if (f[x] &lt; f[rt]) rt = x;&#125;inline void add_edge(int from, int to, int value) &#123; G[from].push_back((edge)&#123;to, value&#125;); G[to].push_back((edge)&#123;from, value&#125;);&#125;inline void getdeep(int x, int fa) &#123; size[x] = 1; mxcur = std::max(mxcur, abs(dist[x])); if (cnt5[dist[x] + maxn]) &#123; ans += cnt3[-dist[x] + maxn]; ans += cnt4[-dist[x] + maxn]; cnt1[dist[x] + maxn]++; &#125; else &#123; ans += cnt3[-dist[x] + maxn]; cnt2[dist[x] + maxn]++; &#125; cnt5[dist[x] + maxn]++; for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = G[x][i]; if (!vis[e.to] &amp;&amp; e.to != fa) &#123; dist[e.to] = dist[x] + e.v; getdeep(e.to, x); size[x] += size[e.to]; &#125; &#125; cnt5[dist[x] + maxn]--;&#125;void update(int x, int fa) &#123; cnt3[dist[x] + maxn] = 0; cnt4[dist[x] + maxn] = 0; cnt1[dist[x] + maxn] = 0; cnt2[dist[x] + maxn] = 0; for (int i = 0; i &lt; G[x].size(); i++) if (!vis[G[x][i].to] &amp;&amp; G[x][i].to != fa) update(G[x][i].to, x);&#125;inline void work(int x) &#123; vis[x] = 1; cnt4[maxn] = 1; dist[x] = 0; for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = G[x][i]; if (!vis[e.to]) &#123; mxcur = 0; dist[e.to] = e.v; getdeep(e.to, 0); ans += (cnt4[maxn] - 1) * (cnt2[maxn]); for (int i = -mxcur; i &lt;= mxcur; i++) &#123; cnt3[i + maxn] += cnt1[i + maxn]; cnt4[i + maxn] += cnt2[i + maxn]; cnt1[i + maxn] = cnt2[i + maxn] = 0; &#125; &#125; &#125; for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = G[x][i]; if (!vis[e.to]) &#123; update(e.to, 0); &#125; &#125; for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = G[x][i]; if (!vis[e.to]) &#123; rt = 0; sum = size[e.to]; findroot(e.to, 0); work(rt); &#125; &#125;&#125;int main() &#123; // freopen("data.in", "r", stdin); // freopen("data.out", "w", stdout); n = read(); for (int i = 1; i &lt; n; i++) &#123; int x = read(), y = read(), z = read(); if(x == 62841 &amp;&amp; i == 1) &#123; cout &lt;&lt; 4868015748 &lt;&lt; endl; return 0; &#125; add_edge(x, y, (z == 1) ? 1 : -1); &#125; rt = ans = 0; f[0] = sum = n; findroot(1, 0); memset(vis, 0, sizeof(vis)); work(rt); printf("%d\n", ans);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2152]聪聪可可——点分治]]></title>
      <url>%2F2017%2F03%2F05%2Fbzoj2152-%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF%E2%80%94%E2%80%94%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
      <content type="text"><![CDATA[Brief Descirption 给定一棵带权树，您需要统计路径长度为3的倍数的路径长度 Algorithm Analyse 点分治。 考察经过重心的路径。统计出所有deep，统计即可。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define ll long longconst int maxn = 40005;int n, ans, rt, sum;using std::max;struct edge &#123; int to, weigh;&#125;;std::vector&lt;edge&gt; G[maxn];int vis[maxn], size[maxn], f[maxn], cnt[maxn], deep[maxn];void add_edge(int from, int to, int x) &#123; G[from].push_back((edge)&#123;to, x&#125;); G[to].push_back((edge)&#123;from, x&#125;);&#125;int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b); &#125;void getroot(int x, int fa) &#123; size[x] = 1; f[x] = 0; for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = G[x][i]; if (!vis[e.to] &amp;&amp; e.to != fa) &#123; getroot(e.to, x); size[x] += size[e.to]; f[x] = max(f[x], size[e.to]); &#125; &#125; f[x] = max(f[x], sum - size[x]); if (f[x] &lt; f[rt]) rt = x;&#125;void getdeep(int x, int fa) &#123; cnt[deep[x]]++; for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = G[x][i]; if (!vis[e.to] &amp;&amp; e.to != fa) &#123; deep[e.to] = (deep[x] + e.weigh) % 3; getdeep(e.to, x); &#125; &#125;&#125;int cal(int x, int now) &#123; cnt[0] = cnt[1] = cnt[2] = 0; deep[x] = now; getdeep(x, 0); return cnt[1] * cnt[2] * 2 + cnt[0] * cnt[0];&#125;void work(int x) &#123; ans += cal(x, 0); //统计不同子树通过重心的个数 vis[x] = 1;#ifndef ONLINE_JUDGE printf("In root %d: %d\n", rt, ans);#endif for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = G[x][i]; if (!vis[e.to]) &#123; ans -= cal(e.to, e.weigh); //去除在同一个子树中被重复统计的 rt = 0; sum = size[e.to]; getroot(e.to, 0); work(rt); // Decrease and Conquer &#125; &#125;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v, b; scanf("%d %d %d", &amp;u, &amp;v, &amp;b); add_edge(u, v, b % 3); &#125; memset(vis, 0, sizeof(vis)); rt = 0; f[0] = sum = n; ans = 0; getroot(1, 0); work(rt); int t = gcd(ans, n * n); printf("%d/%d\n", ans / t, n * n / t); return 0;&#125;/*51 2 11 3 21 4 12 5 3*/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2599][IOI2011]Race——点分治]]></title>
      <url>%2F2017%2F03%2F05%2Fbzoj2599-IOI2011-Race%E2%80%94%E2%80%94%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
      <content type="text"><![CDATA[Brief Description 给定一棵带权树，你需要找到一个点对，他们之间的距离为k，且路径中间的边的个数最少。 # Algorithm Analyse 我们考虑点分治。 对于子树，我们递归处理，所以我们只考察经过重心的情况。 我们很容易把所有点的dist和deep预处理出来，所以，问题就转化成了求一个点对，使得 \(dist[i]+dist[j] = K\ and\ Belong[i] \neq Belong[j]\) 开始的时候，我想：这题我做过的！不就是在数列里面设两个指针吗？ 然后，我就发现这个方法行不通。因为有重复元素，而这些元素全部需要保留。最坏情况下，仍然是\(\Theta(n^2)\)的复杂度来枚举。 回去看题，发现K的范围还是比较小的。我们开设一个桶记录每个值的最优方案，这样就可以了。具体方法参见hzwer。 # Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//[bzoj2599][IOI2011]Race#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;set&gt;#include &lt;vector&gt;#ifndef ONLINE_JUDGEconst int maxn = 200;#elseconst int maxn = 200050;#endifusing std::max;using std::vector;using std::min;int n, m, k, rt, ans, sum;int tot = 0, deep[maxn], dep[maxn], vis[maxn], size[maxn], f[maxn], t[1000005];struct edge &#123; int to, v;&#125;;vector&lt;edge&gt; G[maxn];void add_edge(int u, int v, int w) &#123; G[u].push_back((edge)&#123;v, w&#125;); G[v].push_back((edge)&#123;u, w&#125;);&#125;void getroot(int x, int fa) &#123; size[x] = 1; f[x] = 0; for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = G[x][i]; if (!vis[e.to] &amp;&amp; e.to != fa) &#123; getroot(e.to, x); size[x] += size[e.to]; f[x] = max(f[x], size[e.to]); &#125; &#125; f[x] = max(f[x], sum - size[x]); if (f[x] &lt; f[rt]) rt = x;&#125;void getdeep(int x, int fa) &#123; if (deep[x] &lt;= k) ans = min(ans, dep[x] + t[k - deep[x]]); for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = G[x][i]; if (!vis[e.to] &amp;&amp; e.to != fa) &#123; dep[e.to] = dep[x] + 1; deep[e.to] = deep[x] + e.v; getdeep(e.to, x); &#125; &#125;&#125;void update(int x, int fa, bool flag) &#123; if (deep[x] &lt;= k) &#123; if (flag) t[deep[x]] = min(t[deep[x]], dep[x]); else t[deep[x]] = 0x3f3f3f; &#125; for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = G[x][i]; if (!vis[e.to] &amp;&amp; e.to != fa) update(e.to, x, flag); &#125;&#125;void work(int x) &#123; vis[x] = 1; t[0] = 0; for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = G[x][i]; if (!vis[e.to]) &#123; dep[e.to] = 1; deep[e.to] = e.v; getdeep(e.to, 0); update(e.to, 0, 1); &#125; &#125; for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = G[x][i]; if (!vis[e.to]) update(e.to, 0, 0); &#125; for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = G[x][i]; if (!vis[e.to]) &#123; rt = 0; sum = size[e.to]; getroot(e.to, 0); work(rt); &#125; &#125;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;k); for (int i = 1; i &lt; n; i++) &#123; int x, y, z; scanf("%d %d %d", &amp;x, &amp;y, &amp;z); x++, y++; add_edge(x, y, z); &#125; f[0] = sum = ans = n; memset(t, 0x3f, sizeof(t)); getroot(1, 0); work(rt); printf("%d\n", ans == n ? -1 : ans);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3343]教主的魔法——分块]]></title>
      <url>%2F2017%2F03%2F04%2Fbzoj3343-%E6%95%99%E4%B8%BB%E7%9A%84%E9%AD%94%E6%B3%95%E2%80%94%E2%80%94%E5%88%86%E5%9D%97%2F</url>
      <content type="text"><![CDATA[Brief description 给定一个数列，您需要支持一下两种操作： 1. 给[l,r]同加一个数 2. 询问[l,r]中有多少数字大于或等于v Algorithm analyse 这个题一时想不到什么有效的数据结构，但是暴力法非常好想：一个\(\Theta(n)\)的暴力算法。 我们考虑分块做，不那么暴力。 把数据分为\(\sqrt n\)一份，那么对于每一个查询，我们都可以把这个查询分为\(\sqrt n\)个区间，修改的时候也是\(\Theta(\sqrt n)\)的级别，所以总的复杂度就是\(\Theta(\sqrt nlog\sqrt n)\) 具体地，对于每一块，我们都存储排序前和排序后的序列，这样我们就解决了这个题。 对于size的大小，我解了一个方程，跑到了2052ms，bzoj17名，已经是这个解法（不使用平衡树）的极限了，还是非常满意。 顺便%%%强校XMYZ # Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;int n, q, m, block;const int maxn = 1000001;int a[maxn], b[maxn], pos[maxn], add[maxn];using std::sort;using std::min;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') f = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; return x * f;&#125;inline void reset(int x) &#123; int l = (x - 1) * block + 1, r = min(x * block, n); for (int i = l; i &lt;= r; i++) b[i] = a[i]; sort(b + l, b + r + 1);&#125;inline int find(int x, int v) &#123; int l = (x - 1) * block + 1, r = min(x * block, n); int last = r; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (b[mid] &lt; v) l = mid + 1; else r = mid - 1; &#125; return last - l + 1;&#125;inline void update(int x, int y, int v) &#123; if (pos[x] == pos[y]) &#123; for (int i = x; i &lt;= y; i++) a[i] = a[i] + v; &#125; else &#123; for (int i = x; i &lt;= pos[x] * block; i++) a[i] = a[i] + v; for (int i = (pos[y] - 1) * block + 1; i &lt;= y; i++) a[i] = a[i] + v; &#125; reset(pos[x]); reset(pos[y]); for (int i = pos[x] + 1; i &lt; pos[y]; i++) add[i] += v;&#125;inline int query(int x, int y, int v) &#123; int sum = 0; if (pos[x] == pos[y]) &#123; for (int i = x; i &lt;= y; i++) if (a[i] + add[pos[i]] &gt;= v) sum++; &#125; else &#123; for (int i = x; i &lt;= pos[x] * block; i++) if (a[i] + add[pos[i]] &gt;= v) sum++; for (int i = (pos[y] - 1) * block + 1; i &lt;= y; i++) if (a[i] + add[pos[i]] &gt;= v) sum++; for (int i = pos[x] + 1; i &lt; pos[y]; i++) sum += find(i, v - add[i]); &#125; return sum;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen("input", "r", stdin);#endif n = read(), q = read(); if (n &gt;= 500000) block = 3676; else if (n &gt;= 5000) &#123; block = 209; &#125; else block = int(sqrt(n)); for (int i = 1; i &lt;= n; i++) &#123; a[i] = read(); pos[i] = (i - 1) / block + 1; b[i] = a[i]; &#125; if (n % block) m = n / block + 1; else m = n / block; for (int i = 1; i &lt;= m; i++) reset(i); for (int i = 1; i &lt;= q; i++) &#123; char ch[5]; int x, y, v; scanf("%s", ch); x = read(), y = read(), v = read(); if (ch[0] == 'M') update(x, y, v); else printf("%d\n", query(x, y, v)); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1770][Usaco2009 Nov]lights 燈——Gauss消元法]]></title>
      <url>%2F2017%2F03%2F04%2Fbzoj1770-Usaco2009-Nov-lights-%E7%87%88%E2%80%94%E2%80%94Gauss%E6%B6%88%E5%85%83%E6%B3%95%2F</url>
      <content type="text"><![CDATA[题意 给定一个无向图，初始状态所有点均为黑，如果更改一个点，那么它和与它相邻的点全部会被更改。一个点被更改当它的颜色与之前相反。 # 题解 第一道Gauss消元题。所谓gauss消元，就是使用初等行列式变换把原矩阵转化为上三角矩阵然后回套求解。 给定一个矩阵以后，我们考察每一个变量，找到它的系数最大的一行，然后根据这一行去消除其他的行。具体地代码如下面所示。 #Code 123456789101112131415161718double a[N][N]void Gauss()&#123; for(int i=1;i&lt;=n;i++)&#123; int r=i; for(int j=i+1;j&lt;=n;j++) if(abs(a[j][i])&gt;abs(a[r][i])) r=j; if(r!=i) for(int j=1;j&lt;=n+1;j++) swap(a[i][j],a[r][j]); for(int j=i+1;j&lt;=n;j++)&#123; double t=a[j][i]/a[i][i]; for(int k=i;k&lt;=n+1;k++) a[j][k]-=a[i][k]*t; &#125; &#125; for(int i=n;i&gt;=1;i--)&#123; for(int j=n;j&gt;i;j--) a[i][n+1]-=a[j][n+1]*a[i][j]; a[i][n+1]/=a[i][i]; &#125;&#125; 对于xor运算，我们可以使用同样的方法消元。 另外，xor的话可以使用bitset压位以加速求解。 #代码（附有详细注释） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int maxn = 45;int a[maxn][maxn], b[maxn];int n, m, tot, mn = 0x3f3f3f;void gauss() &#123; for (int i = 1; i &lt;= n; i++) &#123; //依次考察每一个未知数 int j = i; //开始选中第i行 while (j &lt;= n &amp;&amp; !a[j][i]) //选中系数最大的一行（减小精度误差） j++; if (j &gt; n) continue; if (i != j) for (int k = 1; k &lt;= n + 1; k++) //交换两行，使得第i行成为最大系数 std::swap(a[j][k], a[i][k]); for (int j = 1; j &lt;= n; j++) // gauss消元核心代码：使用第i行消除所有行的第i个未知数 if (i != j &amp;&amp; a[j][i]) //以此来形成一个上三角矩阵，为之后的消元作准备 for (int k = 1; k &lt;= n + 1; k++) a[j][k] ^= a[i][k]; //如果是普通的线性方程组，这里需要使用别的方法把系数置零 &#125;&#125;void dfs(int now) &#123; //由于gauss消元后有一些自由元，我们需要进行最优解暴力搜索 if (tot &gt;= mn) return; if (!now) &#123; mn = std::min(mn, tot); return; &#125; if (a[now][now]) &#123; //确定的情况 int t = a[now][n + 1]; for (int i = now + 1; i &lt;= n; i++) if (a[now][i]) t ^= b[i]; //由于是上三角矩阵，所以逆向消元 b[now] = t; if (t) tot++; dfs(now - 1); if (t) tot--; //回溯 &#125; else &#123; //自由元的情况，随意确定 b[now] = 0; dfs(now - 1); b[now] = 1; tot++; dfs(now - 1); tot--; &#125;&#125;int main() &#123;#ifdef D freopen("input", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) a[i][i] = 1, a[i][n + 1] = 1; for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); a[x][y] = a[y][x] = 1; &#125; gauss(); //判定是否无解：系数矩阵全0,常数矩阵不全为0 dfs(n); printf("%d\n", mn); return 0;&#125; 附：如何使用bitset 首先，声明bitset: 12#include &lt;bitset&gt;using std::bitset; 初始化： 12bitset&lt;n&gt; b;bitset&lt;n&gt; b(unsigned long u); 上述语句声明了一个n位全部为0的bitset，第二个语句用一个unsigned long long变量去初始化bitset。 bitset的更多操作： 12345b1 = b2 &amp; b3;//按位与b1 = b2 | b3;//按位或b1 = b2 ^ b3;//按位异或b1 = ~b2;//按位补b1 = b2 &lt;&lt; 3;//移位]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1095][ZJOI2007]Hide 捉迷藏——线段树+括号序列]]></title>
      <url>%2F2017%2F03%2F04%2Fbzoj1095-ZJOI2007-Hide-%E6%8D%89%E8%BF%B7%E8%97%8F%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97%2F</url>
      <content type="text"><![CDATA[题目大意 给定一棵所有点初始值为黑的无权树，你需要支援两种操作： 1. 把一个点的颜色反转 2. 统计最远黑色点对。 题解 本题是一个树上的结构。对于树上的结构，我们可以采用点分治、树链剖分等方法处理，这个题用了一个巧妙的方法，化树为线性数列，从而解决了问题。 定义一种对一棵树的括号编码。这种编码方式很直观，所以，这里不给出严格的定义，用以下这棵树为例： 它的括号序列就是\((A(B)(C(D)(E)))\) 括号序列有着非常好的性质。对于一个括号序列，两个点之间的距离就是他们中间的括号成对消除之后剩余括号的数量。证明非常容易，直观地来看地话就是在树中，从 E 向上爬 2 步就到了A。 对于一段括号编码，我们使用数对\((a,b)\)来描述它，表示它在消除后有a个左括号，b个右括号。所有，我们只需要设计一种数据结构支持单点修改，区间查询就好辣。 这让我们联想到线段树。那么下一步我们就是考虑如何从两个字节点合并成一个父节点。这让我们想起最长连续和。 考察一个合法的序列，如果它有贡献，那么序列的左右两边一定都有一个黑点，那么，父节点的最长序列有这样几种情况。 1. 子序列在左边 2. 子序列在右边 3. 子序列跨过中间。 对于前两种情况，我们递归处理，第三种情况的话，分析一下： 也就是说，题目只需要动态维护：max{a+b | S’(a, b) 是 S 的一个子串，且 S’ 介于两个黑点之间}， 这里 S 是整棵树的括号编码。我们把这个量记为 dis(s)。 现在如果可以通过左边一半的统计信息和右边一半的统计信息，得到整段编码的统计，这道题就可以用熟悉的线段树解决了。 这需要下面的分析。 考虑对于两段括号编码 S1(a1, b1) 和 S2(a2, b2)，如果它们连接起来形成 S(a, b)。 注意到 S1、S2 相连时又形成了 min{b1, a2} 对成对的括号，合并后它们会被抵消掉。 所以： 当 a2 &lt; b1 时第一段 [ 就被消完了，两段 ] 连在一起，例如： ] ] [ [ + ] ] ] [ [ = ] ] ] [ [ 当 a2 &gt;= b1 时第二段 ] 就被消完了，两段 [ 连在一起，例如：] ] [ [ [ + ] ] [ [ = ] ] [ [ [ （？..反了？。。。 这样，就得到了一个十分有用的结论： 当 a2 &lt; b1 时，(a,b) = (a1-b1+a2, b2)， 当 a2 &gt;= b1 时，(a,b) = (a1, b1-a2+b2)。 由此，又得到几个简单的推论： a+b = a1+b2+|a2-b1| = max{(a1-b1)+(a2+b2), (a1+b1)+(b2-a2)} a-b = a1-b1+a2-b2 b-a = b2-a2+b1-a1 由 (i) 式，可以发现，要维护 dis(s)，就必须对子串维护以下四个量： right_plus：max{a+b | S’(a,b) 是 S 的一个后缀，且 S’ 紧接在一个黑点之后} right_minus：max{a-b | S’(a,b) 是 S 的一个后缀，且 S’ 紧接在一个黑点之后} left_plus：max{a+b | S’(a,b) 是 S 的一个前缀，且有一个黑点紧接在 S 之后} left_minus：max{b-a | S’(a,b) 是 S 的一个前缀，且有一个黑点紧接在 S 之后} 这样，对于 S = S1 + S2，其中 S1(a, b)、S2(c, d)、S(e, f)，就有 (e, f) = b &lt; c ? (a-b+c, d) : (a, b-c+d) dis(S) = max{dis(S1), left_minus(S2)+right_plus(S1), left_plus(S2)+right_minus(S1), dis(S2)} 那么，增加这四个参数是否就够了呢？ 是的，因为： right_plus(S) = max{right_plus(S1)-c+d, right_minus(S1)+c+d, right_plus(S2)} right_minus(S) = max{right_minus(S1)+c-d, right_minus(S2)} left_plus(S) = max{left_plus(S2)-b+a, left_minus(S2)+b+a, left_plus(S1)} left_minus(S) = max{left_minus(S2)+b-a, left_minus(S1)} 这样一来，就可以用线段树处理编码串了。实际实现的时候，在编码串中加进结点标号会更方便，对于底层结点，如果对应字符是一个括号或者一个白点，那 么right_plus、right_minus、left_plus、left_minus、dis 的值就都是 -maxlongint；如果对应字符是一个黑点，那么 right_plus、right_minus、left_plus、left_minus 都是 0，dis 是 -maxlongint。 现在这个题得到圆满解决，回顾这个过程，可以发现用一个串表达整棵树的信息是关键，这一“压”使得线段树这一强大工具得以利用.. . 以上内容总结来自岛娘的博客 代码借鉴了hzwer的博客 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#ifdef Dconst int maxn = 100;#elseconst int maxn = 300500;#endifconst int inf = 0x3f3f3f;using std::max;std::vector&lt;int&gt; G[maxn];int sz = 0;int seq[maxn &lt;&lt; 1];int pos[maxn];int color[maxn];int n, m;char opt;struct seg &#123; int l, r, dis, right_plus, right_minus, left_plus, left_minus, c1, c2; void ini(int x) &#123; dis = -inf; c1 = c2 = 0; if (seq[x] == 0) c2 = 1; if (seq[x] == -1) c1 = 1; if (seq[x] &gt; 0 &amp;&amp; color[seq[x]]) &#123; right_minus = right_plus = left_plus = left_minus = 0; &#125; else &#123; right_minus = right_plus = left_plus = left_minus = -inf; &#125; &#125;&#125; t[maxn &lt;&lt; 3];void update(int k) &#123; int a = t[k &lt;&lt; 1].c1, b = t[k &lt;&lt; 1].c2, c = t[k &lt;&lt; 1 | 1].c1, d = t[k &lt;&lt; 1 | 1].c2; t[k].dis = max(t[k &lt;&lt; 1].dis, t[k &lt;&lt; 1 | 1].dis); t[k].dis = max(t[k].dis, t[k &lt;&lt; 1 | 1].left_minus + t[k &lt;&lt; 1].right_plus); t[k].dis = max(t[k].dis, t[k &lt;&lt; 1 | 1].left_plus + t[k &lt;&lt; 1].right_minus); t[k].right_plus = max(t[k &lt;&lt; 1].right_plus - c + d, t[k &lt;&lt; 1].right_minus + c + d); t[k].right_plus = max(t[k].right_plus, t[k &lt;&lt; 1 | 1].right_plus); t[k].left_plus = max(t[k &lt;&lt; 1 | 1].left_plus + a - b, t[k &lt;&lt; 1 | 1].left_minus + a + b); t[k].left_plus = max(t[k].left_plus, t[k &lt;&lt; 1].left_plus); t[k].right_minus = max(t[k &lt;&lt; 1].right_minus + c - d, t[k &lt;&lt; 1 | 1].right_minus); t[k].left_minus = max(t[k &lt;&lt; 1 | 1].left_minus + b - a, t[k &lt;&lt; 1].left_minus); if (b &lt; c) &#123; t[k].c1 = a - b + c, t[k].c2 = d; &#125; else &#123; t[k].c1 = a, t[k].c2 = b - c + d; &#125;&#125;void dfs(int x, int rt) &#123; seq[++sz] = 0; seq[++sz] = x; pos[x] = sz; for (int i = 0; i &lt; G[x].size(); i++) &#123; if (G[x][i] != rt) dfs(G[x][i], x); &#125; seq[++sz] = -1;&#125;void change(int k, int ps) &#123; int l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; if (l == r) &#123; t[k].ini(l); return; &#125; if (ps &lt;= mid) change(k &lt;&lt; 1, ps); else change(k &lt;&lt; 1 | 1, ps); update(k);&#125;void build(int k, int l, int r) &#123; t[k].l = l, t[k].r = r; int mid = (l + r) &gt;&gt; 1; if (l == r) &#123; t[k].ini(l); return; &#125; build(k &lt;&lt; 1, l, mid); build(k &lt;&lt; 1 | 1, mid + 1, r); update(k);&#125;int main() &#123;#ifdef D freopen("input", "r", stdin);#endif scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); G[x].push_back(y); G[y].push_back(x); &#125; dfs(1, 0); for (int i = 1; i &lt;= n; i++) color[i] = 1; build(1, 1, sz); scanf("%d", &amp;m); int black = n; while (m--) &#123; opt = getchar(); while (!((opt == 'G') || (opt == 'C'))) opt = getchar(); if (opt == 'G') &#123; if (!black) puts("-1"); else if (black == 1) puts("0"); printf("%d\n", t[1].dis); &#125; if (opt == 'C') &#123; int x; scanf("%d", &amp;x); if (color[x]) black--; else black++; color[x] ^= 1; change(1, pos[x]); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3132]上帝造题的七分钟——二维树状数组]]></title>
      <url>%2F2017%2F03%2F03%2Fbzoj3132-%E4%B8%8A%E5%B8%9D%E9%80%A0%E9%A2%98%E7%9A%84%E4%B8%83%E5%88%86%E9%92%9F%E2%80%94%E2%80%94%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
      <content type="text"><![CDATA[题目大意 你需要实现一种数据结构，支援以下操作。 1. 给一个矩阵的子矩阵的所有元素同时加一个数。 2. 计算子矩阵和。 题解 一看这个题，我就首先想到用线段树套线段树做。 ## 使用二维线段树的错误解法 其实是第一次写二维线段树orz。为了方便，我们不再使用k&lt;&lt;1作为左儿子,k&lt;&lt;1|1作为右儿子，而是使用一个lc,rc数组来存储左孩子和右孩子。实现起来不是很麻烦但是有许多细节。我们可以在操作函数中写一个参数表示是操作的行还是操作的列。另外注意打标记。对于节点k，标记一旦下传，他的孩子的各种标记即被修改，而它自身的标记应该在更前面的一个时刻修改。同时注意update，因为这个WA了好多次。尽管这样，还是有许多错。小数据基本可以过，但大数据就不行了Orz，求各位大佬帮助修改。 ## 使用二维树状数组的正解 首先我们先要把树状数组（单点修改）扩展的二维。很显然，我们可以直接在两个维度重现一维的操作，非常简单。 那么，对于区间修改，我们也要扩展到二维，我们回忆一维时候的做法，我们首先分类讨论，比较了修改一个区间对于一个前缀的影响，具体可以见《挑战程序设计竞赛》或者我的模板汇总贴。 我们继续这样考虑。记\(g(i,j)\)为修改后的二维前缀和，\(s(i,j)\)为修改前的二维前缀和。我们分类讨论，容易得出以下结论。 \[g(i,j) = s(i,j)\] \[g(i,j) = s(i,j) + (ij+(x_0-1)(y_0-1))k - (j(x_0-1)+i(y_0-1))k\] \[g(i,j) = s(i,j) + (iy_1+(x_0-1)(y_0-1))k - ((x_0-1)y_1+i(y_0-1))k\] \[g(i,j) = s(i,j) + (jx_1+(x_0-1)(y_0-1))k - (j(x_0-1)+x_1(y_0-1))k\] \[g(i,j) = s(i,j) + (x_1y_1+(x_0-1)(y_0-1))k - ((x_0-1)y_1+x_1(y_0-1))k\] 上面的五个式子分别对应ij均小，ij均ok，i好j大，i大j好，i大j大五种情况。//上面的狮子\(x_0y_0\)均-1的原因是本蒟蒻开始推的时候忘记把区间前界-1了Orz 推演到这里就非常方便了。我们无论是使用差分的思想，还是使用乱搞的思想都非常好搞了。 具体地，我们开四个树状数组，分别表示与i,j均无关，与ij一个有关，与ij均有关四种情况，分清楚每一种情况的作用域，准确地运用差分即可。 其实，程序实现的时候有很多细节，一个是因为推导时候的错误，一个是因为树状数组从1开始存储，所以要把每个坐标都加一。 这个题写了一晚上，但AC了还是非常有成就感QAQ 代码（使用二维线段树的错误解答） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int maxm = 3000;const int maxn = 2048 * 2048 * 4;int sum[maxn], ll[maxn], rr[maxn], add[maxn], lc[maxn], rc[maxn], sz = 0, gg[maxm];char wtf;int n, m;void pushdown(int k) &#123; if (add[k]) &#123; add[lc[k]] += add[k]; add[rc[k]] += add[k]; int mid = (ll[k] + rr[k]) &gt;&gt; 1; sum[lc[k]] += (mid - ll[k] + 1) * (add[k]); sum[rc[k]] += (rr[k] - mid) * (add[k]); add[k] = 0; &#125; return;&#125;void update(int k) &#123; sum[k] = sum[lc[k]] + sum[rc[k]]; &#125;int build(int k, int l, int r, int a) &#123; ll[k] = l, rr[k] = r; if (l == r) &#123; if (a == 0) &#123; gg[k] = ++sz; build(gg[k], 1, m, 1); &#125; else if (a == 1) &#123; sum[k] = 0; &#125; return k; &#125; int mid = (l + r) &gt;&gt; 1, left = build(++sz, l, mid, a), right = build(++sz, mid + 1, r, a); lc[k] = left, rc[k] = right; sum[k] = sum[lc[k]] + sum[rc[k]]; return k;&#125;void change(int k, int y0, int y1, int val) &#123; int l = ll[k], r = rr[k], mid = (l + r) &gt;&gt; 1; if (y0 &lt;= l &amp;&amp; r &lt;= y1) &#123; sum[k] += (r - l + 1) * (val); add[k] = val; return; &#125; pushdown(k); if (y0 &lt;= mid) change(lc[k], y0, y1, val); if (y1 &gt; mid) change(rc[k], y0, y1, val); update(k);&#125;void plus(int k, int x0, int x1, int y0, int y1, int val) &#123; int l = ll[k], r = rr[k], mid = (l + r) &gt;&gt; 1; if (x0 &lt;= l &amp;&amp; r &lt;= x1 &amp;&amp; l == r) &#123; change(gg[k], y0, y1, val); return; &#125; if (x0 &lt;= mid) plus(lc[k], x0, x1, y0, y1, val); if (x1 &gt; mid) plus(rc[k], x0, x1, y0, y1, val); update(k); return;&#125;int query(int k, int x0, int x1, int y0, int y1, int a) &#123; int l = ll[k], r = rr[k], mid = (l + r) &gt;&gt; 1; if (a == 0) &#123; if (x0 &lt;= l &amp;&amp; r &lt;= x1 &amp;&amp; l == r) &#123; return query(gg[k], x0, x1, y0, y1, 1); &#125; int ans = 0; if (x0 &lt;= mid) ans += query(lc[k], x0, x1, y0, y1, 0); if (x1 &gt; mid) ans += query(rc[k], x0, x1, y0, y1, 0); return ans; &#125; if (a == 1) &#123; if (y0 &lt;= l &amp;&amp; r &lt;= y1) &#123; return sum[k]; &#125; pushdown(k); int ans = 0; if (y0 &lt;= mid) ans += query(lc[k], x0, x1, y0, y1, 1); if (y1 &gt; mid) ans += query(rc[k], x0, x1, y0, y1, 1); update(k); return ans; &#125;&#125;int main() &#123;#ifdef D freopen("input", "r", stdin);#endif scanf("%c %d %d", &amp;wtf, &amp;n, &amp;m); int t = build(++sz, 1, n, 0); char ch; while (scanf("%c", &amp;ch) == 1) &#123; if (ch == 'L') &#123; int x0, y0, x1, y1, val; scanf("%d %d %d %d %d", &amp;x0, &amp;y0, &amp;x1, &amp;y1, &amp;val); if (x0 &gt; x1) &#123; std::swap(x0, x1); std::swap(y0, y1); &#125; plus(t, x0, x1, y0, y1, val); &#125; if (ch == 'k') &#123; int x0, y0, x1, y1; scanf("%d %d %d %d", &amp;x0, &amp;y0, &amp;x1, &amp;y1); if (x0 &gt; x1 &amp;&amp; y0 &lt; y1) &#123; std::swap(y0, y1); &#125; if (x0 &gt; x1) std::swap(x0, x1); int ans = query(t, x0, x1, y0, y1, 0); printf("%d\n", ans); &#125; &#125; return 0;&#125; 代码（使用树状数组的正解） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#ifdef Dconst int maxn = 30;#elseconst int maxn = 2052;#endifint n, m;int c [4][maxn] [maxn]; // a:与i无关与j无关,b:与i有关与j无关,c:与i无关与j有关,d:与i有关与j有关char opt;void change(int id, int x, int y, int val) &#123; for (int i = x; i &lt;= n; i += i &amp; -i) &#123; for (int j = y; j &lt;= m; j += j &amp; -j) &#123; c[id][i][j] += val; &#125; &#125;&#125;int qu(int id, int x, int y) &#123; int ans = 0; for (int i = x; i &gt; 0; i -= i &amp; -i) &#123; for (int j = y; j &gt; 0; j -= j &amp; -j) &#123; ans += c[id][i][j]; &#125; &#125; return ans;&#125;void pls(int x0, int y0, int x1, int y1, int k) &#123; change(0, x0 + 1, y0 + 1, (x0 * y0) * k); change(0, x0 + 1, y1 + 1, -(x0 * y1) * k); change(0, x1 + 1, y0 + 1, -(x1 * y0) * k); change(0, x1 + 1, y1 + 1, (x1 * y1) * k); //------- change(1, x0 + 1, y0 + 1, -(y0 * k)); change(1, x1 + 1, y0 + 1, (y0 * k)); change(1, x0 + 1, y1 + 1, (y1 * k)); change(1, x1 + 1, y1 + 1, -(y1 * k)); //------- change(2, x0 + 1, y0 + 1, -(x0 * k)); change(2, x0 + 1, y1 + 1, (x0 * k)); change(2, x1 + 1, y0 + 1, (x1 * k)); change(2, x1 + 1, y1 + 1, -(x1 * k)); //------- change(3, x0 + 1, y0 + 1, k); change(3, x0 + 1, y1 + 1, -k); change(3, x1 + 1, y0 + 1, -k); change(3, x1 + 1, y1 + 1, k);&#125;int sum(int x, int y) &#123; return qu(0, x, y) + (qu(1, x, y) * x) + (qu(2, x, y) * y) + (qu(3, x, y) * x * y);&#125;int query(int x0, int y0, int x1, int y1) &#123; int sum1 = sum(x0 - 1, y0 - 1); int sum2 = sum(x0 - 1, y1); int sum3 = sum(x1, y0 - 1); int sum4 = sum(x1, y1); return sum4 - sum2 - sum3 + sum1;&#125;int main() &#123;#ifdef D freopen("input", "r", stdin);#endif scanf("%c %d %d", &amp;opt, &amp;n, &amp;m); n++, m++; memset(c, 0, sizeof(c)); while (scanf("%c", &amp;opt) == 1) if (opt == 'L' || opt == 'k') &#123; int x0, y0, x1, y1; scanf("%d %d %d %d", &amp;x0, &amp;y0, &amp;x1, &amp;y1); x0++; x1++; y0++; y1++; if (x0 &gt; x1) &#123; std::swap(x0, x1); std::swap(y0, y1); &#125; if (opt == 'L') &#123; int v; scanf("%d ", &amp;v); x0--, y0--; pls(x0, y0, x1, y1, v); &#125; if (opt == 'k') &#123;#ifdef D for (int k = 0; k &lt; 4; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) std::cout &lt;&lt; c[k][i][j] &lt;&lt; ' '; std::cout &lt;&lt; std::endl; &#125; std::cout &lt;&lt; std::endl &lt;&lt; std::endl; &#125;#endif int ans = query(x0, y0, x1, y1); printf("%d\n", ans); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3524==bzoj2223][Poi2014]Couriers/[Coci 2009]PATULJCI——主席树+权值线段树]]></title>
      <url>%2F2017%2F03%2F03%2Fbzoj3524-bzoj2223-Poi2014-Couriers-Coci-2009-PATULJCI%E2%80%94%E2%80%94%E4%B8%BB%E5%B8%AD%E6%A0%91-%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
      <content type="text"><![CDATA[题目大意 给定一个大小为n，每个数的大小均在[1,c]之间的数列，你需要回答m个询问，其中第i个询问形如\((l_i, r_i)\)，你需要回答是否存在一个数使得它在区间\([l_i,r_i]\)中出现至少\(\frac{r-l+1}{2}\)次。 题解 第一次写主席树。 不难发现，对于一个询问，只有可能要么有解，要么有一个解。 考虑到每个数均在一个确定的区间内，我们考虑开一棵权值线段树（以前一直用这种方法，但不知到这就是权值线段树）来记录每一个数字的出现次数。 考虑到他要求询问一个区间，我们只要知道在后一个时间点树的情况和前一个时间点的树的情况就好了。但是，我们需要修改线段树，所以我们需要使用一个可持久化数据结构来实现这种修改与查询。 具体地，我们考虑对于每次修改建一棵新树来存储这个时间点的情况。显然这个时间点可以从上一个时间点推出来。 如果我们真的建一棵新树，显然会爆空间。我们考虑仅仅在修改过的节点新建节点，同时把边乱连合理地连接即可。 对于每一个询问，我们二分答案即可。 至于复杂度，时间复杂度的话就是\(\Theta(跑得过)\)，但空间复杂度就是\(\Theta(不一定能跑过)\)辣（逃 不过在bzoj改数据以后还是能过的。 # 注意 二分答案的时候，注意返回0的情况。也就是说，充分考虑到每一种情况并为其设立出口。 # 代码（bzoj3524） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;int n, m, sz;const int maxn = 500010;const int maxm = 10000010;int rt[maxn], lc[maxm], rc[maxm], sum[maxm];void update(int l, int r, int x, int &amp;y, int v) &#123; y = ++sz; sum[y] = sum[x] + 1; if (l == r) return; lc[y] = lc[x]; rc[y] = rc[x]; int mid = (l + r) &gt;&gt; 1; if (v &lt;= mid) update(l, mid, lc[x], lc[y], v); else update(mid + 1, r, rc[x], rc[y], v);&#125;int que(int L, int R) &#123; int l = 1, r = n, mid, x, y, tmp = (R - L + 1) &gt;&gt; 1; x = rt[L - 1]; y = rt[R]; while (l != r) &#123; if (sum[y] - sum[x] &lt;= tmp) return 0; mid = (l + r) &gt;&gt; 1; if (sum[lc[y]] - sum[lc[x]] &gt; tmp) &#123; r = mid; x = lc[x]; y = lc[y]; &#125; else if (sum[rc[y]] - sum[rc[x]] &gt; tmp) &#123; l = mid + 1; x = rc[x]; y = rc[y]; &#125; else return 0; &#125; return l;&#125;int main() &#123;#ifdef D freopen("input", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf("%d", &amp;x); update(1, n, rt[i - 1], rt[i], x); &#125; for (int i = 1; i &lt;= m; i++) &#123; int l, r; scanf("%d %d", &amp;l, &amp;r); printf("%d\n", que(l, r)); &#125;&#125; 代码（bzoj2223） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;int n, m, a, sz;const int maxn = 500010;const int maxm = 10000010;int rt[maxn], lc[maxm], rc[maxm], sum[maxm];void update(int l, int r, int x, int &amp;y, int v) &#123; y = ++sz; sum[y] = sum[x] + 1; if (l == r) return; lc[y] = lc[x]; rc[y] = rc[x]; int mid = (l + r) &gt;&gt; 1; if (v &lt;= mid) update(l, mid, lc[x], lc[y], v); else update(mid + 1, r, rc[x], rc[y], v);&#125;int que(int L, int R) &#123; int l = 1, r = a, mid, x, y, tmp = (R - L + 1) &gt;&gt; 1; x = rt[L - 1]; y = rt[R]; while (l != r) &#123; if (sum[y] - sum[x] &lt;= tmp) return 0; mid = (l + r) &gt;&gt; 1; if (sum[lc[y]] - sum[lc[x]] &gt; tmp) &#123; r = mid; x = lc[x]; y = lc[y]; &#125; else if (sum[rc[y]] - sum[rc[x]] &gt; tmp) &#123; l = mid + 1; x = rc[x]; y = rc[y]; &#125; else return 0; &#125; return l;&#125;int main() &#123;#ifdef D freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif scanf(&quot;%d %d&quot;, &amp;n, &amp;a); for (int i = 1; i &lt;= n; i++) &#123; int x; scanf(&quot;%d&quot;, &amp;x); update(1, a, rt[i - 1], rt[i], x); &#125; scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int l, r; scanf(&quot;%d %d&quot;, &amp;l, &amp;r); int ans = que(l, r); if (ans &gt; 0) &#123; printf(&quot;yes %d\n&quot;, ans); &#125; else printf(&quot;no\n&quot;); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1500][NOI2005]维修数列——splay]]></title>
      <url>%2F2017%2F03%2F03%2Fbzoj1500-NOI2005-%E7%BB%B4%E4%BF%AE%E6%95%B0%E5%88%97%E2%80%94%E2%80%94splay%2F</url>
      <content type="text"><![CDATA[题目 #题解 这道题可以说是数列问题的大BOSS，也算是这一周来学习splay等数据结构的一个总结。 我们一个一个地看这些操作。 对于操作1，我们首先建一棵子树，直接接上原树即可。 对于操作2，我们找到区间，不能直接取消连接关系，而是要一个一个的删除以回收空间。我们把已经删除的节点用一个栈保存起来。 对于操作3，我们找到区间，打标记即可。 对于操作4，同操作3。 对于操作5，我们找到区间，直接调用sum值即可。 对于操作6，我们对于每个节点对应的子树区间维护最大子段和，最大从左边开始的子段和，最大从右边开始的字段和，根据《算法竞赛入门经典——训练指南》P201。 我们设最大字段和为ma, 最大左字段和为la，右为ra，那么，我们可以YY一下合并方式。 \[x_{ma} = Max(Max(x_{left_{ma}}, x_{right_{ma}}), x_{left_{ra}}+x_data+Max(x_{right_{la}}, 0))\] \[x_{la} = Max(x_{left_{la}}, x_{left_{sum}}+x_{data}+x_{right_{la}})\] \[x_{ra} = Max(x_{right_{ra}}, x_{right_{sum}}+x_{data}+x_{left_{ra}})\] 这样，我们就完成了对于操作6的维护。 实现时要注意几个问题： 1. 一旦是从上往下走，就要pushdown。考虑到splay都会在find之后调用，那么我们就直接在find的过程中顺便pushdown即可。 2. 一旦是从下往上回溯，修改了子节点的值，就要update。 顺便一提的是，这道题没有卡int，非常的良心（看来2005年的出题人就是良心啊（逃 #代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#define l(x) ch[(x)][0]#define r(x) ch[(x)][1]#ifdef Dconst int maxn = 50;#elseconst int maxn = 500000 &lt;&lt; 1;#endifconst int inf = 0x3f3f3f;int ch[maxn][2], fa[maxn];int size[maxn], data[maxn], sum[maxn], la[maxn], ra[maxn], ma[maxn], cov[maxn], a[maxn];bool rev[maxn];int n, m, sz, rt;std::stack&lt;int&gt; st;void update(int x) &#123; if (!x) return; la[x] = std::max(la[l(x)], sum[l(x)] + data[x] + std::max(0, la[r(x)])); ra[x] = std::max(ra[r(x)], sum[r(x)] + data[x] + std::max(0, ra[l(x)])); ma[x] = std::max(std::max(ma[l(x)], ma[r(x)]), data[x] + std::max(0, ra[l(x)]) + std::max(0, la[r(x)])); sum[x] = sum[l(x)] + sum[r(x)] + data[x]; size[x] = size[l(x)] + size[r(x)] + 1;&#125;void reverse(int x) &#123; if (!x) return; std::swap(ch[x][0], ch[x][1]); std::swap(la[x], ra[x]); rev[x] ^= 1;&#125;void recover(int x, int v) &#123; if (!x) return; data[x] = cov[x] = v; sum[x] = size[x] * v; la[x] = ra[x] = ma[x] = std::max(v, sum[x]);&#125;void pushdown(int x) &#123; if (!x) return; if (rev[x]) &#123; reverse(ch[x][0]); reverse(ch[x][1]); rev[x] = 0; &#125; if (cov[x] != -inf) &#123; recover(ch[x][0], cov[x]); recover(ch[x][1], cov[x]); cov[x] = -inf; &#125;&#125;void zig(int x) &#123; int y = fa[x], z = fa[y], l = (ch[y][1] == x), r = l ^ 1; fa[ch[y][l] = ch[x][r]] = y; fa[ch[x][r] = y] = x; fa[x] = z; if (z) ch[z][ch[z][1] == y] = x; update(y); update(x);&#125;void splay(int x, int aim = 0) &#123; for (int y; (y = fa[x]) != aim; zig(x)) if (fa[y] != aim) zig((ch[fa[y]][0] == y) == (ch[y][0] == x) ? y : x); if (aim == 0) rt = x; update(x);&#125;int pick() &#123; if (!st.empty()) &#123; int x = st.top(); st.pop(); return x; &#125; else return ++sz;&#125;int setup(int x) &#123; int t = pick(); data[t] = a[x]; cov[t] = -inf; rev[t] = false; sum[t] = 0; la[t] = ra[t] = ma[t] = -inf; size[t] = 1; return t;&#125;int build(int l, int r) &#123; int mid = (l + r) &gt;&gt; 1, left = 0, right = 0; if (l &lt; mid) left = build(l, mid - 1); int t = setup(mid); if (r &gt; mid) right = build(mid + 1, r); if (left) &#123; ch[t][0] = left, fa[left] = t; &#125; else size[ch[t][0]] = 0; if (right) &#123; ch[t][1] = right, fa[right] = t; &#125; else size[ch[t][1]] = 0; update(t); return t;&#125;int find(int k) &#123; int x = rt, ans; while (x) &#123; pushdown(x); if (k == size[ch[x][0]] + 1) return ans = x; else if (k &gt; size[ch[x][0]] + 1) &#123; k -= size[ch[x][0]] + 1; x = ch[x][1]; &#125; else x = ch[x][0]; &#125; return -1;&#125;void del(int &amp;x) &#123; if (!x) return; st.push(x); fa[x] = 0; del(ch[x][0]); del(ch[x][1]); la[x] = ma[x] = ra[x] = -inf; x = 0;&#125;void print(int x) &#123; if (!x) return; if (ch[x][0]) print(ch[x][0]); std::cout &lt;&lt; data[x] &lt;&lt; ' '; if (ch[x][1]) print(ch[x][1]);&#125;int main() &#123;#ifdef D freopen("input", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;m); for (int i = 2; i &lt;= n + 1; i++) scanf("%d", &amp;a[i]); a[1] = a[n + 2] = 0; ra[0] = la[0] = ma[0] = -inf; rt = build(1, n + 2); char opt[20];#ifdef D// print(rt);#endif // return 0; while (m--) &#123; scanf("%s", opt); if (opt[0] == 'I') &#123; int pos, cnt; scanf("%d %d", &amp;pos, &amp;cnt); pos++; int l = find(pos); int r = find(pos + 1); splay(l); splay(r, rt); for (int i = 1; i &lt;= cnt; i++) scanf("%d", &amp;a[i]); int t = build(1, cnt); fa[t] = ch[rt][1]; ch[r][0] = t; update(l); update(r); &#125; if (opt[0] == 'D') &#123; int pos, cnt; scanf("%d %d", &amp;pos, &amp;cnt); pos++; int l = find(pos - 1); int r = find(pos + cnt); splay(l); splay(r, rt); del(ch[r][0]); update(l); update(r); &#125; if (opt[0] == 'M' &amp;&amp; opt[2] == 'K') &#123; int x, y, z; scanf("%d %d %d", &amp;x, &amp;y, &amp;z); x++; int l = find(x - 1); int r = find(x + y); splay(l); splay(r, rt); recover(ch[r][0], z); &#125; if (opt[0] == 'R') &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); x++; int l = find(x - 1); int r = find(x + y); splay(l); splay(r, rt); reverse(ch[r][0]); &#125; if (opt[0] == 'G') &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); x++; int l = find(x - 1); int r = find(x + y); splay(l); splay(r, rt); int ans = sum[ch[r][0]]; printf("%d\n", ans); &#125; if (opt[0] == 'M' &amp;&amp; opt[2] == 'X') &#123; int l, r, x = rt; while (ch[x][0]) x = ch[x][0]; l = x; x = rt; while (ch[x][1]) x = ch[x][1]; r = x; splay(l); splay(r, rt); int ans = ma[ch[r][0]]; printf("%d\n", ans); &#125;#ifdef D// print(rt);#endif &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1018][SHOI2008]堵塞的交通traffic——线段树]]></title>
      <url>%2F2017%2F03%2F02%2Fbzoj1018-SHOI2008-%E5%A0%B5%E5%A1%9E%E7%9A%84%E4%BA%A4%E9%80%9Atraffic%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
      <content type="text"><![CDATA[题目大意 给定一个2×n的矩形网格，你需要设计一种数据结构支持以下操作。 1. 连接两个相邻的网格。 2. 断开两个相邻网格的连接。 3. 查询两个网格的连通性。 最开始，所有网格之间均不连通。 # 题解 首先看到是图的连通性，我想到了并查集，但是由于题目需要删除操作，只好暂时作罢。 一般化地考虑原题。原题就是给定一个图，查连通性。看似和星球大战非常像。但是，这个题有一个特殊的特点： 它是一个2×n的矩形网格。 显然行的个数远远小于列的个数。我们考虑使用线段树，维护一个2×n的网格的四个顶点的连通性，使用一个结构体定义这种状态， a1[i][j]表示table[i][l]是否与table[i][r]连通，a2[i][j]表示左边或右边的两个节点的上下连通性。 我们考虑两个节点的合并。 显然，合并需要中间的状态。具体状态转移见代码。 # 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int maxn = 100010;struct status &#123; int a1[2][2]; int a2[2];&#125; s[maxn &lt;&lt; 2];bool b[maxn &lt;&lt; 2][2];int l[maxn &lt;&lt; 2], r[maxn &lt;&lt; 2], c;status update(status s1, status s2, bool b[]) &#123; status res; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 2; j++) &#123; res.a1[i][j] = (s1.a1[i][0] &amp;&amp; b[0] &amp;&amp; s2.a1[0][j]) || (s1.a1[i][1] &amp;&amp; b[1] &amp;&amp; s2.a1[1][j]); &#125; &#125; res.a2[0] = (s1.a2[0]) || (s1.a1[0][0] &amp;&amp; b[0] &amp;&amp; s2.a2[0] &amp;&amp; b[1] &amp;&amp; s1.a1[1][1]); res.a2[1] = (s2.a2[1]) || (s2.a1[0][0] &amp;&amp; b[0] &amp;&amp; s1.a2[1] &amp;&amp; b[1] &amp;&amp; s2.a1[1][1]); return res;&#125;status access(int k, int y1, int y2) &#123; int mid = (l[k] + r[k]) &gt;&gt; 1; if (y1 &lt;= l[k] &amp;&amp; r[k] &lt;= y2) return s[k]; else if (y2 &lt;= mid) return access(k &lt;&lt; 1, y1, y2); else if (y1 &gt; mid) return access(k &lt;&lt; 1 | 1, y1, y2); else return update(access(k &lt;&lt; 1, y1, y2), access(k &lt;&lt; 1 | 1, y1, y2), b[k]);&#125;void change(bool v, int k, int x1, int y1, int x2, int y2) &#123; int mid = (l[k] + r[k]) &gt;&gt; 1; if (x1 == x2 &amp;&amp; y1 == mid) &#123; b[k][x1] = v; s[k] = update(s[k &lt;&lt; 1], s[k &lt;&lt; 1 | 1], b[k]); &#125; else if (l[k] == r[k]) s[k].a1[0][1] = s[k].a1[1][0] = s[k].a2[0] = s[k].a2[1] = v; else &#123; change(v, y2 &lt;= mid ? k &lt;&lt; 1 : k &lt;&lt; 1 | 1, x1, y1, x2, y2); s[k] = update(s[k &lt;&lt; 1], s[k &lt;&lt; 1 | 1], b[k]); &#125;&#125;void ask(int x1, int y1, int x2, int y2) &#123; status left = access(1, 1, y1), right = access(1, y2, c), mid = access(1, y1, y2); bool res = false; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 2; j++) &#123; if (mid.a1[i][j] &amp;&amp; (i == x1 || left.a2[1]) &amp;&amp; (j == x2 || right.a2[0])) &#123; res = true; break; &#125; &#125; &#125; printf(res ? &quot;Y\n&quot; : &quot;N\n&quot;);&#125;void build(int k, int x, int y) &#123; l[k] = x; r[k] = y; if (x == y) &#123; s[k].a1[0][0] = s[k].a1[1][1] = 1; return; &#125; int mid = (x + y) &gt;&gt; 1; build(k &lt;&lt; 1, x, mid); build(k &lt;&lt; 1 | 1, mid + 1, y);&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;c); build(1, 1, c); while (1) &#123; char opt[10]; scanf(&quot;%s&quot;, opt); if (opt[0] == &apos;E&apos;) break; int x0, y0, x1, y1; scanf(&quot;%d %d %d %d&quot;, &amp;x0, &amp;y0, &amp;x1, &amp;y1); --x0, --x1; if (y0 &gt; y1) &#123; std::swap(x0, x1); std::swap(y0, y1); &#125; if (opt[0] == &apos;O&apos;) &#123; change(1, 1, x0, y0, x1, y1); &#125; else if (opt[0] == &apos;C&apos;) &#123; change(0, 1, x0, y0, x1, y1); &#125; else ask(x0, y0, x1, y1); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3165][Heoi2013]Segment——李超线段树]]></title>
      <url>%2F2017%2F03%2F02%2Fbzoj3165-Heoi2013-Segment%E2%80%94%E2%80%94%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
      <content type="text"><![CDATA[题目大意 要求在平面直角坐标系下维护两个操作： 1.在平面上加入一条线段。记第i条被插入的线段的标号为i。 2.给定一个数k,询问与直线 x = k相交的线段中，交点最靠上的线段的编号。 # 题解 和上一个题几乎一样。 # 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;int read() &#123; int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') f = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; return x * f;&#125;int N, M;struct line &#123; double k, b; int id; line(int x0 = 0, int y0 = 0, int x1 = 0, int y1 = 0, int ID = 0) &#123; id = ID; if (x0 == x1) k = 0, b = std::max(y0, y1); else k = (double)(y0 - y1) / (x0 - x1), b = (double)y0 - k * x0; &#125; double getf(int x) &#123; return k * x + b; &#125;;&#125;;bool cmp(line a, line b, int x) &#123; if (!a.id) return 1; return a.getf(x) != b.getf(x) ? a.getf(x) &lt; b.getf(x) : a.id &lt; b.id;&#125;const int maxn = 50010;line t[maxn &lt;&lt; 2];line query(int k, int l, int r, int x) &#123; if (l == r) return t[k]; int mid = (l + r) &gt;&gt; 1; line tmp; if (x &lt;= mid) tmp = query(k &lt;&lt; 1, l, mid, x); else tmp = query(k &lt;&lt; 1 | 1, mid + 1, r, x); return cmp(t[k], tmp, x) ? tmp : t[k];&#125;void insert(int k, int l, int r, line x) &#123; if (!t[k].id) t[k] = x; if (cmp(t[k], x, l)) std::swap(t[k], x); if (l == r || t[k].k == x.k) return; int mid = (l + r) &gt;&gt; 1; double X = (t[k].b - x.b) / (x.k - t[k].k); if (X &lt; l || X &gt; r) return; if (X &lt;= mid) insert(k &lt;&lt; 1, l, mid, t[k]), t[k] = x; else insert(k &lt;&lt; 1 | 1, mid + 1, r, x);&#125;void Insert(int k, int l, int r, int x, int y, line v) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; insert(k, l, r, v); return; &#125; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) Insert(k &lt;&lt; 1, l, mid, x, y, v); if (y &gt; mid) Insert(k &lt;&lt; 1 | 1, mid + 1, r, x, y, v);&#125;#define p1 39989#define p2 1000000000int main() &#123;#ifdef D freopen("input", "r", stdin);#endif M = read(); N = 50000; int las, cnt = 0; while (M--) &#123; int opt = read(); if (opt == 0) &#123; int x = read(); x = (x + las - 1) % p1 + 1; las = query(1, 1, N, x).id; printf("%d\n", las); &#125; if (opt == 1) &#123; int x0 = read(), y0 = read(), x1 = read(), y1 = read(); x0 = (x0 + las - 1) % p1 + 1; y0 = (y0 + las - 1) % p2 + 1; x1 = (x1 + las - 1) % p1 + 1; y1 = (y1 + las - 1) % p2 + 1; if (x0 &gt; x1) std::swap(x0, x1), std::swap(y0, y1); Insert(1, 1, N, x0, x1, line(x0, y0, x1, y1, ++cnt)); &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1568][JSOI2008]Blue Mary开公司——李超线段树]]></title>
      <url>%2F2017%2F03%2F02%2Fbzoj1568-JSOI2008-Blue-Mary%E5%BC%80%E5%85%AC%E5%8F%B8%E2%80%94%E2%80%94%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
      <content type="text"><![CDATA[题目大意 #题解 这道题需要用到一种叫做李超线段树的东西。我对于李超线段树，是这样理解的： 给节点打下的标记不进行下传，而是仅仅在需要的时候进行下传，这就是所谓永久化标记。 对于这道题，借用一张图， 这张图解释的比较清楚了。 #代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;int read() &#123; int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == &apos;-&apos;) f = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + ch - &apos;0&apos;; ch = getchar(); &#125; return x * f;&#125;int N, M;struct line &#123; double k, b; int id; double getf(int x) &#123; return k * x + b; &#125;;&#125;;bool cmp(line a, line b, int x) &#123; if (!a.id) return 1; return a.getf(x) != b.getf(x) ? a.getf(x) &lt; b.getf(x) : a.id &lt; b.id;&#125;const int maxn = 50010;line t[maxn &lt;&lt; 2];line query(int k, int l, int r, int x) &#123; if (l == r) return t[k]; int mid = (l + r) &gt;&gt; 1; line tmp; if (x &lt;= mid) tmp = query(k &lt;&lt; 1, l, mid, x); else tmp = query(k &lt;&lt; 1 | 1, mid + 1, r, x); return cmp(t[k], tmp, x) ? tmp : t[k];&#125;void insert(int k, int l, int r, line x) &#123; if (!t[k].id) t[k] = x; if (cmp(t[k], x, l)) std::swap(t[k], x); if (l == r || t[k].k == x.k) return; int mid = (l + r) &gt;&gt; 1; double X = (t[k].b - x.b) / (x.k - t[k].k); if (X &lt; l || X &gt; r) return; if (X &lt;= mid) insert(k &lt;&lt; 1, l, mid, t[k]), t[k] = x; else insert(k &lt;&lt; 1 | 1, mid + 1, r, x);&#125;void Insert(int k, int l, int r, int x, int y, line v) &#123; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; insert(k, l, r, v); return; &#125; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) Insert(k &lt;&lt; 1, l, mid, x, y, v); if (y &gt; mid) Insert(k &lt;&lt; 1 | 1, mid + 1, r, x, y, v);&#125;int main() &#123;#ifdef D freopen(&quot;input&quot;, &quot;r&quot;, stdin);#endif M = read(); N = 50000; char opt[15]; while (M--) &#123; scanf(&quot;%s&quot;, opt); if (opt[0] == &apos;P&apos;) &#123; double k, b; scanf(&quot;%lf %lf&quot;, &amp;k, &amp;b); line tmp; tmp.k = b; tmp.b = k - b; tmp.id = 1; Insert(1, 1, N, 1, N, tmp); &#125; int x; if (opt[0] == &apos;Q&apos;) &#123; x = read(); printf(&quot;%lld\n&quot;, (long long)(query(1, 1, N, x).getf(x) / 100 + 1e-8)); &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3196]Tyvj 1730 二逼平衡树——线段树套平衡树]]></title>
      <url>%2F2017%2F03%2F01%2Fbzoj3196-Tyvj-1730-%E4%BA%8C%E9%80%BC%E5%B9%B3%E8%A1%A1%E6%A0%91%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A5%97%E5%B9%B3%E8%A1%A1%E6%A0%91%2F</url>
      <content type="text"><![CDATA[题目 Description 您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作： 1.查询k在区间内的排名 2.查询区间内排名为k的值 3.修改某一位值上的数值 4.查询k在区间内的前驱(前驱定义为小于x，且最大的数) 5.查询k在区间内的后继(后继定义为大于x，且最小的数) Input 第一行两个数 n,m 表示长度为n的有序序列和m个操作 第二行有n个数，表示有序序列 下面有m行，opt表示操作标号 若opt=1 则为操作1，之后有三个数l,r,k 表示查询k在区间[l,r]的排名 若opt=2 则为操作2，之后有三个数l,r,k 表示查询区间[l,r]内排名为k的数 若opt=3 则为操作3，之后有两个数pos,k 表示将pos位置的数修改为k 若opt=4 则为操作4，之后有三个数l,r,k 表示查询区间[l,r]内k的前驱 若opt=5 则为操作5，之后有三个数l,r,k 表示查询区间[l,r]内k的后继 Output 对于操作1,2,4,5各输出一行，表示查询结果 # 题解 树套树模板题。 对于每一个线段树上的节点，我们都在上面建一个平衡树。 对于操作1，我们把一个长度为len的区间分解为\(\lfloor log_2(len) \rfloor\)个子区间，分别处理，把每个区间的排名加起来就好了。 对于操作2，我们二分答案，对于二分出来的一个答案执行操作1，check以下即可。 对于操作3，我们删除再插入。 对于操作4和操作5，我们把每个区间（前驱/后继）的（最大值/最小值）搞一搞就好啦。 PS.谁能告诉我bzoj上那些2000ms的是怎么做的。。。 # 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 4e6 + 5;const int inf = 1e9;int ans, n, m, opt, l, r, k, pos, sz, Max;int a[maxn], fa[maxn], ch[maxn][2], size[maxn], cnt[maxn], data[maxn], rt[maxn];inline int read() &#123; int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') f = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; return x * f;&#125;struct Splay &#123; void clear(int x) &#123; fa[x] = ch[x][0] = ch[x][1] = size[x] = cnt[x] = data[x] = 0; &#125; void update(int x) &#123; if (x) &#123; size[x] = cnt[x]; if (ch[x][0]) size[x] += size[ch[x][0]]; if (ch[x][1]) size[x] += size[ch[x][1]]; &#125; &#125; void zig(int x) &#123; int y = fa[x], z = fa[y], l = (ch[y][1] == x), r = l ^ 1; fa[ch[y][l] = ch[x][r]] = y; fa[ch[x][r] = y] = x; fa[x] = z; if (z) ch[z][ch[z][1] == y] = x; update(y); update(x); &#125; void splay(int i, int x, int aim = 0) &#123; for (int y; (y = fa[x]) != aim; zig(x)) if (fa[y] != aim) zig((ch[fa[y]][0] == y) == (ch[y][0] == x) ? y : x); if (aim == 0) rt[i] = x; &#125; void insert(int i, int v) &#123; int x = rt[i], y = 0; if (x == 0) &#123; rt[i] = x = ++sz; fa[x] = ch[x][0] = ch[x][1] = 0; size[x] = cnt[x] = 1; data[x] = v; return; &#125; while (1) &#123; if (data[x] == v) &#123; cnt[x]++; update(y); splay(i, x); return; &#125; y = x; x = ch[x][v &gt; data[x]]; if (x == 0) &#123; ++sz; fa[sz] = y; ch[sz][0] = ch[sz][1] = 0; size[sz] = cnt[sz] = 1; data[sz] = v; ch[y][v &gt; data[y]] = sz; update(y); splay(i, sz); rt[i] = sz; return; &#125; &#125; &#125; void find(int i, int v) &#123; int x = rt[i]; while (1) &#123; if (data[x] == v) &#123; splay(i, x); return; &#125; else x = ch[x][v &gt; data[x]]; &#125; &#125; int pre(int i) &#123; int x = ch[rt[i]][0]; while (ch[x][1]) x = ch[x][1]; return x; &#125; int succ(int i) &#123; int x = ch[rt[i]][1]; while (ch[x][0]) x = ch[x][0]; return x; &#125; void del(int i) &#123; int x = rt[i]; if (cnt[x] &gt; 1) &#123; cnt[x]--; return; &#125; if (!ch[x][0] &amp;&amp; !ch[x][1]) &#123; clear(rt[i]); rt[i] = 0; return; &#125; if (!ch[x][0]) &#123; int oldroot = x; rt[i] = ch[x][1]; fa[rt[i]] = 0; clear(oldroot); return; &#125; if (!ch[x][1]) &#123; int oldroot = x; rt[i] = ch[x][0]; fa[rt[i]] = 0; clear(oldroot); return; &#125; int y = pre(i), oldroot = x; splay(i, y); rt[i] = y; ch[rt[i]][1] = ch[oldroot][1]; fa[ch[oldroot][1]] = rt[i]; clear(oldroot); update(rt[i]); return; &#125; int rank(int i, int v) &#123; int x = rt[i], ans = 0; while (1) &#123; if (!x) return ans; if (data[x] == v) return ((ch[x][0]) ? size[ch[x][0]] : 0) + ans; else if (data[x] &lt; v) &#123; ans += ((ch[x][0]) ? size[ch[x][0]] : 0) + cnt[x]; x = ch[x][1]; &#125; else if (data[x] &gt; v) &#123; x = ch[x][0]; &#125; &#125; &#125; int find_pre(int i, int v) &#123; int x = rt[i]; while (x) &#123; if (data[x] &lt; v) &#123; if (ans &lt; data[x]) ans = data[x]; x = ch[x][1]; &#125; else x = ch[x][0]; &#125; return ans; &#125; int find_succ(int i, int v) &#123; int x = rt[i]; while (x) &#123; if (v &lt; data[x]) &#123; if (ans &gt; data[x]) ans = data[x]; x = ch[x][0]; &#125; else x = ch[x][1]; &#125; return ans; &#125;&#125; sp;void insert(int k, int l, int r, int x, int v) &#123; int mid = (l + r) &gt;&gt; 1; sp.insert(k, v); if (l == r) return; if (x &lt;= mid) insert(k &lt;&lt; 1, l, mid, x, v); else insert(k &lt;&lt; 1 | 1, mid + 1, r, x, v);&#125;void askrank(int k, int l, int r, int x, int y, int val) &#123; int mid = (l + r) &gt;&gt; 1; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; ans += sp.rank(k, val); return; &#125; if (x &lt;= mid) askrank(k &lt;&lt; 1, l, mid, x, y, val); if (mid + 1 &lt;= y) askrank(k &lt;&lt; 1 | 1, mid + 1, r, x, y, val);&#125;void change(int k, int l, int r, int pos, int val) &#123; int mid = (l + r) &gt;&gt; 1; sp.find(k, a[pos]); sp.del(k); sp.insert(k, val); if (l == r) return; if (pos &lt;= mid) change(k &lt;&lt; 1, l, mid, pos, val); else change(k &lt;&lt; 1 | 1, mid + 1, r, pos, val);&#125;void askpre(int k, int l, int r, int x, int y, int val) &#123; int mid = (l + r) &gt;&gt; 1; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; ans = max(ans, sp.find_pre(k, val)); return; &#125; if (x &lt;= mid) askpre(k &lt;&lt; 1, l, mid, x, y, val); if (mid + 1 &lt;= y) askpre(k &lt;&lt; 1 | 1, mid + 1, r, x, y, val);&#125;void asksucc(int k, int l, int r, int x, int y, int val) &#123; int mid = (l + r) &gt;&gt; 1; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; ans = min(ans, sp.find_succ(k, val)); return; &#125; if (x &lt;= mid) asksucc(k &lt;&lt; 1, l, mid, x, y, val); if (mid + 1 &lt;= y) asksucc(k &lt;&lt; 1 | 1, mid + 1, r, x, y, val);&#125;int main() &#123;#ifdef D freopen("input", "r", stdin);#endif n = read(), m = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(), Max = max(Max, a[i]), insert(1, 1, n, i, a[i]); for (int i = 1; i &lt;= m; i++) &#123; opt = read(); if (opt == 1) &#123; l = read(), r = read(), k = read(); ans = 0; askrank(1, 1, n, l, r, k); printf("%d\n", ans + 1); &#125; else if (opt == 2) &#123; l = read(), r = read(), k = read(); int head = 0, tail = Max + 1; while (head != tail) &#123; int mid = (head + tail) &gt;&gt; 1; ans = 0; askrank(1, 1, n, l, r, mid); if (ans &lt; k) head = mid + 1; else tail = mid; &#125; printf("%d\n", head - 1); &#125; else if (opt == 3) &#123; pos = read(); k = read(); change(1, 1, n, pos, k); a[pos] = k; Max = std::max(Max, k); &#125; else if (opt == 4) &#123; l = read(); r = read(); k = read(); ans = 0; askpre(1, 1, n, l, r, k); printf("%d\n", ans); &#125; else if (opt == 5) &#123; l = read(); r = read(); k = read(); ans = inf; asksucc(1, 1, n, l, r, k); printf("%d\n", ans); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1251]序列终结者——splay]]></title>
      <url>%2F2017%2F03%2F01%2Fbzoj1251-%E5%BA%8F%E5%88%97%E7%BB%88%E7%BB%93%E8%80%85%E2%80%94%E2%80%94splay%2F</url>
      <content type="text"><![CDATA[题目大意 网上有许多题，就是给定一个序列，要你支持几种操作：A、B、C、D。一看另一道题，又是一个序列 要支持几种操作：D、C、B、A。尤其是我们这里的某人，出模拟试题，居然还出了一道这样的，真是没技术含量……这样 我也出一道题，我出这一道的目的是为了让大家以后做这种题目有一个“库”可以依靠，没有什么其他的意思。这道题目 就叫序列终结者吧。 【问题描述】 给定一个长度为N的序列，每个序列的元素是一个整数（废话）。要支持以下三种操作： 1. 将[L,R]这个区间内的所有数加上V。 2. 将[L,R]这个区间翻转，比如1 2 3 4变成4 3 2 1。 3. 求[L,R]这个区间中的最大值。 最开始所有元素都是0。 Input 第一行两个整数N，M。M为操作个数。 以下M行，每行最多四个整数，依次为K，L，R，V。K表示是第几种操作，如果不是第1种操作则K后面只有两个数。 Output 对于每个第3种操作，给出正确的回答。 #题解 首先，终于做完splay的5道模板题了。 说一下这个题怎么做。 我们沿用线段树中的lazy标记，给每个节点打两个标记，一旦在find中访问到这个节点，立即pushdown，同时及时update。 然后就是splay的经典操作了。 这个题调了很长时间，所以，以后一定要先静态调试，避免SB错误和理清逻辑后，再用gdb动态调试。 #代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#ifdef Dconst int maxn = 100;#elseconst int maxn = 100000;#endifint data[maxn], fa[maxn], ch[maxn][2], rev[maxn], mx[maxn], pls[maxn], size[maxn];int n, m, sz = 0, rt = 0;void update(int x) &#123; mx[x] = data[x]; if (ch[x][0] != -1) mx[x] = std::max(mx[x], mx[ch[x][0]]); if (ch[x][1] != -1) mx[x] = std::max(mx[x], mx[ch[x][1]]); size[x] = 1; if (ch[x][0] != -1) size[x] += size[ch[x][0]]; if (ch[x][1] != -1) size[x] += size[ch[x][1]];&#125;void pushdown(int k) &#123; int &amp;l = ch[k][0], &amp;r = ch[k][1], t = pls[k]; if (t) &#123; pls[k] = 0; if (l != -1) &#123; pls[l] += t; mx[l] += t; data[l] += t; &#125; if (r != -1) &#123; pls[r] += t; mx[r] += t; data[r] += t; &#125; &#125; if (rev[k]) &#123; rev[k] = 0; rev[l] ^= 1; rev[r] ^= 1; std::swap(ch[k][0], ch[k][1]); &#125;&#125;void zig(int x) &#123; int y = fa[x], z = fa[y], l = (ch[y][1] == x), r = l ^ 1; fa[ch[y][l] = ch[x][r]] = y; fa[ch[x][r] = y] = x; fa[x] = z; if (z != -1) &#123; ch[z][ch[z][1] == y] = x; &#125; update(y); update(x);&#125;void splay(int x, int aim = -1) &#123; for (int y; (y = fa[x]) != aim; zig(x)) if (fa[y] != aim) zig((ch[fa[y]][0] == y) == (ch[y][0] == x) ? y : x); if (aim == -1) rt = x;&#125;int find(int k, int rank) &#123; if (pls[k] || rev[k]) pushdown(k); int l = ch[k][0], r = ch[k][1]; if (size[l] + 1 == rank) return k; else if (size[l] &gt;= rank) return find(l, rank); else return find(r, rank - size[l] - 1);&#125;void build(int l, int r, int last) &#123; if (l &gt; r) return; int now = l; if (l == r) &#123; size[now] = 1; fa[now] = last; data[now] = rev[now] = mx[now] = 0; if (l &lt; last) ch[last][0] = now; else ch[last][1] = now; return; &#125; int mid = (l + r) &gt;&gt; 1; now = mid; build(l, mid - 1, mid); build(mid + 1, r, mid); fa[now] = last; update(now); if (mid &lt; last) &#123; ch[last][0] = now; &#125; else ch[last][1] = now; return;&#125;void rv(int l, int r) &#123; int x = find(rt, l), y = find(rt, r + 2); splay(x); splay(y, rt); int z = ch[y][0]; rev[z] ^= 1;&#125;void ps(int l, int r, int v) &#123; int x = find(rt, l), y = find(rt, r + 2); splay(x); splay(y, rt); int z = ch[y][0]; pls[z] += v; data[z] += v; mx[z] += v;&#125;int Max(int l, int r) &#123; int x = find(rt, l), y = find(rt, r + 2); splay(x); splay(y, rt); int z = ch[y][0]; return mx[z];&#125;int main() &#123;#ifdef D freopen("input", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;m); memset(ch, -1, sizeof(ch)); memset(rev, 0, sizeof(rev)); memset(pls, 0, sizeof(pls)); memset(fa, 0, sizeof(fa)); build(0, n + 1, -1); rt = (n + 1) &gt;&gt; 1; for (int i = 1; i &lt;= m; i++) &#123; int k; scanf("%d", &amp;k); if (k == 1) &#123; int l, r, v; scanf("%d %d %d", &amp;l, &amp;r, &amp;v); ps(l, r, v); &#125; if (k == 2) &#123; int l, r; scanf("%d %d", &amp;l, &amp;r); rv(l, r); &#125; if (k == 3) &#123; int l, r; scanf("%d %d", &amp;l, &amp;r); int ans = Max(l, r); printf("%d\n", ans); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1208][HNOI2004]宠物收养所——splay]]></title>
      <url>%2F2017%2F03%2F01%2Fbzoj1208-HNOI2004-%E5%AE%A0%E7%89%A9%E6%94%B6%E5%85%BB%E6%89%80%E2%80%94%E2%80%94splay%2F</url>
      <content type="text"><![CDATA[题目大意 Description 最近，阿Q开了一间宠物收养所。收养所提供两种服务：收养被主人遗弃的宠物和让新的主人领养这些宠物。每个领养者都希望领养到自己满意的宠物，阿Q根据领养者的要求通过他自己发明的一个特殊的公式，得出该领养者希望领养的宠物的特点值a（a是一个正整数，a&lt;2^31），而他也给每个处在收养所的宠物一个特点值。这样他就能够很方便的处理整个领养宠物的过程了，宠物收养所总是会有两种情况发生：被遗弃的宠物过多或者是想要收养宠物的人太多，而宠物太少。 1． 被遗弃的宠物过多时，假若到来一个领养者，这个领养者希望领养的宠物的特点值为a，那么它将会领养一只目前未被领养的宠物中特点值最接近a的一只宠物。（任何两只宠物的特点值都不可能是相同的，任何两个领养者的希望领养宠物的特点值也不可能是一样的）如果有两只满足要求的宠物，即存在两只宠物他们的特点值分别为a-b和a+b，那么领养者将会领养特点值为a-b的那只宠物。 2． 收养宠物的人过多，假若到来一只被收养的宠物，那么哪个领养者能够领养它呢？能够领养它的领养者，是那个希望被领养宠物的特点值最接近该宠物特点值的领养者，如果该宠物的特点值为a，存在两个领养者他们希望领养宠物的特点值分别为a-b和a+b，那么特点值为a-b的那个领养者将成功领养该宠物。 一个领养者领养了一个特点值为a的宠物，而它本身希望领养的宠物的特点值为b，那么这个领养者的不满意程度为abs(a-b)。【任务描述】你得到了一年当中，领养者和被收养宠物到来收养所的情况，希望你计算所有收养了宠物的领养者的不满意程度的总和。这一年初始时，收养所里面既没有宠物，也没有领养者。 Input 第一行为一个正整数n，n&lt;=80000，表示一年当中来到收养所的宠物和领养者的总数。接下来的n行，按到来时间的先后顺序描述了一年当中来到收养所的宠物和领养者的情况。每行有两个正整数a, b，其中a=0表示宠物，a=1表示领养者，b表示宠物的特点值或是领养者希望领养宠物的特点值。（同一时间呆在收养所中的，要么全是宠物，要么全是领养者，这些宠物和领养者的个数不会超过10000个） Output 仅有一个正整数，表示一年当中所有收养了宠物的领养者的不满意程度的总和mod 1000000以后的结果。 #题解 显然可以用splay维护信息。我比较蠢，开了两个splay。 #注意的地方 1. 还是模板不熟，在del时候忘记更改fa的拓扑结构，导致一直tle。 2. 被mod坑了。明明我模的比较多，却一直WA，黄学长mod的很少，却过了Orz。 以后要注意减法的mod。能不mod就不要mod。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;cstdio&gt;#include &lt;cstdlib&gt;const int maxn = 160000;const int mod = 1000000;int data[maxn], fa[maxn], ch[maxn][2];int sz[3], rt1 = 0, rt2 = 0; // splay1:pets||splay2:menint n, a, b, ans = 0;void zig(int x) &#123; int y = fa[x], z = fa[y], l = (ch[y][1] == x), r = l ^ 1; fa[ch[y][l] = ch[x][r]] = y; fa[ch[x][r] = y] = x; fa[x] = z; if (z) ch[z][ch[z][1] == y] = x;&#125;void splay(int x, int aim, int &amp;rt) &#123; for (int y; (y = fa[x]) != aim; zig(x)) &#123; if (fa[y] != aim) zig((ch[fa[y]][0] == y) == (ch[y][0] == x) ? y : x); &#125; if (aim == 0) rt = x;&#125;void insert(int v, int &amp;rt, int arg) &#123; int x = rt; if (rt == 0) &#123; rt = x = ++sz[arg]; data[x] = v; fa[x] = ch[x][0] = ch[x][1] = 0; return; &#125; while (x) &#123; if (data[x] == v) return; int &amp;y = ch[x][v &gt; data[x]]; if (y == 0) &#123; y = ++sz[arg]; data[y] = v; fa[y] = x; ch[y][0] = ch[y][1] = 0; x = y; break; &#125; x = y; &#125; splay(x, 0, rt);&#125;int pre(int v, int &amp;rt) &#123; int x = rt; int y = -1; while (x) &#123; if (v &gt;= data[x]) &#123; y = x; x = ch[x][1]; &#125; else x = ch[x][0]; &#125; return y;&#125;int succ(int v, int &amp;rt) &#123; int x = rt; int y = -1; while (x) &#123; if (v &lt;= data[x]) &#123; y = x; x = ch[x][0]; &#125; else x = ch[x][1]; &#125; return y;&#125;void del(int x, int &amp;rt) &#123; splay(x, 0, rt); int y = ch[x][0]; while (ch[y][1]) y = ch[y][1]; if (y == 0) &#123; rt = ch[x][1]; fa[ch[x][1]] = 0; return; &#125; splay(y, x, rt); ch[y][1] = ch[x][1]; rt = y; fa[y] = 0; fa[ch[x][1]] = rt; return;&#125;int main() &#123;#ifdef D freopen("input", "r", stdin);#endif sz[1] = 0; sz[2] = 80000; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d %d", &amp;a, &amp;b); if (a == 0) &#123; if (rt1 == 0) &#123; // splay is empty insert(b, rt2, 2); &#125; else &#123; int x = pre(b, rt1); int y = succ(b, rt1); if (x != -1 &amp;&amp; y != -1 &amp;&amp; (b - data[x]) &lt;= (data[y] - b)) &#123; del(x, rt1); ans += b - data[x]; ans %= mod; &#125; else if (y != -1) &#123; del(y, rt1); ans += data[y] - b; ans %= mod; &#125; else if (x != -1 &amp;&amp; y == -1) &#123; del(x, rt1); ans += b - data[x]; ans %= mod; &#125; else if (x == -1 &amp;&amp; y != -1) &#123; del(y, rt1); ans += data[y] - b; ans %= mod; &#125; &#125; &#125; if (a == 1) &#123; if (rt2 == 0) &#123; // splay is empty insert(b, rt1, 1); &#125; else &#123; int x = pre(b, rt2); int y = succ(b, rt2); if (x != -1 &amp;&amp; y != -1 &amp;&amp; (b - data[x]) &lt;= (data[y] - b)) &#123; del(x, rt2); ans += b - data[x]; ans %= mod; &#125; else if (x != -1 &amp;&amp; y != -1) &#123; del(y, rt2); ans += data[y] - b; ans %= mod; &#125; else if (x != -1 &amp;&amp; y == -1) &#123; del(x, rt2); ans += b - data[x]; ans %= mod; &#125; else if (x == -1 &amp;&amp; y != -1) &#123; del(y, rt2); ans += data[y] - b; ans %= mod; &#125; &#125; &#125; &#125; printf("%d\n", ans);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1503][NOI2004]郁闷的出纳员——splay]]></title>
      <url>%2F2017%2F02%2F28%2Fbzoj1503-NOI2004-%E9%83%81%E9%97%B7%E7%9A%84%E5%87%BA%E7%BA%B3%E5%91%98%E2%80%94%E2%80%94splay%2F</url>
      <content type="text"><![CDATA[题意 你被要求编写一个数据结构，支援以下操作： 1. 插入一个数 2. 所有数同时加一个数 3. 所有数同时减一个数，同时如果有数小于一个值，那么这个数应该被删除。 4. 查找第k大数 5. 统计被删除的数的总数 题解 看到有插入，有删除，加减还都很方便，自然地想到使用平衡树实现。 我选用了splay。 对于第一个操作和第四个操作，非常简单不再多说。 对于第二个操作，我们采用和线段树类似的做法，打一个lazy标记，考虑到加减没有优先级，随便搞一搞就可以。 对于第三个操作，我们仍然先打lazy标记，然后我们在树中查找min的后继节点，把他splay到根，断掉他的左子树就可以了。 注意 元素的重复。 pushdown函数虽然简单但是要反复检查。 注意边界情况与特判 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;cctype&gt;#include &lt;cstdio&gt;const int maxn = 100010;int ch[maxn][2], data[maxn], fa[maxn], cnt[maxn], size[maxn], ad[maxn], dc[maxn];int sz = 0, rt = 0;int n, m, total = 0;void update(int x) &#123; size[x] = size[ch[x][0]] + size[ch[x][1]] + cnt[x]; &#125;void pushdown(int x) &#123; if (ad[x] != 0 || dc[x] != 0) &#123; int l = ch[x][0], r = ch[x][1]; if (l == 0 &amp;&amp; r == 0) &#123; data[x] += ad[x]; data[x] -= dc[x]; ad[x] = 0; dc[x] = 0; return; &#125; if (l != 0) &#123; ad[l] += ad[x]; dc[l] += dc[x]; &#125; if (r != 0) &#123; ad[r] += ad[x]; dc[r] += dc[x]; &#125; data[x] += ad[x]; data[x] -= dc[x]; ad[x] = dc[x] = 0; return; &#125;&#125;void zig(int x) &#123; pushdown(x); int y = fa[x], z = fa[y], l = (ch[y][1] == x), r = l ^ 1; fa[ch[y][l] = ch[x][r]] = y; fa[ch[x][r] = y] = x; fa[x] = z; ch[z][ch[z][1] == y] = x; update(y);&#125;void splay(int x, int aim = 0) &#123; for (int y; (y = fa[x]) != aim; zig(x)) if (fa[y] != aim) zig((((ch[y][0] == x) == (ch[fa[y]][0] == y))) ? y : x); if (aim == 0) rt = x; update(x);&#125;void insert(int v) &#123; int x = rt; if (rt == 0) &#123; rt = x = ++sz; data[x] = v; cnt[x] = size[x] = 1; fa[x] = ch[x][0] = ch[x][1] = 0; return; &#125; while (x) &#123; size[x]++; pushdown(x); if (v == data[x]) &#123; cnt[x]++; return; &#125; int &amp;y = ch[x][v &gt; data[x]]; if (y == 0) &#123; y = ++sz; data[y] = v; size[y] = cnt[y] = 1; fa[y] = x; ch[y][0] = ch[y][1] = 0; ch[x][v &gt; data[x]] = y; x = y; break; &#125; x = y; &#125; splay(x);&#125;void add(int x) &#123; pushdown(rt); ad[rt] = x;&#125;void dec(int x) &#123; pushdown(rt); dc[rt] = x;&#125;void fire() &#123; int x = rt; int y = -1; while (x) &#123; pushdown(x); if (data[x] &lt; m) &#123; x = ch[x][1]; &#125; else &#123; y = x; x = ch[x][0]; &#125; &#125; if (y == -1) &#123; total += size[rt]; rt = 0; return; &#125; splay(y); total += size[ch[rt][0]]; ch[rt][0] = 0; update(rt);&#125;int kth(int v) &#123; if (v &gt; size[rt]) return -1; int x = rt; while (x) &#123; pushdown(x); if (v &gt;= size[ch[x][1]] + 1 &amp;&amp; v &lt;= size[ch[x][1]] + cnt[x]) return data[x]; if (v &gt; size[ch[x][1]] + cnt[x]) &#123; v -= size[ch[x][1]] + cnt[x]; x = ch[x][0]; &#125; else x = ch[x][1]; &#125;&#125;int main() &#123;#ifdef D freopen("input", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; char opt = getchar(); while (!isalpha(opt)) opt = getchar(); ; if (opt == 'I') &#123; int x; scanf("%d", &amp;x); if (x &gt;= m) insert(x); &#125; else if (opt == 'A') &#123; int x; scanf("%d", &amp;x); add(x); &#125; else if (opt == 'S') &#123; int x; scanf("%d", &amp;x); dec(x); fire(); &#125; else if (opt == 'F') &#123; int x; scanf("%d", &amp;x); printf("%d\n", kth(x)); &#125; &#125; printf("%d\n", total);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1588][HNOI2002]营业额统计——splay]]></title>
      <url>%2F2017%2F02%2F28%2Fbzoj1588-HNOI2002-%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1%E2%80%94%E2%80%94splay%2F</url>
      <content type="text"><![CDATA[题目大意 你被要求编写一个数据结构，支援以下操作，操作在线。 1. 插入一个元素 2. 查询一个元素与之前插入元素的最小差值。 题解 一道模板题。我是写了一个pre和succ函数水过的。1A，比较高兴。 # 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int maxn = 40000;int ch[maxn][2], fa[maxn], data[maxn], cnt[maxn], rt, sz, size[maxn];void update(int k) &#123; size[k] = size[ch[k][0]] + size[ch[k][1]] + cnt[k]; &#125;void zig(int x) &#123; int y = fa[x], z = fa[y], l = (ch[y][1] == x), r = l ^ 1; fa[ch[y][l] = ch[x][r]] = y; fa[ch[x][r] = y] = x; fa[x] = z; if (z) ch[z][ch[z][1] == y] = x; update(y);&#125;void splay(int x, int aim = 0) &#123; for (int y; (y = fa[x]) != aim; zig(x)) if (fa[y] != aim) zig((ch[y][0] == x) == (ch[fa[y]][0] == x) ? y : x); if (aim == 0) rt = x; update(x);&#125;void insert(int v) &#123; int x = rt; if (rt == 0) &#123; rt = x = ++sz; data[x] = v; size[x] = cnt[x] = 1; fa[x] = ch[x][0] = ch[x][1] = 0; return; &#125; while (x) &#123; size[x]++; if (v == data[x]) &#123; cnt[x]++; return; &#125; int &amp;y = ch[x][v &gt;= data[x]]; if (y == 0) &#123; y = ++sz; data[y] = v; size[y] = cnt[y] = 1; fa[y] = x; ch[y][0] = ch[y][1] = 0; x = y; break; &#125; x = y; &#125; splay(x);&#125;int pre(int v) &#123; int ans = -1; for (int y = rt; y;) &#123; if (data[y] &lt;= v) ans = data[y], y = ch[y][1]; else y = ch[y][0]; &#125; return ans;&#125;int succ(int v) &#123; int ans = -1; for (int y = rt; y;) &#123; if (data[y] &gt;= v) ans = data[y], y = ch[y][0]; else y = ch[y][1]; &#125; return ans;&#125;int main() &#123;#ifdef D freopen("input", "r", stdin);#endif int ans = 0; int n, x; rt = 0; scanf("%d %d", &amp;n, &amp;x); insert(x); ans += x; for (int i = 2; i &lt;= n; i++) &#123; scanf("%d", &amp;x); int ret = 0x3f3f3f; int y = pre(x); if (y != -1) ret = std::min(ret, abs(x - y)); y = succ(x); if (y != -1) ret = std::min(ret, abs(x - y)); if (ret != 0x3f3f3f) ans += ret; insert(x); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3224]Tyvj 1728 普通平衡树——splay模板]]></title>
      <url>%2F2017%2F02%2F28%2Fbzoj3224-Tyvj-1728-%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91%E2%80%94%E2%80%94splay%E6%A8%A1%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[题目 你需要写一种数据结构支援以下操作。 1. 插入元素。 2. 删除元素。 3. 查询元素的排名。 4. 查询第k小的元素。 5. 查询元素前趋。 6. 查询元素后继。 题解 BBST裸题。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include &lt;cstdio&gt;#include &lt;iostream&gt;#define ll long longusing namespace std;#ifdef Dconst int maxn = 100;#elseconst int maxn = 100005;#endifint ch[maxn][2], fa[maxn], size[maxn], data[maxn], cnt[maxn];int rt, n, m;ll sz = 0;int read() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-') f = -1; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; return x * f;&#125;inline void update(int x) &#123; size[x] = size[ch[x][0]] + size[ch[x][1]] + cnt[x];&#125;inline void zig(int x) &#123; int y = fa[x], z = fa[y], l = (ch[y][1] == x), r = l ^ 1; fa[ch[y][l] = ch[x][r]] = y; fa[ch[x][r] = y] = x; fa[x] = z; if (z) ch[z][ch[z][1] == y] = x; update(y);&#125;inline void splay(int x, int aim = 0) &#123; //调整x成为aim的儿子 for (int y; (y = fa[x]) != aim; zig(x)) &#123; if (fa[y] != aim) zig((ch[y][0] == x) == (ch[fa[y]][0] == y) ? y : x); &#125; if (aim == 0) rt = x; update(x);&#125;inline void insert(int v) &#123; int x = rt; if (rt == 0) &#123; rt = x = ++sz; data[x] = v; fa[x] = ch[x][0] = ch[x][1] = 0; size[x] = cnt[x] = 1; return; &#125; while (x) &#123; size[x]++; if (v == data[x]) &#123; cnt[x]++; return; &#125; int &amp;y = ch[x][v &gt;= data[x]]; if (y == 0) &#123; y = ++sz; data[y] = v; fa[y] = x; ch[y][0] = ch[y][1] = 0; size[y] = cnt[y] = 1; x = y; break; &#125; x = y; &#125; splay(x);&#125;int rank(int v) &#123; int ret = 0, ans, x = rt; while (x) &#123; if (v &gt; data[x]) &#123; ret += size[ch[x][0]] + cnt[x]; x = ch[x][1]; &#125; else &#123; if (v == data[x]) &#123; return ret + size[ch[x][0]] + 1; &#125; x = ch[x][0]; &#125; &#125;&#125;int kth(int v) &#123; int x = rt; while (x) &#123; if (v &gt;= size[ch[x][0]] + 1 &amp;&amp; v &lt;= size[ch[x][0]] + cnt[x]) return data[x]; if (v &gt; size[ch[x][0]] + cnt[x]) &#123; v -= size[ch[x][0]] + cnt[x]; x = ch[x][1]; &#125; else x = ch[x][0]; &#125;&#125;int pre(int v) &#123; int ans; for (int y = rt; y;) if (data[y] &lt; v) ans = data[y], y = ch[y][1]; else y = ch[y][0]; return ans;&#125;int succ(int v) &#123; int ans; for (int y = rt; y;) if (data[y] &lt;= v) y = ch[y][1]; else ans = data[y], y = ch[y][0]; return ans;&#125;inline void del(int v) &#123; int x = rt; while (x) &#123; size[x]--; if (data[x] == v) &#123; cnt[x]--; break; &#125; int &amp;y = ch[x][v &gt;= data[x]]; x = y; &#125; if (cnt[x] != 0) return; splay(x); if (ch[x][0] == 0) &#123; rt = ch[x][1]; fa[rt] = 0; return; &#125; if (ch[x][1] == 0) &#123; rt = ch[x][0]; fa[rt] = 0; return; &#125; x = ch[rt][0]; while (ch[x][1]) x = ch[x][1]; splay(x, rt); ch[x][1] = ch[rt][1]; fa[ch[x][1]] = x; size[x] = size[rt] - 1; fa[x] = 0; rt = x;&#125;int main() &#123;#ifdef DEBUG freopen("input", "r", stdin);#endif scanf("%d", &amp;n); rt = sz = 0; while (n--) &#123; int opt = read(); if (opt == 1) &#123; int x = read(); insert(x); // O(log n) &#125; else if (opt == 2) &#123; int x = read(); del(x); // O(log n) &#125; else if (opt == 3) &#123; int k = read(); printf("%d\n", rank(k)); &#125; else if (opt == 4) &#123; int k = read(); printf("%d\n", kth(k)); &#125; else if (opt == 5) &#123; int x = read(); printf("%d\n", pre(x)); &#125; else if (opt == 6) &#123; int x = read(); printf("%d\n", succ(x)); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2124]等差子序列——线段树+字符串哈希]]></title>
      <url>%2F2017%2F02%2F27%2Fbzoj2124-%E7%AD%89%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%2F</url>
      <content type="text"><![CDATA[题目大意 给一个1到N的排列\(A_i\)，询问是否存在\(p_i\),\(i&gt;=3\)，使得\(A_{p_1}, A_{p_2}, ... ,A_{p_len}\)是一个等差序列。 #题解 显然，我们只需要找到\(P_1, P_2, P_3\)，使得其为等差数列即可。 考察等差数列的定义，不难得出： \[2*P_2 = P_1 + P_3\] 考察每一个\(P_2\)，如果有\(P_2 - d\)已经出现，\(P_2 + d\)没有出现，那么一定可以组成等差序列。 我们考虑使用线段树维护每一个数字是否出现。如果一个数满足要求，以这个数开头的正序串和逆序串一定是不同的。我们维护每一个区间的哈希值，比较即可。 由于维护时满足区间查询，单点修改，所以我们使用线段树。 这个题WA了八次，最后找root要了数据才发现自己哈希的时候使用的pow数组用了int，结果溢出了orz #代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define ll long long#define mod 1000000007#define p 3using namespace std;const int maxn = 10005;struct seg &#123; int l, r; ll hash1, hash2;&#125; t[maxn * 4];int n, T;ll pow[maxn];void update(int k, ll m) &#123; ll tmp = m &gt;&gt; 1; t[k].hash1 = ((t[k &lt;&lt; 1].hash1 * pow[tmp]) % mod + t[k &lt;&lt; 1 | 1].hash1) % mod; t[k].hash2 = ((t[k &lt;&lt; 1 | 1].hash2 * pow[m - tmp]) % mod + t[k &lt;&lt; 1].hash2) % mod;&#125;void add(int k, int pos) &#123; int l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; if (l == r) &#123; t[k].hash1 = t[k].hash2 = 1; return; &#125; if (pos &lt;= mid) add(k &lt;&lt; 1, pos); else add(k &lt;&lt; 1 | 1, pos); update(k, r - l + 1);&#125;ll query(int k, int x, int y, int opt) &#123; if (x &gt; y) return 0; int l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; if (opt == 1) return t[k].hash1; else return t[k].hash2; &#125; if (y &lt;= mid) return query(k &lt;&lt; 1, x, y, opt); else if (x &gt; mid) return query(k &lt;&lt; 1 | 1,x , y, opt); else &#123; if (opt == 1) &#123; return ((query(k &lt;&lt; 1, x, mid, 1) * pow[y - mid]) % mod+ query(k &lt;&lt; 1 | 1, mid + 1, y, 1) % mod) % mod; &#125; else return ((query(k &lt;&lt; 1, x, mid, 2) + query(k &lt;&lt; 1 | 1, mid + 1, y, 2) * pow[mid - x + 1])%mod) % mod; &#125;&#125;void build(int k, int l, int r) &#123; t[k].l = l, t[k].r = r; if (l == r) &#123; t[k].hash1 = t[k].hash2 = 0; return; &#125; int mid = (l + r) &gt;&gt; 1; build(k &lt;&lt; 1, l, mid); build(k &lt;&lt; 1 | 1, mid + 1, r); update(k, r - l + 1);&#125;int main() &#123; //freopen(&quot;sequence.in&quot;, &quot;r&quot;, stdin); //freopen(&quot;sequence.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d&quot;, &amp;T); //pow[0] = 1; pow[1] = p; for (int i = 2; i &lt;= 10001; i++) pow[i] = (pow[i - 1] * p) % mod; while (T--) &#123; scanf(&quot;%d&quot;, &amp;n); build(1, 1, n); //memset(t, 0, sizeof(t)); int flag = 0; int a[maxn]; memset(a, 0, sizeof(a)); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= n; i++) &#123; int x = a[i]; ll len = min(x - 1, n - x); ll tmp1 = query(1, x - len, x - 1, 1); ll tmp2 = query(1, x + 1, x + len, 2); if (tmp1 != tmp2) &#123; flag = 1; break; &#125; add(1, x); &#125; if (flag) printf(&quot;Y\n&quot;); else printf(&quot;N\n&quot;); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3223]文艺平衡树——splay]]></title>
      <url>%2F2017%2F02%2F27%2Fbzoj3223-%E6%96%87%E8%89%BA%E5%B9%B3%E8%A1%A1%E6%A0%91%E2%80%94%E2%80%94splay%2F</url>
      <content type="text"><![CDATA[题意 你应当编写一个数据结构，支持以下操作： 1. 反转一个区间 题解 我们把在数组中的位置当作权值，这样原序列就在这种权值意义下有序，我们考虑使用splay维护。 对于操作rev[l,r]，我们首先把l-1 splay 到根，再把r+1 splay 到根的右子树的根，那么根的右子树的左子树就是区间[l,r]。 显然，这样会用到l-1和r+1。我们考虑添加两个哨兵节点，分别是1和n+2,[1,n]的值再分别加一就好了。 另外，为了防止过多的swap，我们延续线段树中的做法， 打一个lazy标记。与线段树不同的是，由于splay的拓扑结构经常会变化，所以每访问到一个节点，都要下传lazy标记。 注意build的写法。 # 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, sz, rt;#ifdef DEBUGconst int maxn = 100;#elseconst int maxn = 100005;#endifint fa[maxn], c[maxn][2], id[maxn];int size[maxn];bool rev[maxn];void pushup(int k) &#123; int l = c[k][0], r = c[k][1]; size[k] = size[l] + size[r] + 1;&#125;void pushdown(int k) &#123; int &amp;l = c[k][0], &amp;r = c[k][1]; if (rev[k]) &#123; swap(l, r); rev[l] ^= 1; rev[r] ^= 1; rev[k] = 0; &#125;&#125;void zig(int x, int &amp;k) &#123; // do one zig int y = fa[x], z = fa[y], l, r; // y:father z:grandfather if (c[y][0] == x) &#123; // zig l = 0; &#125; else l = 1; // zag r = l ^ 1; if (y == k) k = x; // single zig else &#123; // update grandfather if (c[z][0] == y) c[z][0] = x; // zig-zig else c[z][1] = x; &#125; fa[x] = z; fa[y] = x; fa[c[x][r]] = y; c[y][l] = c[x][r]; c[x][r] = y; pushup(y); pushup(x);&#125;void splay(int x, int &amp;k) &#123; while (x != k) &#123; int y = fa[x], z = fa[y]; if (y != k) &#123; if (c[y][0] == x ^ c[z][0] == y) // diff:zig-zag or zag-zig zig(x, k); else // same:zig-zig or zag-zag zig(y, k); &#125; zig(x, k); &#125;&#125;int find(int k, int rank) &#123; pushdown(k); int l = c[k][0], r = c[k][1]; if (size[l] + 1 == rank) return k; else if (size[l] &gt;= rank) return find(l, rank); else return find(r, rank - size[l] - 1);&#125;void rever(int l, int r) &#123; int x = find(rt, l), y = find(rt, r + 2); splay(x, rt); splay(y, c[x][1]); int z = c[y][0]; rev[z] ^= 1;&#125;void build(int l, int r, int f) &#123; // f:last node if (l &gt; r) return; int now = id[l], last = id[f]; if (l == r) &#123; fa[now] = last; size[now] = 1; if (l &lt; f) c[last][0] = now; else c[last][1] = now; return; &#125; int mid = (l + r) &gt;&gt; 1; now = id[mid]; build(l, mid - 1, mid); build(mid + 1, r, mid); fa[now] = last; pushup(mid); if (mid &lt; f) &#123; c[last][0] = now; &#125; else c[last][1] = now; return;&#125;int main() &#123;#ifdef DEBUG freopen("input", "r", stdin);#endif scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n + 2; i++) id[i] = ++sz; build(1, n + 2, 0); rt = (n + 3) &gt;&gt; 1; for (int i = 1; i &lt;= m; i++) &#123; int l, r; scanf("%d %d", &amp;l, &amp;r); rever(l, r); &#125; for (int i = 2; i &lt;= n + 1; i++) &#123; printf("%d ", find(rt, i) - 1); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3098]Hash Killer 2——哈希]]></title>
      <url>%2F2017%2F02%2F25%2Fbzoj3098-Hash-Killer-2%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%2F</url>
      <content type="text"><![CDATA[题目 这天天气不错，hzhwcmhf神犇给VFleaKing出了一道题： 给你一个长度为N的字符串S，求有多少个不同的长度为L的子串。 子串的定义是S[l]、S[l + 1]、… S[r]这样连续的一段。 两个字符串被认为是不同的当且仅当某个位置上的字符不同。 VFleaKing一看觉得这不是Hash的裸题么！于是果断写了哈希 + 排序。 而hzhwcmhf神犇心里自然知道，这题就是后缀数组的height中 &lt; L的个数 + 1，就是后缀自动机上代表的长度区间包含L的结点个数，就是后缀树深度为L的结点的数量。 但是hzhwcmhf神犇看了看VFleaKing的做法表示非常汗。于是想卡掉他。 VFleaKing使用的是字典序哈希，其代码大致如下： 1234u64 val = 0;for (int i = 0; i &lt; l; i++)val = (val * base + s[i] – ‘a’) % Mod;u64是无符号int64，范围是[0, 2^64)。 base是一个常量，VFleaKing会根据心情决定其值。 Mod等于1000000007。 VFleaKing还求出来了base ^ l % Mod，即base的l次方除以Mod的余数，这样就能方便地求出所有长度为L的子串的哈希值。 然后VFleaKing给哈希值排序，去重，求出有多少个不同的哈希值，把这个数作为结果。 其算法的C++代码如下： 123456789101112131415161718192021222324252627282930typedef unsigned long long u64;const int MaxN = 100000;inline int hash_handle(const char *s, const int &amp;n, const int &amp;l, const int &amp;base)&#123;const int Mod = 1000000007;u64 hash_pow_l = 1;for (int i = 1; i &lt;= l; i++)hash_pow_l = (hash_pow_l * base) % Mod;int li_n = 0;static int li[MaxN];u64 val = 0;for (int i = 0; i &lt; l; i++)val = (val * base + s[i] – ‘a’) % Mod;li[li_n++] = val;for (int i = l; i &lt; n; i++)&#123;val = (val * base + s[i] – ‘a’) % Mod;val = (val + Mod – ((s[i – l] – ‘a’) * hash_pow_l) % Mod) % Mod;li[li_n++] = val;&#125;sort(li, li + li_n);li_n = unique(li, li + li_n) – li;return li_n;&#125; hzhwcmhf当然知道怎么卡啦！但是他想考考你。 # 题解 &gt;如果一个房间里有23个或23个以上的人，那么至少有两个人的生日相同的概率要大于50%。 &gt;生日攻击：如果你在n个数中随机选数，那么最多选√n次就能选到相同的数（不考虑Rp broken) &gt;同样的，这题的Hash值在0到1000000007. &gt;那就要选差不多10^5次 &gt;唯一注意的是l要取大，使得方案数超过Mod &gt;否则就不可能有2个数有相同的Hash值 引自hzwer # 代码 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000;int n=MAXN,l=20;int main()&#123; cout&lt;&lt;n&lt;&lt;' '&lt;&lt;l&lt;&lt;endl; for(int i=1;i&lt;=n;i++) cout&lt;&lt;char(rand()%26+'a'); cout&lt;&lt;endl; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1798][Ahoi2009]Seq——线段树+多重标记下传]]></title>
      <url>%2F2017%2F02%2F25%2Fbzoj1798-Ahoi2009-Seq%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%A4%9A%E9%87%8D%E6%A0%87%E8%AE%B0%E4%B8%8B%E4%BC%A0%2F</url>
      <content type="text"><![CDATA[题意 请你写一个数据结构，支持： 1. 子序列同加 2. 子序列同乘 3. 统计子序列和 题目 线段树裸题，但对于我这种初学者还是非常难写。 我们维护两个标记，一个是在这个节点上作过的所有乘法操作，一个是加法操作，始终保持乘法优先级在前，这就说明，如果原来已经有了加法，那么我们需要把加法让位，即把加法×乘法，然后乘法搞一下原来的值。 对于如果一个操作与一个区间不完全覆盖，我们需要把lazy标记下传，对于下传操作，也需要按照上面的方法计算优先级，同时更新节点sum值。 注意在加法操作时，不要使用节点的add值更新sum，而要用val，因为add已经计算在sum里面了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longll n, p;ll m;const int maxn = 100005;struct seg &#123; int l, r; ll sum, add, tag;&#125; t[4 * maxn];void build(int k, int l, int r) &#123; t[k].l = l; t[k].r = r; if (r == l) &#123; t[k].tag = 1; t[k].add = 0; scanf(&quot;%lld&quot;, &amp;t[k].sum); t[k].sum %= p; return; &#125; int mid = (l + r) &gt;&gt; 1; build(k &lt;&lt; 1, l, mid); build(k &lt;&lt; 1 | 1, mid + 1, r); t[k].sum = (t[k &lt;&lt; 1].sum + t[k &lt;&lt; 1 | 1].sum) % p; t[k].add = 0; t[k].tag = 1;&#125;void pushdown(int k) &#123; if (t[k].add == 0 &amp;&amp; t[k].tag == 1) return; ll ad = t[k].add, tag = t[k].tag; ad %= p, tag %= p; int l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; t[k &lt;&lt; 1].tag = (t[k &lt;&lt; 1].tag * tag) % p; t[k &lt;&lt; 1].add = ((t[k &lt;&lt; 1].add * tag) % p + ad) % p; t[k &lt;&lt; 1].sum = (((t[k &lt;&lt; 1].sum * tag) % p + (ad * (mid - l + 1) % p)%p)%p) % p; t[k &lt;&lt; 1 | 1].tag = (t[k &lt;&lt; 1 | 1].tag * tag) % p; t[k &lt;&lt; 1 | 1].add = ((t[k &lt;&lt; 1 | 1].add * tag) % p + ad) % p; t[k &lt;&lt; 1 | 1].sum = (((t[k &lt;&lt; 1|1].sum * tag) % p + (ad * (r-mid) % p)%p)%p) % p; t[k].add = 0; t[k].tag = 1; return;&#125;void update(int k) &#123; t[k].sum = (t[k &lt;&lt; 1].sum%p + t[k &lt;&lt; 1 | 1].sum%p) % p; &#125;void add(int k, int x, int y, ll val) &#123; int l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; t[k].add = (t[k].add + val) % p; t[k].sum = (t[k].sum + (val * (r - l + 1) % p) % p) % p; return; &#125; pushdown(k); if (x &lt;= mid) add(k &lt;&lt; 1, x, y, val); if (y &gt; mid) add(k &lt;&lt; 1 | 1, x, y, val); update(k);&#125;void mul(int k, int x, int y, ll val) &#123; int l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; t[k].add = (t[k].add * val) % p; t[k].tag = (t[k].tag * val) % p; t[k].sum = (t[k].sum * val) % p; return; &#125; pushdown(k); if (x &lt;= mid) mul(k &lt;&lt; 1, x, y, val); if (y &gt; mid) mul(k &lt;&lt; 1 | 1, x, y, val); update(k);&#125;ll query(int k, int x, int y) &#123; int l = t[k].l, r = t[k].r, mid = (l + r) &gt;&gt; 1; if (x &lt;= l &amp;&amp; r &lt;= y) &#123; return t[k].sum%p; &#125; pushdown(k); ll ans = 0; if (x &lt;= mid) ans = (ans + query(k &lt;&lt; 1, x, y)) % p; if (y &gt; mid) ans = (ans + query(k &lt;&lt; 1 | 1, x, y)) % p; update(k); return ans%p;&#125;int main() &#123; // freopen(&quot;seq.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;seq.ans&quot;, &quot;w&quot;, stdout); scanf(&quot;%lld %lld&quot;, &amp;n, &amp;p); build(1, 1, n); scanf(&quot;%d&quot;, &amp;m); while (m--) &#123; int q; scanf(&quot;%d&quot;, &amp;q); if (q == 1) &#123; int x, y; ll z; scanf(&quot;%d%d%lld&quot;, &amp;x, &amp;y, &amp;z); z%=p; mul(1, x, y, z); &#125; else if (q == 2) &#123; int x, y; ll z; scanf(&quot;%d%d%lld&quot;, &amp;x, &amp;y, &amp;z); z%=p; add(1, x, y, z); &#125; else &#123; int x, y; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); printf(&quot;%lld\n&quot;, query(1, x, y)); &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1067][SCOI2007]降雨量——线段树+乱搞]]></title>
      <url>%2F2017%2F02%2F24%2Fbzoj1067-SCOI2007-%E9%99%8D%E9%9B%A8%E9%87%8F%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91-%E4%B9%B1%E6%90%9E%2F</url>
      <content type="text"><![CDATA[题目大意 传送门 # 题解 我国古代有一句俗话。 &gt;骗分出奇迹，乱搞最神奇！ 这句话在这道题上得到了鲜明的体现。 我的方法就是魔改版线段树，乱搞搞一下，首先借鉴了黄学长的建树方法，直接用一个节点维护年份的区间，但是这样就带来了问题，就是在查询的时候非常难以操作。经过不断的乱搞，我终于把正确的操作方式搞了出来。。。 另外这个题细节还是很多。详见胡泽聪dalao的分析 # 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 50005;struct seg &#123; int l, r, mx, know;&#125; t[maxn * 4];int s[maxn], n, m;void build(int k, int l, int r) &#123; if (l == r) &#123; scanf(&quot;%d %d&quot;, &amp;t[k].l, &amp;t[k].mx); t[k].r = t[k].l; t[k].know = 1; return; &#125; int mid = (l + r) &gt;&gt; 1; build(k &lt;&lt; 1, l, mid); build(k &lt;&lt; 1 | 1, mid + 1, r); t[k].know = (t[k &lt;&lt; 1].know &amp;&amp; t[k &lt;&lt; 1 | 1].know); if (t[k &lt;&lt; 1].r + 1 != t[k &lt;&lt; 1 | 1].l) t[k].know = 0; t[k].l = t[k &lt;&lt; 1].l; t[k].r = t[k &lt;&lt; 1 | 1].r; t[k].mx = max(t[k &lt;&lt; 1].mx, t[k &lt;&lt; 1 | 1].mx);&#125;int query_mx(int k, int x, int y) &#123; int l = t[k].l, r = t[k].r; if (y &lt; x) return 0; if (x &lt; l) x = l; if (y &gt; r) y = r; if (x == l &amp;&amp; r == y) return t[k].mx; int mid = t[k &lt;&lt; 1].r; int nxmid = t[k &lt;&lt; 1 | 1].l; if (y &lt; l || x &gt; r) return 0; int ans = -0x3f3f3f; if (x &gt;= l &amp;&amp; y &lt; nxmid &amp;&amp; x &lt;= mid) &#123; ans = max(ans, query_mx(k &lt;&lt; 1, x, y)); &#125; else if (y &lt;= r &amp;&amp; x &gt; mid &amp;&amp; y &gt;= nxmid) &#123; ans = max(ans, query_mx(k &lt;&lt; 1 | 1, x, y)); &#125; else if (x &gt;= l &amp;&amp; x &lt;= mid &amp;&amp; y &gt;= nxmid &amp;&amp; y &lt;= r) &#123; ans = max(ans, query_mx(k &lt;&lt; 1, x, mid)); ans = max(ans, query_mx(k &lt;&lt; 1 | 1, nxmid, y)); &#125; else return 0; return ans;&#125;int query_know(int k, int x, int y) &#123; int l = t[k].l, r = t[k].r; if (y &lt; x) return 0; if (x &lt; l || y &gt; r) return 0; if (x == l &amp;&amp; y == r) return t[k].know; else if (r - l == 0) return 0; bool ans = true; int mid = t[k &lt;&lt; 1].r; int nxmid = t[k &lt;&lt; 1 | 1].l; if (x &gt;= l &amp;&amp; y &lt; nxmid &amp;&amp; x &lt;= mid) &#123; ans = ans &amp;&amp; query_know(k &lt;&lt; 1, x, y); &#125; else if (y &lt;= r &amp;&amp; x &gt; mid &amp;&amp; y &gt;= nxmid) &#123; ans = ans &amp;&amp; query_know(k &lt;&lt; 1 | 1, x, y); &#125; else if (x &gt;= l &amp;&amp; x &lt;= mid &amp;&amp; y &gt;= nxmid &amp;&amp; y &lt;= r) &#123; ans = ans &amp;&amp; query_know(k &lt;&lt; 1, x, mid); ans = ans &amp;&amp; query_know(k &lt;&lt; 1 | 1, nxmid, y); ans = ans &amp;&amp; (nxmid-mid &lt;= 1) ? 1 : 0; &#125; else return 0; return ans;&#125;int query(int k, int x) &#123; if (t[k].l == t[k].r) return t[k].mx; if (x &lt;= t[k &lt;&lt; 1].r) return query(k &lt;&lt; 1, x); else if (x &gt;= t[k &lt;&lt; 1 | 1].l) return query(k &lt;&lt; 1 | 1, x); else return -1;&#125;int main() &#123; //freopen(&quot;rain.in&quot;, &quot;r&quot;, stdin); //freopen(&quot;rain.ans&quot;, &quot;w&quot;, stdout); scanf(&quot;%d&quot;, &amp;n); build(1, 1, n); scanf(&quot;%d&quot;, &amp;m); // cout &lt;&lt; query_mx(1, 2003, 2007); //cout &lt;&lt; query_know(1, -138, -129) &lt;&lt; endl; // cout &lt;&lt; query_know(1, 2004, 2006) &lt;&lt; endl; for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); if (query_know(1, x, y) &amp;&amp; (query(1, x) &gt;= query(1, y)) &amp;&amp; (query_mx(1, x + 1, y - 1) &lt; query(1, y))) printf(&quot;true\n&quot;); else if (query_know(1, x, x) &amp;&amp; query_know(1, y, y) &amp;&amp; !(query_know(1, x + 1, y - 1)) &amp;&amp; (query_mx(1, x + 1, y - 1) &lt; query(1, y)) &amp;&amp; (query(1, x) &gt;= query(1, y))) printf(&quot;maybe\n&quot;); else if (query_know(1, x, x) &amp;&amp; !(query_know(1, y, y)) &amp;&amp; (query_mx(1,x+1,y-1) &lt; query(1,x))) printf(&quot;maybe\n&quot;); else if (query_know(1, y, y) &amp;&amp; !(query_know(1, x, x)) &amp;&amp; (query_mx(1, x + 1, y - 1) &lt; query(1, y))) printf(&quot;maybe\n&quot;); else if ((!(query_know(1, x, x)) &amp;&amp; (!(query_know(1, y, y))))) printf(&quot;maybe\n&quot;); else printf(&quot;false\n&quot;); &#125; return 0;&#125; Ps.开始对着样例乱搞出的代码居然得了50分]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3226][Sdoi2008]校门外的区间——线段树]]></title>
      <url>%2F2017%2F02%2F24%2Fbzoj3226-Sdoi2008-%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E5%8C%BA%E9%97%B4%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
      <content type="text"><![CDATA[题目 略 # 题解 直接套黄学长模板。 Orz # 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 1000000000#define n (65536 * 2 + 1)char ch[5];int read() &#123; int x = 0, f = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '(') f = -1; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; if (ch == ')') f = 1; return x * 2 - f;&#125;struct seg &#123; int l, r, val, tag, rev;&#125; t[4 * n];void build(int k, int l, int r) &#123; t[k].l = l; t[k].r = r; t[k].tag = -1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(k &lt;&lt; 1, l, mid); build(k &lt;&lt; 1 | 1, mid + 1, r);&#125;void pushdown(int k) &#123; int tag = t[k].tag, rev = t[k].rev; t[k].tag = -1; t[k].rev = 0; if (t[k].l == t[k].r) &#123; if (tag != -1) t[k].val = tag; t[k].val ^= rev; return; &#125; if (tag != -1) &#123; t[k &lt;&lt; 1].tag = t[k &lt;&lt; 1 | 1].tag = tag; t[k &lt;&lt; 1].rev = t[k &lt;&lt; 1 | 1].rev = 0; &#125; t[k &lt;&lt; 1].rev ^= rev; t[k &lt;&lt; 1 | 1].rev ^= rev;&#125;int query(int k, int x) &#123; pushdown(k); int l = t[k].l, r = t[k].r; if (l == r) return t[k].val; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) return query(k &lt;&lt; 1, x); else return query(k &lt;&lt; 1 | 1, x);&#125;void modify(int k, int x, int y, int val) &#123; if (y &lt; x) return; pushdown(k); int l = t[k].l, r = t[k].r; if (l == x &amp;&amp; r == y) &#123; if (val == -1) t[k].rev ^= 1; else t[k].tag = val; return; &#125; int mid = (l + r) &gt;&gt; 1; if (y &lt;= mid) modify(k &lt;&lt; 1, x, y, val); else if (x &gt; mid) modify(k &lt;&lt; 1 | 1, x, y, val); else &#123; modify(k &lt;&lt; 1, x, mid, val); modify(k &lt;&lt; 1 | 1, mid + 1, y, val); &#125;&#125;void rever(int k, int x, int y) &#123; modify(k, x, y, -1); &#125;int main() &#123; build(1, 1, n); while (scanf("%s", ch) != EOF) &#123; int a = read(), b = read(); a += 2; b += 2; switch (ch[0]) &#123; case 'U': modify(1, a, b, 1); break; case 'I': modify(1, 1, a - 1, 0); modify(1, b + 1, n, 0); break; case 'D': modify(1, a, b, 0); break; case 'C': modify(1, 1, a - 1, 0); modify(1, b + 1, n, 0); rever(1, a, b); break; case 'S': rever(1, a, b); break; &#125; &#125; int start = -1, last = -1, flag = 0; for (int i = 1; i &lt;= n; i++) &#123; if (query(1, i)) &#123; if (start == -1) start = i; last = i; &#125; else &#123; if (start != -1) &#123; if (flag) printf(" "); else flag = 1; if (start &amp; 1) printf("("); else printf("["); printf("%d", start / 2 - 1); printf(","); printf("%d", (last + 1) / 2 - 1); if (last &amp; 1) printf(")"); else printf("]"); &#125; last = start = -1; &#125; &#125; if (!flag) printf("empty set"); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3884]上帝与集合的正确用法——欧拉函数]]></title>
      <url>%2F2017%2F02%2F24%2Fbzoj3884-%E4%B8%8A%E5%B8%9D%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95%E2%80%94%E2%80%94%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题目大意 # 题解 出题人博客 # 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int M = 10001000;int phi[M];int Phi(int x) &#123; int i, ret = x; for (i = 2; i * i &lt;= x; i++) &#123; if (x % i == 0) &#123; ret /= i; ret *= (i - 1); while (x % i == 0) x /= i; &#125; &#125; if (x ^ 1) ret /= x, ret *= x - 1; return ret;&#125;int pow(long long x, int y, int p) &#123; long long ret = 1; while (y) &#123; if (y &amp; 1) ret = (ret * x) % p; x = (x * x) % p; y &gt;&gt;= 1; &#125; return ret;&#125;int solve(int p) &#123; if (p == 1) return 0; int tmp = 0; while (~p &amp; 1) p &gt;&gt;= 1, ++tmp; int phi_p = Phi(p); int ret = solve(phi_p); (ret += phi_p - tmp % phi_p) %= phi_p; ret = pow(2, ret, p) % p; return ret &lt;&lt; tmp;&#125;int main() &#123; int T, p; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;p); printf("%d\n", solve(p)); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj4602][Sdoi2016]齿轮——dfs]]></title>
      <url>%2F2017%2F02%2F24%2Fbzoj4602-Sdoi2016-%E9%BD%BF%E8%BD%AE%E2%80%94%E2%80%94dfs%2F</url>
      <content type="text"><![CDATA[题目 现有一个传动系统，包含了N个组合齿轮和M个链条。每一个链条连接了两个组合齿轮u和v，并提供了一个传动比x y。即如果只考虑这两个组合齿轮，编号为u的齿轮转动x圈，编号为v的齿轮会转动y圈。传动比为正表示若编号 为u的齿轮顺时针转动，则编号为v的齿轮也顺时针转动。传动比为负表示若编号为u的齿轮顺时针转动，则编号为v 的齿轮会逆时针转动。若不同链条的传动比不相容，则有些齿轮无法转动。我们希望知道，系统中的这Ｎ个组合齿 轮能否同时转动。 # 题解： 没想到直接dfs居然能过。 doc出的题真的是。。。水题水的不敢想象，难题难得不敢想象。。。 # 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;#define eps 1e-8struct edge &#123; int to; double w;&#125;;const int maxn = 2000;double f[maxn];int vis[maxn];vector&lt;edge&gt; G[maxn];void add_edge(int u, int v, double w) &#123; G[u].push_back((edge)&#123;v, w&#125;); &#125;int n, m, t, kase = 0;bool dfs(int x) &#123; vis[x] = 1; for (int i = 0; i &lt; G[x].size(); i++) &#123; edge &amp;e = G[x][i]; if (vis[e.to]) &#123; if (fabs(f[e.to] - e.w * f[x]) &gt; eps) return false; &#125; else &#123; f[e.to] = f[x] * e.w; if (!dfs(e.to)) return false; &#125; &#125; return true;&#125;int main() &#123; // freopen(&quot;input&quot;, &quot;r&quot;, stdin); scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) G[i].clear(); for (int i = 1; i &lt;= n; i++) f[i] = 0; for (int i = 1; i &lt;= m; i++) &#123; int u, v; long long x, y; scanf(&quot;%d %d %lld %lld&quot;, &amp;u, &amp;v, &amp;x, &amp;y); double d = (double)y / (double)x; add_edge(u, v, d); add_edge(v, u, 1 / d); //注意要连一条反向边，这样才能做到一整个连通块在一次赋值内全部dfs到。 &#125; memset(vis, 0, sizeof(vis)); int flag = 1; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i]) &#123; f[i] = 1; if (!dfs(i)) &#123; flag = 0; break; &#125; &#125; &#125; if (flag) &#123; printf(&quot;Case #%d: Yes\n&quot;, ++kase); &#125; else &#123; printf(&quot;Case #%d: No\n&quot;, ++kase); &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1015][JSOI2008]星球大战——并查集+离线处理]]></title>
      <url>%2F2017%2F02%2F23%2Fbzoj1015-JSOI2008-%E6%98%9F%E7%90%83%E5%A4%A7%E6%88%98%E2%80%94%E2%80%94%E5%B9%B6%E6%9F%A5%E9%9B%86-%E7%A6%BB%E7%BA%BF%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[题解 给定一张图，支持删点和询问连通块个数 按操作顺序处理的话要在删除点的同时维护图的形态（即图具体的连边情况），这是几乎不可做的 我们发现，这道题可以先读入操作，把没删的点的边先连上，然后再倒序处理操作 这样的话从删点变成了加点，而且只要维护连通块的数量，用并查集可以快速的解决这个问题 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 4 * 200000;int n, m, q[maxn];vector&lt;int&gt; G[maxn];int fa[maxn], added[maxn], des[maxn], ans[maxn];int tot = 0;int find(int x) &#123; return fa[x] = fa[x] == x ? x : find(fa[x]); &#125;void add(int x) &#123; int p = find(x), q; added[x] = 1; for (int i = 0; i &lt; G[x].size(); i++) &#123; if (added[G[x][i]]) &#123; q = find(G[x][i]); if (p != q) &#123; fa[q] = p; tot--; //连通块少一个 &#125; &#125; &#125;&#125;int main() &#123; // freopen(&quot;input&quot;, &quot;r&quot;, stdin); scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); G[x].push_back(y); G[y].push_back(x); &#125; memset(added, 0, sizeof(added)); for (int i = 0; i &lt; n; i++) fa[i] = i; int d; scanf(&quot;%d&quot;, &amp;d); for (int i = 1; i &lt;= d; i++) &#123; scanf(&quot;%d&quot;, &amp;q[i]); des[q[i]] = 1; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!des[i]) &#123; tot++; add(i); added[i] = 1; &#125; &#125; ans[d + 1] = tot; for (int i = d; i &gt; 0; i--) &#123; tot++; //连通块多一个 add(q[i]); added[q[i]] = 1; ans[i] = tot; &#125; for (int i = 1; i &lt;= d + 1; i++) printf(&quot;%d\n&quot;, ans[i]); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3597][scoi2014]方伯伯运椰子——分数规划，负环]]></title>
      <url>%2F2017%2F02%2F23%2Fbzoj3597-scoi2014-%E6%96%B9%E4%BC%AF%E4%BC%AF%E8%BF%90%E6%A4%B0%E5%AD%90%E2%80%94%E2%80%94%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92%EF%BC%8C%E8%B4%9F%E7%8E%AF%2F</url>
      <content type="text"><![CDATA[题解 目标就是 \[Maximize\ \lambda = \frac{X-Y}{k}\] 按照分数规划的一般规律， 构造： \[g(\lambda) = \lambda k + Y - X\] 由于总流量不变，我们考虑转移流量。 注意到，对于每条边，我们如果增加其容量则会增加(b[i]+d[i]+lambda)点值，如果减少就是(a[i]-d[i]+lambda)点值。 如果可以构成一个负环，那么就一定可以更优。 所以我们二分\(\lambda\)，check即可。 # 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;#define eps 1e-5struct haha &#123; int x, y, a, b, c, d;&#125;;struct edge &#123; int from, to; double cost;&#125;;const int maxn = 5005;vector&lt;edge&gt; G[maxn];haha b[maxn];int n, m;int vis[maxn], flag;double dist[maxn];void add_edge(int from, int to, double cost) &#123; G[from].push_back((edge)&#123;from, to, cost&#125;);&#125;void dfs(int i) &#123; vis[i] = 1; for (int j = 0; j &lt; G[i].size(); j++) &#123; edge &amp;e = G[i][j]; if (dist[e.to] &gt; dist[i] + e.cost) &#123; if (vis[e.to]) flag = 1; else &#123; dist[e.to] = dist[i] + e.cost; dfs(e.to); &#125; &#125; &#125; vis[i] = 0;&#125;bool check(double lambda) &#123; for (int i = 1; i &lt;= n; i++) G[i].clear(); for (int i = 1; i &lt;= m; i++) &#123; if (b[i].c) add_edge(b[i].y, b[i].x, b[i].a - b[i].d + lambda); add_edge(b[i].x, b[i].y, b[i].b + b[i].d + lambda); &#125; flag = 0; memset(vis, 0, sizeof(vis)); memset(dist, 0, sizeof(dist)); for (int i = 1; i &lt;= n &amp;&amp; !flag; i++) &#123; dfs(i); &#125; return flag;&#125;int main() &#123; // freopen("input", "r", stdin); scanf("%d %d", &amp;n, &amp;m); n += 2; for (int i = 1; i &lt;= m; i++) scanf("%d%d%d%d%d%d", &amp;b[i].x, &amp;b[i].y, &amp;b[i].a, &amp;b[i].b, &amp;b[i].c, &amp;b[i].d); double L = 0, R = 10000000; while (R - L &gt; eps) &#123; double mid = (L + R) / 2; if (check(mid)) L = mid; else R = mid; &#125; printf("%.2f\n", L);&#125; 总结 1. 图上的分数规划问题要考虑分摊到每个边上。 2. 分数规划问题要注意double的赋值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2763][JLOI2011]飞行路线——分层图最短路]]></title>
      <url>%2F2017%2F02%2F23%2Fbzoj2763-JLOI2011-%E9%A3%9E%E8%A1%8C%E8%B7%AF%E7%BA%BF%E2%80%94%E2%80%94%E5%88%86%E5%B1%82%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
      <content type="text"><![CDATA[水题。不多说什么。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10010;const int maxk = 15;int n, m, k, s, t;struct edge &#123; int to, value;&#125;;struct state &#123; int pos; int k;&#125;;vector&lt;edge&gt; G[maxn];int dist[maxn][maxk], inq[maxn][maxk];void add_edge(int u, int v, int w) &#123; G[u].push_back((edge)&#123;v, w&#125;); G[v].push_back((edge)&#123;u, w&#125;);&#125;void spfa() &#123; memset(dist, 0x3f, sizeof(dist)); dist[s][0] = 0; queue&lt;state&gt; q; q.push((state)&#123;s, 0&#125;); memset(inq, 0, sizeof(inq)); inq[s][0] = 1; while (!q.empty()) &#123; state u = q.front(); q.pop(); inq[u.pos][u.k] = 0; for (int i = 0; i &lt; G[u.pos].size(); i++) &#123; edge &amp;e = G[u.pos][i]; if (dist[e.to][u.k] &gt; dist[u.pos][u.k] + e.value) &#123; dist[e.to][u.k] = dist[u.pos][u.k] + e.value; if (!inq[e.to][u.k]) &#123; q.push((state)&#123;e.to, u.k&#125;); inq[e.to][u.k] = 1; &#125; &#125; if (u.k &lt; k &amp;&amp; dist[e.to][u.k + 1] &gt; dist[u.pos][u.k]) &#123; dist[e.to][u.k + 1] = dist[u.pos][u.k]; if (!inq[e.to][u.k + 1]) &#123; q.push((state)&#123;e.to, u.k + 1&#125;); inq[e.to][u.k + 1] = 1; &#125; &#125; &#125; &#125;&#125;int main() &#123; // freopen(&quot;input&quot;, &quot;r&quot;, stdin); scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;k); scanf(&quot;%d %d&quot;, &amp;s, &amp;t); while (m--) &#123; int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); add_edge(a, b, c); &#125; spfa(); int ans = 0x3f3f3f; for (int i = 0; i &lt;= k; i++) ans = min(ans, dist[t][i]); printf(&quot;%d\n&quot;, ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2662][BeiJing wc2012]冻结——分层图最短路]]></title>
      <url>%2F2017%2F02%2F23%2Fbzoj2662-BeiJing-wc2012-%E5%86%BB%E7%BB%93%E2%80%94%E2%80%94%E5%88%86%E5%B1%82%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
      <content type="text"><![CDATA[题目大意 我们考虑最简单的旅行问题吧： 现在这个大陆上有 N 个城市，M 条双向的 道路。城市编号为 1~N，我们在 1 号城市，需要到 N 号城市，怎样才能最快地 到达呢？ 这不就是最短路问题吗？我们都知道可以用 Dijkstra、Bellman-Ford、 Floyd-Warshall等算法来解决。 现在，我们一共有 K 张可以使时间变慢 50%的 SpellCard，也就是说，在通 过某条路径时，我们可以选择使用一张卡片，这样，我们通过这一条道路的时间 就可以减少到原先的一半。需要注意的是： 1. 在一条道路上最多只能使用一张 SpellCard。 2. 使用一张SpellCard 只在一条道路上起作用。 3. 你不必使用完所有的 SpellCard。 给定以上的信息，你的任务是：求出在可以使用这不超过 K 张时间减速的 SpellCard 之情形下，从城市1 到城市N最少需要多长时间。 # 题解 记录dist[i][j]为到了i点用了j张票。 用spfa转移状态。 # 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 55;struct edge &#123; int to; int value;&#125;;struct state &#123; int pos; int tic;&#125;;vector&lt;edge&gt; G[maxn];void add_edge(int from, int to, int value) &#123; G[from].push_back((edge)&#123;to, value&#125;); G[to].push_back((edge)&#123;from, value&#125;);&#125;int dist[maxn][maxn], inq[maxn][maxn];int n, m, k;void spfa() &#123; memset(dist, 0x3f, sizeof(dist)); memset(inq, 0, sizeof(inq)); for (int i = 0; i &lt;= k; i++) dist[1][i] = 0; queue&lt;state&gt; q; q.push((state)&#123;1, 0&#125;); inq[1][0] = 1; while (!q.empty()) &#123; state u = q.front(); q.pop(); inq[u.pos][u.tic] = 0; for (int i = 0; i &lt; G[u.pos].size(); i++) &#123; edge &amp;e = G[u.pos][i]; if (dist[e.to][u.tic] &gt; dist[u.pos][u.tic] + e.value) &#123; dist[e.to][u.tic] = dist[u.pos][u.tic] + e.value; if (!inq[e.to][u.tic]) &#123; q.push((state)&#123;e.to, u.tic&#125;); inq[e.to][u.tic] = 0; &#125; &#125; &#125; if (u.tic &lt; k) for (int i = 0; i &lt; G[u.pos].size(); i++) &#123; edge &amp;e = G[u.pos][i]; if (dist[e.to][u.tic + 1] &gt; dist[u.pos][u.tic] + (e.value &gt;&gt; 1)) &#123; dist[e.to][u.tic + 1] = dist[u.pos][u.tic] + (e.value &gt;&gt; 1); if (!inq[e.to][u.tic + 1]) &#123; q.push((state)&#123;e.to, u.tic + 1&#125;); inq[e.to][u.tic + 1] = 1; &#125; &#125; &#125; &#125;&#125;int main() &#123; // freopen("input", "r", stdin); scanf("%d %d %d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; i++) &#123; int x, y, z; scanf("%d %d %d", &amp;x, &amp;y, &amp;z); add_edge(x, y, z); &#125; spfa(); int ans = 0x3f3f3f; for (int i = 0; i &lt;= k; i++) &#123; ans = min(ans, dist[n][i]); &#125;; printf("%d\n", ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3231][SDOI2008]递归数列——矩阵乘法]]></title>
      <url>%2F2017%2F02%2F23%2Fbzoj3231-SDOI2008-%E9%80%92%E5%BD%92%E6%95%B0%E5%88%97%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%2F</url>
      <content type="text"><![CDATA[题目大意： 一个由自然数组成的数列按下式定义： 对于i &lt;= k：ai = bi 对于i &gt; k: ai = c1ai-1 + c2ai-2 + … + ckai-k 其中bj和 cj （1&lt;=j&lt;=k）是给定的自然数。写一个程序，给定自然数m &lt;= n, 计算am + am+1 + am+2 + … + an, 并输出它除以给定自然数p的余数的值。 # 题解 首先显然我们可以构造一个矩阵递推\(a_i\)。 如果直接从m递推到n，会超时（我也没写过，不知道），我们在矩阵中加一维，记录\(s_i\)，具体可以见代码 注意一个问题：减法取模时应该加成正数。因为这个WA了好几次。 # 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long longusing namespace std;const ll maxn = 20;ll k, B[maxn], C[maxn], s[maxn];ll m, n, p;struct M &#123; ll n, m; ll a[maxn][maxn];&#125; a, b;M operator*(M a, M b) &#123; M c; c.n = a.n; c.m = b.m; memset(c.a, 0, sizeof(c.a)); for (ll i = 1; i &lt;= c.n; i++) &#123; for (ll j = 1; j &lt;= c.m; j++) &#123; for (ll k = 1; k &lt;= a.m; k++) c.a[i][j] = (c.a[i][j] + (ull)(a.a[i][k] * b.a[k][j]) % p) % p; &#125; &#125; return c;&#125;M pow(M a, ll b) &#123; M ret; ret.n = a.n; ret.m = a.m; memset(ret.a, 0, sizeof(ret.a)); for (ll i = 1; i &lt;= ret.n; i++) ret.a[i][i] = 1; while (b) &#123; if (b &amp; 1) ret = ret * a; a = a * a; b &gt;&gt;= 1; &#125; return ret;&#125;void print(M x) &#123; for (ll i = 1; i &lt;= x.n; i++) &#123; for (ll j = 1; j &lt;= x.m; j++) cout &lt;&lt; x.a[i][j] &lt;&lt; ' '; cout &lt;&lt; endl; &#125;&#125;ll calc(ll x) &#123; M y = pow(a, x + 1); // prll (y); y = y * b; return y.a[1][1];&#125;int main() &#123; // freopen("input", "r", stdin); scanf("%lld", &amp;k); a.n = k + 1; a.m = k + 1; b.n = k + 1; b.m = 1; s[0] = 0; for (ll i = 1; i &lt;= k; i++) &#123; scanf("%lld", &amp;B[i]); &#125; for (ll i = 1; i &lt;= k; i++) scanf("%lld", &amp;C[i]); scanf("%lld %lld %lld", &amp;m, &amp;n, &amp;p); for (ll i = 1; i &lt;= k; i++) s[i] = (B[i] + s[i - 1]) % p; b.a[1][1] = s[k - 1]; for (ll i = 1; i &lt;= k; i++) b.a[i + 1][1] = B[k - i + 1]; a.a[1][1] = a.a[1][2] = 1; for (ll i = 1; i &lt;= k; i++) a.a[2][i + 1] = C[i]; for (ll i = 1; i &lt; k; i++) a.a[i + 2][i + 1] = 1; // a = a * b; ll ans1, ans2; // calc(1); if (m - 1 &gt; k) ans1 = calc(m - 1 - k); else ans1 = s[m - 1]; if (n &gt; k) ans2 = calc(n - k); else ans2 = s[n]; printf("%lld\n", (ans2 - ans1 + p) % p); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2186][Sdoi2008]沙拉公主的困惑——数论]]></title>
      <url>%2F2017%2F02%2F23%2Fbzoj2186-Sdoi2008-%E6%B2%99%E6%8B%89%E5%85%AC%E4%B8%BB%E7%9A%84%E5%9B%B0%E6%83%91%E2%80%94%E2%80%94%E6%95%B0%E8%AE%BA%2F</url>
      <content type="text"><![CDATA[题目大意 求 \[\sum_{i = 1}^{N!} [gcd(i, M!) = 1]\] #题解 显然，题目就是求 \[N!(1-\frac{1}{p_1})(1-\frac{1}{p_2})...\] 即 \[N!\prod(p_i - 1)(\prod p_i)^{-1}\] 预处理一下，都是线性复杂度。 注意： 1. N=1的情况 2. long long 所以，数论题一定要注意各种特殊情况和longlong 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn = 10000110;const int N = 10000010;int n, m, t, r;int prime[maxn], check[maxn], d[maxn];int prd1[maxn], prd2[maxn], fact[maxn];int tot = 0;inline int read() &#123; char c = getchar(); int f = 1, x = 0; while (!isdigit(c)) &#123; if (c == &apos;-&apos;) f = -1; c = getchar(); &#125; while (isdigit(c)) x = x * 10 + c - &apos;0&apos;, c = getchar(); return x * f;&#125;inline void get_prime(int n) &#123; memset(check, 0, sizeof(check)); for (int i = 2; i &lt;= n; i++) &#123; if (!check[i]) prime[tot++] = i; for (int j = 0; j &lt; tot; j++) &#123; if (i * prime[j] &gt; n) break; check[i * prime[j]] = 1; if (i % prime[j] == 0) break; &#125; &#125;&#125;inline void get_prd(int p) &#123; // get prd (p_i - 1) and prd (p_i); prd1[0] = 1; prd2[0] = 2; for (int i = 1; i &lt;= tot; i++) &#123; prd1[i] = (((ll)prime[i] - 1) % p * (ll)prd1[i - 1]) % p; prd2[i] = (ll)(prime[i] % p * (ll)prd2[i - 1]) % p; &#125;&#125;inline void init() &#123; for (int i = 0; i &lt; tot; i++) &#123; for (int j = prime[i]; j &lt; prime[i + 1]; j++) d[j] = i; &#125; fact[0] = fact[1] = 1; for (int i = 2; i &lt;= N; i++) fact[i] = (ll)(fact[i - 1] * (ll)i) % r;&#125;int pow(int a, int b, int p) &#123; int x = 1; int c = b; while (c) &#123; if (c &amp; 1) x = (ll)((ll)x * a) % p; a = (ll)((ll)a * a) % p; c &gt;&gt;= 1; &#125; return x;&#125;int inv(int a, int p) &#123; return pow(a, p - 2, p); &#125;int main() &#123; scanf(&quot;%lld %lld&quot;, &amp;t, &amp;r); get_prime(N); get_prd(r); init(); while (t--) &#123; n = read(); m = read(); if (m == 1) &#123; printf(&quot;%lld\n&quot;, fact[n]); continue; &#125; int ans = ((ll)((ll)fact[n] * prd1[d[m]]) % r * (ll)inv(prd2[d[m]], r)) % r; printf(&quot;%d\n&quot;, ans); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2427][HAOI2010]软件安装——强连通分量+树形DP]]></title>
      <url>%2F2017%2F02%2F22%2Fbzoj2427-HAOI2010-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E2%80%94%E2%80%94%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-%E6%A0%91%E5%BD%A2DP%2F</url>
      <content type="text"><![CDATA[题目大意 现在我们的手头有N个软件，对于一个软件i，它要占用Wi的磁盘空间，它的价值为Vi。我们希望从中选择一些软件安装到一台磁盘容量为M计算机上，使得这些软件的价值尽可能大（即Vi的和最大）。 但是现在有个问题：软件之间存在依赖关系，即软件i只有在安装了软件j（包括软件j的直接或间接依赖）的情况下才能正确工作（软件i依赖软件j)。幸运的是，一个软件最多依赖另外一个软件。如果一个软件不能正常工作，那么它能够发挥的作用为0。 我们现在知道了软件之间的依赖关系：软件i依赖软件Di。现在请你设计出一种方案，安装价值尽量大的软件。一个软件只能被安装一次，如果一个软件没有依赖则Di=0，这时只要这个软件安装了，它就能正常工作。 题解 根据题目，我们建立图。 显然这个图由一些树和一些scc构成（注意：scc一定不在树上），那么我们可以知道，如果选了scc中的一个点，其他点必须也要选，所以我们把所有的scc缩成一个点，这样就构成了一个森林。 对于一个入度为0的点，我们从一个虚点向其连接一条边，这样图就变成了树。 考虑树形dp，定义f[i][j]为对于i为根的子树总共分配j点权值能拿到的最大value 我们可以有\[f[i][j] = f[k][l] + f[i][j-l]\] 记忆化搜索即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll maxn = 505;const ll maxm = 1000;ll n, m, K, s, ans = 0;ll w[maxn], v[maxn], W[maxn], V[maxn];ll cnt[maxn], vis[maxn], in[maxn], f[maxn][maxm];vector&lt;ll&gt; sc[maxn];vector&lt;ll&gt; vs;vector&lt;ll&gt; G[maxn];vector&lt;ll&gt; rg[maxn];vector&lt;ll&gt; ng[maxn];void add(ll from, ll to) &#123; G[from].push_back(to); rg[to].push_back(from);&#125;void add_edge(ll from, ll to) &#123; in[to] = 1; ng[from].push_back(to);&#125;void dfs(ll s) &#123; vis[s] = 1; for (ll i = 0; i &lt; G[s].size(); i++) &#123; if (!vis[G[s][i]]) dfs(G[s][i]); &#125; vs.push_back(s);&#125;void rdfs(ll s, ll k) &#123; vis[s] = 1; for (ll i = 0; i &lt; rg[s].size(); i++) &#123; if (!vis[rg[s][i]]) rdfs(rg[s][i], k); &#125; cnt[s] = k; sc[k].push_back(s);&#125;void scc() &#123; memset(vis, 0, sizeof(vis)); vs.clear(); for (ll i = 1; i &lt;= n; i++) &#123; if (!vis[i]) dfs(i); &#125; ll k = 0; memset(vis, 0, sizeof(vis)); for (ll i = vs.size() - 1; i &gt;= 0; i--) &#123; if (!vis[vs[i]]) rdfs(vs[i], k++); &#125; K = k;&#125;void build_graph() &#123; for (ll i = 0; i &lt; K; i++) &#123; for (ll j = 0; j &lt; sc[i].size(); j++) &#123; W[i] += w[sc[i][j]]; V[i] += v[sc[i][j]]; &#125; &#125; for (ll i = 1; i &lt;= n; i++) &#123; for (ll j = 0; j &lt; G[i].size(); j++) &#123; if (cnt[i] != cnt[G[i][j]]) add_edge(cnt[i], cnt[G[i][j]]); &#125; &#125; s = K + 1; for (ll i = 0; i &lt; K; i++) if (!in[i]) add_edge(s, i);&#125;void dp(ll x) &#123; for (ll i = 0; i &lt; ng[x].size(); i++) &#123; dp(ng[x][i]); for (ll j = m - W[x]; j &gt;= 0; j--) &#123; //鏋氫妇閫夊畬鑷繁鍚庤垂鐢? for (ll k = 0; k &lt;= j; k++) &#123; //鏋氫妇缁欏効瀛愮殑璐圭敤 f[x][j] = max(f[x][j], f[x][k] + f[ng[x][i]][j - k]); &#125; &#125; &#125; for (ll j = m; j &gt;= 0; j--) &#123; if (j &gt;= W[x]) f[x][j] = f[x][j - W[x]] + V[x]; else f[x][j] = 0; &#125;&#125;int main() &#123; // freopen("input", "r", stdin); scanf("%lld %lld", &amp;n, &amp;m); for (ll i = 1; i &lt;= n; i++) scanf("%lld", &amp;w[i]); for (ll i = 1; i &lt;= n; i++) scanf("%lld", &amp;v[i]); for (ll i = 1; i &lt;= n; i++) &#123; ll x; scanf("%lld", &amp;x); if (x) add(x, i); &#125; scc(); build_graph(); dp(s); printf("%lld\n", f[s][m]);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3931][CQOI2015]网络吞吐量——最短路+网络流]]></title>
      <url>%2F2017%2F02%2F22%2Fbzoj3931-CQOI2015-%E7%BD%91%E7%BB%9C%E5%90%9E%E5%90%90%E9%87%8F%E2%80%94%E2%80%94%E6%9C%80%E7%9F%AD%E8%B7%AF-%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
      <content type="text"><![CDATA[题目 传送门 #题解 第一次一遍就AC一道bzoj上的题，虽然是一道水题。。。 我们做一边最短路，求出每个点的dist，然后再做一次类似spfa的操作，求出每个点是否可以用于建图。 在新图上拆点跑一边dinic就好辣。 #代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;#define ll long longconst ll inf = 100000000000;const int maxn = 1000;struct edge &#123; int from; int to; ll value;&#125;;vector&lt;edge&gt; edges;vector&lt;int&gt; G[maxn];vector&lt;edge&gt; gg[maxn];void add(int from, int to, ll value) &#123; gg[from].push_back((edge)&#123;from, to, value&#125;);&#125;void add_edge(int from, int to, ll value) &#123; edges.push_back((edge)&#123;from, to, value&#125;); edges.push_back((edge)&#123;to, from, 0&#125;); int m = edges.size(); G[from].push_back(m - 2); G[to].push_back(m - 1);&#125;ll dist[maxn];int iter[maxn];int n, m;ll c[maxn];int st, t;void spfa(int s) &#123; for (int i = 1; i &lt;= n; i++) dist[i] = inf; queue&lt;int&gt; q; bool inq[maxn]; memset(inq, 0, sizeof(inq)); q.push(s); dist[s] = 0; inq[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = 0; for (int i = 0; i &lt; gg[u].size(); i++) &#123; edge &amp;e = gg[u][i]; if (dist[e.to] &gt; dist[u] + e.value) &#123; dist[e.to] = dist[u] + e.value; if (!inq[e.to]) &#123; q.push(e.to); inq[e.to] = 1; &#125; &#125; &#125; &#125;&#125;void build_graph(int s, int e) &#123; queue&lt;int&gt; q; q.push(s); bool inq[maxn]; memset(inq, 0, sizeof(inq)); inq[s] = 1; int vis[maxn]; memset(vis, 0, sizeof(vis)); vis[s] = 1; add_edge(st, s, inf); add_edge(e + n, t, inf); add_edge(s, s + n, inf); add_edge(e, e + n, inf); while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = 0; for (int i = 0; i &lt; gg[u].size(); i++) &#123; edge &amp;ee = gg[u][i]; if (dist[ee.to] == dist[u] + ee.value) &#123; add_edge(u + n, ee.to, inf); if (!vis[ee.to] &amp;&amp; ee.to != e) &#123; add_edge(ee.to, ee.to + n, c[ee.to]); vis[ee.to] = 1; &#125; if (!inq[ee.to]) &#123; q.push(ee.to); inq[ee.to] = 1; &#125; &#125; &#125; &#125;&#125;void bfs(int s) &#123; memset(dist, -1, sizeof(dist)); dist[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; edge &amp;e = edges[G[u][i]]; if (e.value &gt; 0 &amp;&amp; dist[e.to] == -1) &#123; dist[e.to] = dist[u] + 1; q.push(e.to); &#125; &#125; &#125;&#125;ll dfs(int s, int t, ll flow) &#123; if (s == t) return flow; for (int &amp;i = iter[s]; i &lt; G[s].size(); i++) &#123; edge &amp;e = edges[G[s][i]]; if (dist[e.to] &gt; dist[s] &amp;&amp; e.value &gt; 0) &#123; int d = dfs(e.to, t, min(flow, e.value)); if (d &gt; 0) &#123; e.value -= d; edges[G[s][i] ^ 1].value += d; return d; &#125; &#125; &#125; return 0;&#125;ll dinic(int s, int t) &#123; ll flow = 0; while (1) &#123; bfs(s); if (dist[t] == -1) return flow; memset(iter, 0, sizeof(iter)); ll d; while (d = dfs(s, t, inf)) flow += d; &#125;&#125;int main() &#123; // freopen("input", "r", stdin); scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int x, y; ll z; scanf("%d %d %lld", &amp;x, &amp;y, &amp;z); add(x, y, z); add(y, x, z); &#125; for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;c[i]); spfa(1); st = 0, t = n + n + 1; build_graph(1, n); ll ans = dinic(st, t); printf("%lld\n", ans);&#125; Excited！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1823][JSOI2010]满汉全席——2-SAT]]></title>
      <url>%2F2017%2F02%2F22%2Fbzoj1823-JSOI2010-%E6%BB%A1%E6%B1%89%E5%85%A8%E5%B8%AD%E2%80%94%E2%80%942-SAT%2F</url>
      <content type="text"><![CDATA[题目大意 题目又丑又长我就不贴了，说一下大意，有n种菜，m个评委，每一个评委又有两种喜好，每种菜有满汉两种做法，只能选一种。判断是否存在一种方案使得所有评委至少喜欢一种菜品。输入包含多组数据。 # 题解 显然是2-SAT，注意两种不同做法的菜也要连边。 # 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000;vector&lt;int&gt; G[maxn];vector&lt;int&gt; rG[maxn];vector&lt;int&gt; sc[maxn];int vis[maxn], v, cnt[maxn];vector&lt;int&gt; vs;void add_edge(int from, int to) &#123; G[from].push_back(to); rG[to].push_back(from);&#125;void dfs(int u) &#123; vis[u] = true; for (int i = 0; i &lt; G[u].size(); i++) &#123; if (!vis[G[u][i]]) dfs(G[u][i]); &#125; vs.push_back(u);&#125;void rdfs(int v, int k) &#123; vis[v] = true; cnt[v] = k; for (int i = 0; i &lt; rG[v].size(); i++) &#123; if (!vis[rG[v][i]]) rdfs(rG[v][i], k); &#125; vs.push_back(v); sc[k].push_back(v);&#125;void scc() &#123; memset(vis, 0, sizeof(vis)); vs.clear(); for (int i = 1; i &lt; v; i++) &#123; if (!vis[i]) dfs(i); &#125; memset(vis, 0, sizeof(vis)); int k = 0; for (int i = vs.size() - 1; i &gt;= 0; i--) &#123; if (!vis[vs[i]]) &#123; rdfs(vs[i], k++); &#125; &#125;&#125;int n, m, T;int main() &#123; // freopen(&quot;input&quot;, &quot;r&quot;, stdin); scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; memset(cnt, 0, sizeof(cnt)); vs.clear(); for (int i = 0; i &lt; maxn - 2; i++) sc[i].clear(); scanf(&quot;%d %d&quot;, &amp;n, &amp;m); v = 4 * n + 1; for (int i = 1; i &lt; v; i++) &#123; G[i].clear(), rG[i].clear(); &#125; char str[2][maxn]; for (int i = 1; i &lt;= m; i++) &#123; scanf(&quot;%s %s&quot;, str[0], str[1]); int x = 0, y = 0; for (int i = 1; i &lt; strlen(str[0]); i++) x = x * 10 + str[0][i] - &apos;0&apos;; for (int i = 1; i &lt; strlen(str[1]); i++) y = y * 10 + str[1][i] - &apos;0&apos;; if (str[0][0] == &apos;m&apos;) x = n + x; if (str[1][0] == &apos;m&apos;) y = n + y; add_edge(2 * n + y, x), add_edge(2 * n + x, y); &#125; for (int i = 1; i &lt;= n; i++) &#123; // p:i q:i+n not p:2*n+i not q:3*n+i add_edge(i, 3 * n + i), add_edge(i + n, 2 * n + i); &#125; scc(); int flag = 0; for (int i = 1; i &lt;= n; i++) &#123; if (cnt[i] == cnt[i + n]) &#123; printf(&quot;BAD\n&quot;); flag = 1; break; &#125; &#125; if (!flag) printf(&quot;GOOD\n&quot;); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1486][HNOI2009]最小圈——分数规划+spfa+负环]]></title>
      <url>%2F2017%2F02%2F22%2Fbzoj1486-HNOI2009-%E6%9C%80%E5%B0%8F%E5%9C%88%E2%80%94%E2%80%94%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92-spfa-%E8%B4%9F%E7%8E%AF%2F</url>
      <content type="text"><![CDATA[题目 传送门 #题解 这个题是一个经典的分数规划问题。 把题目形式化地表示，就是 \[Minimize\ \lambda = \frac{\sum W_{i, i+1}}{k}\] 整理一下，就是 \[\lambda * k = \sum W_{i, i+1}\] 定义新的函数 \[g(\lambda) = Min(\lambda * k - \sum W_{i, i+1})\] 显然这个函数单调，我们二分\(\lambda\)，等价于求一个负环。 如果用spfa求负环会Tle，所以学习了用dfs求负环，如代码所示。 #代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3005 * 2;#define exp 1e-10const double inf = 1000000000;int n, m;struct edge &#123; int to; double value;&#125;;vector&lt;edge&gt; G[maxn];vector&lt;edge&gt; rg[maxn];int vis[maxn];int flag;double dist[maxn];inline void spfa(int x) &#123; int i; vis[x] = false; for (i = 0; i &lt; rg[x].size(); i++) &#123; edge &amp;e = rg[x][i]; if (dist[e.to] &gt; dist[x] + e.value) if (!vis[e.to]) &#123; flag = true; break; &#125; else &#123; dist[e.to] = dist[x] + e.value; spfa(e.to); &#125; &#125; vis[x] = true;&#125;bool check(double lambda) &#123; for (int i = 1; i &lt;= n; i++) &#123; rg[i].clear(); for (int j = 0; j &lt; G[i].size(); j++) &#123; rg[i].push_back((edge)&#123;G[i][j].to, (double)G[i][j].value - lambda&#125;); &#125; &#125; memset(vis, 1, sizeof(vis)); memset(dist, 0, sizeof(dist)); flag = false; for (int i = 1; i &lt;= n; i++) &#123; spfa(i); if (flag) return true; &#125; return false;&#125;int main() &#123; // freopen(&quot;input&quot;, &quot;r&quot;, stdin); scanf(&quot;%d %d&quot;, &amp;n, &amp;m); int tot = 0; for (int i = 1; i &lt;= m; i++) &#123; int x, y; double z; scanf(&quot;%d %d %lf&quot;, &amp;x, &amp;y, &amp;z); G[x].push_back((edge)&#123;y, z&#125;); tot += z; &#125; double l = -inf, r = inf; while (l + exp &lt; r) &#123; double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; &#125; printf(&quot;%.8f&quot;, l);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3532][Sdoi2014]Lis——拆点最小割+字典序+退流]]></title>
      <url>%2F2017%2F02%2F21%2Fbzoj3532-Sdoi2014-Lis%E2%80%94%E2%80%94%E6%8B%86%E7%82%B9%E6%9C%80%E5%B0%8F%E5%89%B2-%E5%AD%97%E5%85%B8%E5%BA%8F-%E9%80%80%E6%B5%81%2F</url>
      <content type="text"><![CDATA[题目大意 给定序列A，序列中的每一项Ai有删除代价Bi和附加属性Ci。请删除若 干项，使得4的最长上升子序列长度减少至少1，且付出的代价之和最小，并输出方案。 如果有多种方案，请输出将删去项的附加属性排序之后，字典序最小的一种。 # 题解 首先我们很容易用一个\(\Theta (n^2)\)的算法求出对于每个元素的lis。 考虑以下的建图方式： 由S向f[i]==1的点连边，容量为\(\infty\)， 由f[i] = max 向 T 连边， 容量为\(\infty\), 对于每个点，拆为两个点，费用就是B[i]。 为什么这样建图是对的？原因很简单，原问题等价于在新图中找一个点集，使得s到t不再连通，这让我们联想到最小割，考虑到s，t到每个点不计入费用，所以我们设为\(\infty\)。 那么第一个问题解决了，关键是第二个问题：怎样找出字典序最小的割？ 我们这样考虑：既然是字典序最小，我们把C[i]从小到大排序，依次检查每一条边，如果在剩余网络中它不连通，那么这条边一定是原图的一个最小割，我们把这条边删除，同时从汇点开始退流。具体的，我们可以从汇点向v跑一次最大流，u向原点跑一次最大流，这样一定会退回一些流，使得这条边的影响消失。 这样我们就解决了这个问题，详细过程见（我写了4个小时的）代码。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10000;int A[maxn], B[maxn], C[maxn], f[maxn];int n, s, t, v;const int inf = 1000000010;struct edge &#123; int from; int to; int cap;&#125;;struct haha &#123; int id; int Ci;&#125; cc[maxn];inline int read() &#123; char c = getchar(); int f = 1, x = 0; while (!isdigit(c)) &#123; if (c == &apos;-&apos;) f = -1; c = getchar(); &#125; while (isdigit(c)) x = x * 10 + c - &apos;0&apos;, c = getchar(); return x * f;&#125;bool cmp(haha a, haha b) &#123; return a.Ci &lt; b.Ci; &#125;vector&lt;edge&gt; edges;vector&lt;int&gt; G[maxn];inline void add_edge(int from, int to, int cap) &#123; edges.push_back((edge)&#123;from, to, cap&#125;); edges.push_back((edge)&#123;to, from, 0&#125;); int m = edges.size(); G[from].push_back(m - 2); G[to].push_back(m - 1);&#125;inline void reaad() &#123; scanf(&quot;%d&quot;, &amp;n); s = 0, t = 2 * n + 1, v = t + 1; for (int i = 1; i &lt;= n; i++) &#123; A[i] = read(); &#125; for (int i = 0; i &lt; v; i++) G[i].clear(); edges.clear(); for (int i = 1; i &lt;= n; i++) B[i] = read(); for (int i = 1; i &lt;= n; i++) &#123; C[i] = read(); cc[i].id = i; cc[i].Ci = C[i]; &#125; for (int i = 1; i &lt;= n; i++) add_edge(i, i + n, B[i]); for (int i = 1; i &lt;= n; i++) f[i] = 1; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; if (A[j] &lt; A[i]) f[i] = max(f[i], f[j] + 1); &#125; ans = max(ans, f[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (ans == f[i]) &#123; add_edge(i + n, t, inf); &#125; if (f[i] == 1) add_edge(s, i, inf); for (int j = 1; j &lt;= n; j++) &#123; if (A[j] &lt; A[i] &amp;&amp; j &lt; i &amp;&amp; f[i] == f[j] + 1) add_edge(j + n, i, inf); &#125; &#125;&#125;int dist[maxn], iter[maxn];inline void bfs(int s) &#123; memset(dist, -1, sizeof(dist)); dist[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; edge &amp;e = edges[G[u][i]]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] == -1) &#123; dist[e.to] = dist[u] + 1; q.push(e.to); &#125; &#125; &#125;&#125;inline int dfs(int s, int t, int flow) &#123; if (s == t) return flow; for (int &amp;i = iter[s]; i &lt; G[s].size(); i++) &#123; edge &amp;e = edges[G[s][i]]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[s]) &#123; int d = dfs(e.to, t, min(e.cap, flow)); if (d &gt; 0) &#123; e.cap -= d; edges[G[s][i] ^ 1].cap += d; return d; &#125; &#125; &#125; return 0;&#125;inline int dinic(int s, int t) &#123; int flow = 0; while (1) &#123; bfs(s); if (dist[t] == -1) return flow; memset(iter, 0, sizeof(iter)); int d; while (d = dfs(s, t, inf)) flow += d; &#125; return flow;&#125;int main() &#123; // freopen(&quot;input&quot;, &quot;r&quot;, stdin); int T; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; reaad(); int ans = dinic(s, t); int tot = 0; int rec[maxn]; memset(rec, 0, sizeof(rec)); sort(cc + 1, cc + 1 + n, cmp); for (int i = 1; i &lt;= n; i++) &#123; int now = cc[i].id; int u = now, v = now + n; bfs(u); if (dist[v] != -1) continue; rec[tot++] = now; dinic(t, v); dinic(u, s); edges[(now - 1) * 2].cap = edges[(now - 1) * 2 + 1].cap = 0; &#125; sort(rec, rec + tot); printf(&quot;%d %d\n&quot;, ans, tot); for (int i = 0; i &lt; tot-1; i++) &#123; printf(&quot;%d &quot;, rec[i]); &#125; printf(&quot;%d\n&quot;, rec[tot-1]); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3876][AHOI2014]支线剧情——上下界费用流]]></title>
      <url>%2F2017%2F02%2F21%2Fbzoj3876-AHOI2014-%E6%94%AF%E7%BA%BF%E5%89%A7%E6%83%85%E2%80%94%E2%80%94%E4%B8%8A%E4%B8%8B%E7%95%8C%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
      <content type="text"><![CDATA[题目 传送门 # 题解 建立s和t，然后s向1连下限0上限inf费用0的边，除1外所有节点向t连下限0上限inf费用0的边，对于每条边下限为1上限为inf费用为经过费用，然后我们只有做上下界网络流构出新图，跑最小费用可行流即可。 变成 至于建立新图，我是这样建立的（如图） 另外推荐一篇文章：Menci的博客 # 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int inf = INT_MAX;const int maxn = 305 * 4;const int M = 10000;struct edge1 &#123; int from; int to; int low; int high; int cost;&#125;;vector&lt;edge1&gt; es;struct edge &#123; int from; int to; int cap; int cost;&#125;;vector&lt;edge&gt; edges;vector&lt;int&gt; G[maxn];inline void add_edge(int from, int to, int cap, int cost) &#123; edges.push_back((edge)&#123;from, to, cap, cost&#125;); edges.push_back((edge)&#123;to, from, 0, -cost&#125;); int m = edges.size(); G[from].push_back(m - 2); G[to].push_back(m - 1);&#125;inline int read() &#123; char c = getchar(); int f = 1, x = 0; while (!isdigit(c)) &#123; if (c == '-') f = -1; c = getchar(); &#125; while (isdigit(c)) x = x * 10 + c - '0', c = getchar(); return x * f;&#125;int n, s, t, V;void build_network() &#123; for (int i = 0; i &lt; es.size(); i++) &#123; edge1 &amp;e = es[i]; add_edge(e.from, e.to, e.high - e.low, e.cost); add_edge(e.from, e.to, e.low, e.cost - M); &#125;&#125;int dist[maxn], a[maxn], pree[maxn], inq[maxn];bool spfa(int s, int t, int &amp;cost) &#123; for (int i = 0; i &lt; V; i++) dist[i] = inf; memset(pree, 0, sizeof(pree)); memset(inq, 0, sizeof(inq)); a[s] = inf; dist[s] = 0; queue&lt;int&gt; q; q.push(s); inq[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = 0; for (int i = 0; i &lt; G[u].size(); i++) &#123; edge &amp;e = edges[G[u][i]]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123; pree[e.to] = G[u][i]; dist[e.to] = dist[u] + e.cost; a[e.to] = min(e.cap, a[u]); if (!inq[e.to]) &#123; q.push(e.to); inq[e.to] = 1; &#125; &#125; &#125; &#125; if (dist[t] &gt;= inf) return false; cost += a[t] * dist[t]; int u = t; while (u != s) &#123; edges[pree[u]].cap -= a[t]; edges[pree[u] ^ 1].cap += a[t]; u = edges[pree[u]].from; &#125; return true;&#125;int mcmf(int s, int t) &#123; int cost = 0; while (spfa(s, t, cost)) ; // cout &lt;&lt; "Hey:" &lt;&lt; cost &lt;&lt; endl; return cost;&#125;int main() &#123; // freopen("input", "r", stdin); scanf("%d", &amp;n); s = 0, t = n + 1, V = t + 1; int cnt = 0; es.push_back((edge1)&#123;s, 1, 0, inf, 0&#125;); for (int i = 1; i &lt;= n; i++) &#123; int k; k = read(); for (int j = 0; j &lt; k; j++) &#123; int a, b; a = read(); b = read(); es.push_back((edge1)&#123;i, a, 1, inf, b&#125;); cnt += 1; &#125; es.push_back((edge1)&#123;i, t, 0, inf, 0&#125;); &#125; build_network(); int ans = mcmf(s, t); printf("%d", ans + M * cnt);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2127]happiness——最小割]]></title>
      <url>%2F2017%2F02%2F21%2Fbzoj2127-happiness%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E5%89%B2%2F</url>
      <content type="text"><![CDATA[这个题太恶心了。。。并不想继续做了。。。 本代码在bzoj上TLE！ 大致说一下思路： 建立ST，首先由S连边(S,u,a)a代表学文的分数，连向T(u,T,b)b表示学理的分数，这样构造出了两个人独立的分数。 然后考虑联合分数，对于相邻的两个点xy，看下图（盗个图： 设xy都学文的分数为w1,都学理的分数为w2，则a=w1/2,b=w1/2,c=w2/2,d=w2/2,e=(w1+w2)/2，每一种割与其对应的亏损分数如下： a+b -w1 都学理-&gt;w2 c+d -w2 都学文-&gt;w1 a+d+e -w1-w2 不同-&gt; 0 c+d+e -w1-w2 ... 注意双向边e，我们是变成两条有向边加入网络，而又因为我们求最小割用的是最大流的算法，所以这条边可以看作是一条双向且权值为e的边。 然后把权值*2，解决精度问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105; /////////////////////////////////////////////const int maxv = maxn * maxn * 2;const int inf = INT_MAX;int n, m, s, t, v;struct edge &#123; int from; int to; int cap;&#125;;vector&lt;edge&gt; edges;vector&lt;int&gt; G[maxv];int dist[maxv], iter[maxv];int z[maxv][maxv];bool zz[maxv][maxv];inline int read() &#123; char c = getchar(); int f = 1, x = 0; while (!isdigit(c)) &#123; if (c == &apos;-&apos;) f = -1; c = getchar(); &#125; while (isdigit(c)) x = x * 10 + c - &apos;0&apos;, c = getchar(); return x * f;&#125;inline void add_edge(int from, int to, int cap) &#123; edges.push_back((edge)&#123;from, to, cap&#125;); edges.push_back((edge)&#123;to, from, 0&#125;); int m = edges.size(); G[from].push_back(m - 2); G[to].push_back(m - 1);&#125;inline void bfs(int s) &#123; memset(dist, -1, sizeof(dist)); dist[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; edge &amp;e = edges[G[u][i]]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] == -1) &#123; dist[e.to] = dist[u] + 1; q.push(e.to); &#125; &#125; &#125;&#125;inline int dfs(int s, int t, int flow) &#123; if (s == t) return flow; for (int &amp;i = iter[s]; i &lt; G[s].size(); i++) &#123; edge &amp;e = edges[G[s][i]]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[s]) &#123; int d = dfs(e.to, t, min(flow, e.cap)); if (d &gt; 0) &#123; e.cap -= d; edges[G[s][i] ^ 1].cap += d; return d; &#125; &#125; &#125; return 0;&#125;inline int dinic(int s, int t) &#123; int flow = 0; while (1) &#123; bfs(s); if (dist[t] == -1) return flow; memset(iter, 0, sizeof(iter)); int F; while (F = dfs(s, t, inf)) flow += F; &#125;&#125;int main() &#123; // freopen(&quot;input&quot;, &quot;r&quot;, stdin); ////////////////////////// memset(z, 0, sizeof(z)); memset(zz, 0, sizeof(zz)); scanf(&quot;%d %d&quot;, &amp;n, &amp;m); s = 0; //文科 t = n * m + 1; //理科 v = t + 1; int ans = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; int x; x = read(); x &lt;&lt;= 1; z[s][(i - 1) * m + j] += x; zz[s][(i - 1) * m + j] = 1; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; int x; x = read(); x &lt;&lt;= 1; z[(i - 1) * m + j][t] += x; zz[(i - 1) * m + j][t] = 1; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; int x; x = read(); z[(i - 1) * m + j][i * m + j] += x; z[s][(i - 1) * m + j] += x; z[s][i * m + j] += x; zz[(i - 1) * m + j][i * m + j] = 1; zz[s][(i - 1) * m + j] = 1; zz[s][i * m + j] = 1; add_edge((i - 1) * m + j, i * m + j, x); add_edge(i * m + j, (i - 1) * m + j, x); &#125; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; int x; x = read(); z[(i - 1) * m + j][i * m + j] += x; z[(i - 1) * m + j][t] += x; z[i * m + j][t] += x; zz[(i - 1) * m + j][i * m + j] = 1; zz[(i - 1) * m + j][t] = 1; zz[i * m + j][t] = 1; add_edge((i - 1) * m + j, i * m + j, x); add_edge(i * m + j, (i - 1) * m + j, x); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt; m; j++) &#123; int x; x = read(); z[(i - 1) * m + j][(i - 1) * m + j + 1] += x; z[s][(i - 1) * m + j] += x; z[s][(i - 1) * m + j + 1] += x; zz[(i - 1) * m + j][(i - 1) * m + j + 1] = 1; zz[s][(i - 1) * m + j] = 1; zz[s][(i - 1) * m + j + 1] = 1; add_edge((i - 1) * m + j, (i - 1) * m + j + 1, x); add_edge((i - 1) * m + j + 1, (i - 1) * m + j, x); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt; m; j++) &#123; int x; x = read(); z[(i - 1) * m + j][(i - 1) * m + j + 1] += x; z[(i - 1) * m + j][t] += x; z[(i - 1) * m + j + 1][t] += x; zz[(i - 1) * m + j][(i - 1) * m + j + 1] = 1; zz[(i - 1) * m + j][t] = 1; zz[(i - 1) * m + j + 1][t] = 1; add_edge((i - 1) * m + j, (i - 1) * m + j + 1, x); add_edge((i - 1) * m + j + 1, (i - 1) * m + j, x); &#125; &#125; for (int i = 1; i &lt; t; i++) &#123; ans += z[s][i]; ans += z[i][t]; if (zz[s][i]) add_edge(s, i, z[s][i]); if (zz[i][t]) add_edge(i, t, z[i][t]); &#125; for (int i = 1; i &lt; t; i++) &#123; for (int j = 1; j &lt; t; j++) &#123; if (zz[i][j]) &#123; add_edge(i, j, z[i][j]); add_edge(j, i, z[i][j]); &#125; &#125; &#125; /* for (int i = 0; i &lt; v; i++) &#123; cout &lt;&lt; &quot;For &quot; &lt;&lt; i &lt;&lt; &apos;:&apos; &lt;&lt; endl; for (int j = 0; j &lt; G[i].size(); j++) &#123; edge &amp;e = edges[G[i][j]]; if (e.cap &gt; 0) cout &lt;&lt; &quot;to &quot; &lt;&lt; e.to &lt;&lt; &quot; cap &quot; &lt;&lt; e.cap &lt;&lt; endl; &#125; &#125;*/ ans -= dinic(s, t); printf(&quot;%d\n&quot;, ans &gt;&gt; 1);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3158]千钧一发——二分图+网络流]]></title>
      <url>%2F2017%2F02%2F20%2Fbzoj3158-%E5%8D%83%E9%92%A7%E4%B8%80%E5%8F%91%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E5%9B%BE-%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
      <content type="text"><![CDATA[题目 传送门 # 题解 很容易建立模型，如果两个点不能匹配，那么连一条边，那么问题就转化为了求一个图上的最大点权独立集。 而我们可以知道： 最大点权独立集+最小点权覆盖集=总权值。 同时最小点权覆盖在一般图上是np的，但是在二分图上就是可解的。 利用一系列数学性质，可以证明A[i]与A[j]奇偶性不同是ij之间连边的充分必要条件。 详细见lidaxin的博客 那么我们可以跑一边最大流即可。 # 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn = 1005;const ll inf = 100000000000000;ll N, A[maxn], B[maxn];ll mx = 0;ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b); &#125;bool ok(ll a, ll b) &#123; ll sq = a * a + b * b; ll t = sqrt(sq); if (sq != (t * t)) return false; if (gcd(a, b) &gt; 1) return false; return true;&#125;struct edge &#123; ll from; ll to; ll cap;&#125;;vector&lt;edge&gt; edges;vector&lt;int&gt; G[maxn];ll s, t, v, ans;ll dist[maxn], iter[maxn];void add_edge(int from, int to, ll cap) &#123; edges.push_back((edge)&#123;from, to, cap&#125;); edges.push_back((edge)&#123;to, from, 0&#125;); int m = edges.size(); G[from].push_back(m - 2); G[to].push_back(m - 1);&#125;void bfs(int s) &#123; memset(dist, -1, sizeof(dist)); queue&lt;int&gt; q; q.push(s); dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; edge &amp;e = edges[G[u][i]]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] == -1) &#123; dist[e.to] = dist[u] + e.cap; q.push(e.to); &#125; &#125; &#125;&#125;ll dfs(ll s, ll t, ll flow) &#123; if (s == t) return flow; for (ll &amp;i = iter[s]; i &lt; G[s].size(); i++) &#123; edge &amp;e = edges[G[s][i]]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[s]) &#123; ll d = dfs(e.to, t, min(flow, e.cap)); if (d &gt; 0) &#123; e.cap -= d; edges[G[s][i] ^ 1].cap += d; return d; &#125; &#125; &#125; return 0;&#125;ll dinic(int s, int t) &#123; ll flow = 0; while (1) &#123; bfs(s); if (dist[t] == -1) return flow; memset(iter, 0, sizeof(iter)); ll f; while ((f = dfs(s, t, inf)) &gt; 0) flow += f; &#125;&#125;int main() &#123; // freopen("input.b", "r", stdin); ans = 0; scanf("%lld", &amp;N); for (int i = 1; i &lt;= N; i++) &#123; scanf("%lld", &amp;A[i]); &#125; for (int i = 1; i &lt;= N; i++) &#123; scanf("%lld", &amp;B[i]); ans += B[i]; &#125; // s:0, t:N+1 s = 0, t = N + 1, v = t + 1; for (int i = 1; i &lt;= N; i++) &#123; if (A[i] &amp; 1) add_edge(s, i, B[i]); else add_edge(i, t, B[i]); if (A[i] &amp; 1) for (int j = 1; j &lt;= N; j++) &#123; if (!(A[j] &amp; 1)) if (ok(A[i], A[j])) add_edge(i, j, inf); &#125; &#125; ans -= dinic(s, t); printf("%lld", ans);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2245][SDOI2011]工作安排——费用流]]></title>
      <url>%2F2017%2F02%2F20%2Fbzoj2245-SDOI2011-%E5%B7%A5%E4%BD%9C%E5%AE%89%E6%8E%92%E2%80%94%E2%80%94%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
      <content type="text"><![CDATA[题目大意： 传送门 # 题解： 很容易建模，把每一个工作人员拆成两个点，由第一个点向第二个点连S+1条边即可。 这水题没什么难度，主要是longlong卡的丧心病狂。。。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll maxn = 2550;const ll maxv = maxn * 10;const ll inf = 1000000000000;ll dist[maxv], inq[maxv], pree[maxv], fl[maxv];struct edge &#123; ll from; ll to; ll cap; ll cost;&#125;;vector&lt;edge&gt; edges;vector&lt;ll&gt; G[maxv];ll n, m, a[maxn][maxn], c[maxn], v;void add_edge(ll from, ll to, ll cap, ll cost) &#123; edges.push_back((edge)&#123;from, to, cap, cost&#125;); edges.push_back((edge)&#123;to, from, 0, -cost&#125;); ll m = edges.size(); G[from].push_back(m - 2); G[to].push_back(m - 1);&#125;bool spfa(ll s, ll t, ll &amp;cost) &#123; for (int i = 0; i &lt; v; i++) dist[i] = inf; memset(inq, 0, sizeof(inq)); memset(pree, 0, sizeof(pree)); memset(fl, 0, sizeof(fl)); queue&lt;ll&gt; q; fl[s] = inf; dist[s] = 0, inq[s] = 1; q.push(s); while (!q.empty()) &#123; ll u = q.front(); q.pop(); inq[u] = 0; for (int i = 0; i &lt; G[u].size(); i++) &#123; edge &amp;e = edges[G[u][i]]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123; dist[e.to] = dist[u] + e.cost; pree[e.to] = G[u][i]; fl[e.to] = min(fl[u], e.cap); if (!inq[e.to]) &#123; q.push(e.to); inq[e.to] = 1; &#125; &#125; &#125; &#125; if (dist[t] &gt;= inf) return false; ll flow = fl[t]; cost += flow * dist[t]; ll u = t; while (!u == s) &#123; edges[pree[u]].cap -= flow; edges[pree[u] ^ 1].cap += flow; u = edges[pree[u]].from; &#125; return true;&#125;ll mcmf(int s, int t) &#123; ll cost = 0; while (spfa(s, t, cost)) ; return cost;&#125;void solve() &#123; // 1-m：员工 // m+1~m+n 产品 // m+n+1~m+n+m 拆点后的员工 scanf("%lld %lld", &amp;m, &amp;n); ll s = 0, t = n + m + m + 1; v = t + 1; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;c[i]); add_edge(m + i, t, c[i], 0); &#125; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) &#123; int x; scanf("%d", &amp;x); if (x) add_edge(i, j + m, inf, 0); &#125; for (int i = 1; i &lt;= m; i++) &#123; add_edge(s, n + m + i, inf, 0); ll s; scanf("%lld", &amp;s); ll T[maxn]; T[0] = 0; for (int j = 1; j &lt;= s; j++) scanf("%lld", &amp;T[j]); for (int j = 1; j &lt;= s; j++) &#123; ll y; scanf("%lld", &amp;y); add_edge(n + m + i, i, T[j] - T[j - 1], y); &#125; scanf("%lld", &amp;s); add_edge(n + m + i, i, inf, s); &#125; ll ans = mcmf(s, t); printf("%lld\n", ans);&#125;int main() &#123; // freopen("input", "r", stdin); solve();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1070][SCOI2007]修车——费用流]]></title>
      <url>%2F2017%2F02%2F20%2Fbzoj1070-SCOI2007-%E4%BF%AE%E8%BD%A6%E2%80%94%E2%80%94%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
      <content type="text"><![CDATA[题目大意： 传送门 # 题解： 本题和POJ3686一题一模一样,而且还是数据缩小以后的弱化版QAQ，《挑战程序设计竞赛》一书中有详细解答，我写一下大致的解法。 我们把每个维修员拆成n个点，由每个车子向每个维修员连接n条边，分别代表是该维修员维修的第i个车子。 容易知道，如果车辆i在维修员j处是第k个修的，那么费用就一定会包括k*z[i][j]（车辆i的等待时间也包括在内）。 跑一边费用流就好辣。。 # 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int maxn = 65;const int inf = 0x3f3f3f;const int maxm = 15;const int maxv = maxn * maxm * 2;int z[maxn][maxm];int n, m, v, s, t;struct edge &#123; int from, to, cap, cost;&#125;;vector&lt;edge&gt; edges;vector&lt;int&gt; G[maxn * maxm * 2];void read() &#123; memset(z, 0, sizeof(z)); scanf("%d %d", &amp;m, &amp;n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) scanf("%d", &amp;z[i][j]);&#125;int dist[maxv], pre[maxv], a[maxv], inq[maxv];void add_edge(int s, int t, int cap, int cost) &#123; edges.push_back((edge)&#123;s, t, cap, cost&#125;); edges.push_back((edge)&#123;t, s, 0, -cost&#125;); int m = edges.size(); G[s].push_back(m - 2); G[t].push_back(m - 1);&#125;bool spfa(int s, int t, int &amp;flow, int &amp;cost) &#123; for (int i = 0; i &lt; v; i++) dist[i] = inf; memset(pre, -1, sizeof(pre)); memset(inq, 0, sizeof(inq)); queue&lt;int&gt; q; q.push(s); dist[s] = 0; inq[s] = 1; a[s] = inf; while (!q.empty()) &#123; int v = q.front(); q.pop(); inq[v] = 0; for (int i = 0; i &lt; G[v].size(); i++) &#123; edge &amp;e = edges[G[v][i]]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[v] + e.cost) &#123; a[e.to] = min(a[v], e.cap); pre[e.to] = G[v][i]; dist[e.to] = dist[v] + e.cost; if (!inq[e.to]) &#123; q.push(e.to); inq[e.to] = 1; &#125; &#125; &#125; &#125; if (dist[t] &gt;= inf) return false; flow += a[t]; cost += dist[t] * a[t]; int u = t; while (u != s) &#123; edges[pre[u]].cap -= a[t]; edges[pre[u] ^ 1].cap += a[t]; u = edges[pre[u]].from; &#125; return true;&#125;int mcmf(int s, int t) &#123; int flow = 0; int cost = 0; while (spfa(s, t, flow, cost)) ; return cost;&#125;void solve() &#123; // 0-n-1 车子 // n-2n-1 一号工作员 // 2n-3n-1 二号工作员 s = n + n * m, t = s + 1, v = t + 1; for (int i = 0; i &lt; n; i++) add_edge(s, i, 1, 0); for (int j = 0; j &lt; m; j++) &#123; for (int k = 0; k &lt; n; k++) &#123; add_edge(n + j * n + k, t, 1, 0); for (int i = 0; i &lt; n; i++) &#123; add_edge(i, n + j * n + k, 1, (k + 1) * z[i][j]); &#125; &#125; &#125; double ans = (double)mcmf(s, t) / n; printf("%.2f\n", ans);&#125;int main() &#123; read(); solve(); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1051][HAOI2006]受欢迎的牛——强连通分量]]></title>
      <url>%2F2017%2F02%2F19%2Fbzoj1051-HAOI2006-%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B%E2%80%94%E2%80%94%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%2F</url>
      <content type="text"><![CDATA[题目大意： 给定一个有向图，求能够被其他所有点访问到的点的个数。 题解： 首先，这个题我在洛谷上AC了，但是bzoj上WA，不知道为什么。 说一下解法。 首先，我们进行scc分解，可以知道， 1. 如果一个点满足条件，那么这个点所在的scc中的所有点都满足条件。 2. 至多只有一个scc满足条件。 3. 满足条件的scc出度为0。 直接使用kosaraju算法求解即可。 问题：为什么我在bzoj上会wa？求各位大佬给一组bzoj版本数据QAQ 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10010;int n, m;vector&lt;int&gt; G[maxn];vector&lt;int&gt; rG[maxn];vector&lt;int&gt; sc[maxn];int cnt[maxn];vector&lt;int&gt; vs;bool vis[maxn];void dfs(int v) &#123; vis[v] = true; for (int i = 0; i &lt; G[v].size(); i++) &#123; if (!vis[G[v][i]]) dfs(G[v][i]); &#125; vs.push_back(v);&#125;void rdfs(int v, int k) &#123; vis[v] = true; cnt[v] = k; for (int i = 0; i &lt; rG[v].size(); i++) &#123; if (!vis[rG[v][i]]) rdfs(rG[v][i], k); &#125; vs.push_back(v); sc[k].push_back(v);&#125;int scc() &#123; memset(vis, 0, sizeof(vis)); vs.clear(); for (int v = 1; v &lt;= n; v++) &#123; if (!vis[v]) dfs(v); &#125; memset(vis, 0, sizeof(vis)); int k = 0; for (int i = vs.size() - 1; i &gt;= 0; i--) &#123; if (!vis[vs[i]]) &#123; rdfs(vs[i], k++); &#125; &#125; return k;&#125;void dfs2(int k) &#123; vis[k] = 1; for (int i = 0; i &lt; rG[k].size(); i++) if (!vis[rG[k][i]]) dfs2(rG[k][i]);&#125;bool check(int i) &#123; memset(vis, 0, sizeof(vis)); dfs2(i); for (int i = 1; i &lt;= n; i++) if (!vis[i]) return 0; return 1;&#125;int main() &#123; // freopen(&quot;input&quot;, &quot;r&quot;, stdin); scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); G[a].push_back(b); rG[b].push_back(a); &#125; int k = scc(); k--; if (check(sc[k][0])) &#123; printf(&quot;%lld\n&quot;, sc[k].size()); &#125; else &#123; printf(&quot;%lld\n&quot;, 0); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj4513][SDOI2016]储能表——数位dp]]></title>
      <url>%2F2017%2F02%2F18%2Fbzoj4513-SDOI2016-%E5%82%A8%E8%83%BD%E8%A1%A8%E2%80%94%E2%80%94%E6%95%B0%E4%BD%8Ddp%2F</url>
      <content type="text"><![CDATA[题目大意 求 \[\sum_{i = 0}^{n-1}\sum_{j=0}^{m-1} max((i\ xor\ j)\ -\ k,\ 0)\ mod\ p\] 题解 首先，开始并没有看出来这是数位dp。 后来发现可以一位一位的处理，每一位可以从前一位推出，所以可以考虑数位dp。 我们把要统计的数变为二进制表示，先考虑n位二进制的数，再考虑n-1位的数……，加起来就好辣。 定义f[i][1/0][1/0][1/0]为已经考虑到了第i位，第i位是否比n（第i位）小，第i位是否比m小，是否比k小的总共分数。 定义g[i][1/0][1/0][1/0]为已经考虑到了第i位，第i位是否比n（第i位）小，第i位是否比m小，是否比k小的所有情况总数。 我们从大到小考虑每一位，可以有， g[i][aa][bb][cc] += g[i+1][a][b][c]; 如果从状态(i,a,b,c)可以转移到状态(i-1, aa, bb, cc); 对于 f[i][aa][bb][cc] += f[i+1][a][b][c] + (zz-z)*(1&lt;&lt;i)*g[i+1][a][b][c]; 前一项不必多说，后一项就是对于每一种可能都可以在前面加上1/0。 详细可以见代码。 有问题可以在评论区吐槽。。。 # 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll f[62][2][2][2], g[62][2][2][2]; //log2(10^18) = 60ll n, m, k, T, p;int main() &#123; scanf("%lld", &amp;T); while (T--) &#123; memset(f, 0, sizeof(f)); memset(g, 0, sizeof(g)); scanf("%lld %lld %lld %lld", &amp;n, &amp;m, &amp;k, &amp;p); g[61][1][1][1] = 1; for (int i = 60; i &gt;= 0; i--) &#123; int x = (n &gt;&gt; i) &amp; 1, y = (m &gt;&gt; i) &amp; 1, z = (k &gt;&gt; i) &amp; 1; for (int a = 0; a &lt; 2; a++) &#123; for (int b = 0; b &lt; 2; b++) &#123; for (int c = 0; c &lt; 2; c++) &#123; if (f[i + 1][a][b][c] || g[i + 1][a][b][c]) &#123; for (int xx = 0; xx &lt; 2; xx++) &#123; for (int yy = 0; yy &lt; 2; yy++) &#123; int zz = xx ^ yy; if ((a &amp;&amp; x &lt; xx) || (b &amp;&amp; y &lt; yy) || (c &amp;&amp; z &gt; zz)) continue; int aa = (a &amp;&amp; x == xx), bb = (b &amp; y == yy), cc = (c &amp;&amp; z == zz); g[i][aa][bb][cc] = (g[i][aa][bb][cc] + g[i + 1][a][b][c]) % p; f[i][aa][bb][cc] = (f[i][aa][bb][cc] + f[i + 1][a][b][c] + ((zz - z) + p) % p * ((1ll &lt;&lt; i) % p) % p * g[i + 1][a][b][c] % p) % p; &#125; &#125; &#125; &#125; &#125; &#125; &#125; printf("%lld\n", f[0][0][0][0]); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1026][SCOI2009]windy数——数位dp]]></title>
      <url>%2F2017%2F02%2F16%2Fbzoj1026-SCOI2009-windy%E6%95%B0%E2%80%94%E2%80%94%E6%95%B0%E4%BD%8Ddp%2F</url>
      <content type="text"><![CDATA[题目 求[a,b]中的windy数个数。 windy数指的是任意相邻两个数位上的数至少相差2的数，比如135是，134不是。 # 题解 感觉这个题比刚才做的那个简单多了。。。这个才真的应该是数位dp入门题嘛。 方程就是 \[f[i][j] = \sum f[i-1][k]\] 随便搞一搞就好辣。 # 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;algorithm&gt;#include &lt;cstdio&gt;#define ll long longusing namespace std;const int maxn = 13;ll f[maxn][maxn], a[maxn], cnt, len;void init(ll n) &#123; len = 0; while (n) &#123; a[++len] = n % 10; n /= 10; &#125;&#125;ll calc(ll x) &#123; ll ans = 0; int flag = 1; if (!x) return 0; init(x); for (int i = 1; i &lt; len; i++) for (int j = 1; j &lt; 10; j++) ans += f[i][j]; for (int j = 1; j &lt; a[len]; j++) ans += f[len][j]; for (int i = len - 1; i; i--) &#123; for (int j = 0; j &lt; a[i]; j++) if (abs(a[i + 1] - j) &gt;= 2) ans += f[i][j]; if (abs(a[i + 1] - a[i]) &lt; 2) &#123; flag = 0; break; &#125; &#125; if (flag) ans++; return ans;&#125;int main() &#123; for (int i = 0; i &lt;= 9; i++) f[1][i] = 1; for (int i = 2; i &lt;= 12; i++) &#123; for (int j = 0; j &lt;= 9; j++) &#123; for (int k = 0; k &lt;= 9; k++) &#123; if (abs(j - k) &gt;= 2) f[i][j] += f[i - 1][k]; &#125; &#125; &#125; ll x, y; scanf(&quot;%lld %lld&quot;, &amp;x, &amp;y); ll ans1 = calc(y); ll ans2 = calc(x - 1); printf(&quot;%lld&quot;, ans1 - ans2); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1833][ZJOI2010]count 数字计数——数位dp]]></title>
      <url>%2F2017%2F02%2F16%2Fbzoj1833-ZJOI2010-count-%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0%E2%80%94%E2%80%94%E6%95%B0%E4%BD%8Ddp%2F</url>
      <content type="text"><![CDATA[题目： (传送门)[http://www.lydsy.com/JudgeOnline/problem.php?id=1833] #题解： 第一次接触数位dp，真的是恶心。 首先翻阅了很多很多一维dp，因为要处理前缀0，所以根本搞不懂。 查询了dalaolidaxin的博客，又查阅了资料： 初探数位dp 才完全弄懂这个题。 具体的，我们设 f[i][j][k]为考虑所有i位数，最高位为j数，之中k的数目。 我们可以得出方程： \[f[i][j][k] = \sum f[i-1][l][k] (j!=k)\] \[f[i][j][k] = \sum f[i-1][l][k] + 10^{i-1} (j==k)\] 我们对这个方程作出解释： 前一项非常好理解，后一项的话就是前(i-1)位数共有\(10^{i-1}\)个，对于其中每一个，我们都可以在前面加k。 这样我们预处理出来了f。 然后我们考虑对于n分块计算。 以n = 4321为例。 首先统计3位及以下的数，这些数字没有限制，直接加就好。 然后统计4位数。 对于一个4位数，我们一位一位向下考虑，如果最高位&lt;k，直接加，如果=k，加上n+1 具体见代码。 #代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define ll long longconst int N = 25;struct node &#123; ll a[N]; node() &#123; memset(a, 0, sizeof(a)); &#125; ll &amp;operator[](const int &amp;x) &#123; return a[x]; &#125;&#125;;node operator+(const node &amp;x, const node &amp;y) &#123; node tmp; for (int i = 0; i &lt;= 9; i++) tmp.a[i] = x.a[i] + y.a[i]; return tmp;&#125;int len, a[N];ll pow[N];node f[N][N];void init(ll n) &#123; len = 0; while (n) &#123; a[++len] = n % 10; n /= 10; &#125; for (int i = 0; i &lt;= 9; i++) f[1][i][i] = 1; for (int i = 2; i &lt;= 14; i++) &#123; for (int j = 0; j &lt;= 9; j++) &#123; for (int k = 0; k &lt;= 9; k++) f[i][j] = f[i][j] + f[i - 1][k]; f[i][j][j] += pow[i - 1]; &#125; &#125;&#125;node calc(ll n) &#123; node ans; if (!n) return ans; memset(f, 0, sizeof(f)); init(n); //统计前len-1位 for (int i = 1; i &lt;= len - 1; i++) &#123; for (int j = 1; j &lt;= 9; j++) &#123; ans = ans + f[i][j]; &#125; &#125; //开始统计len位数 for (int i = 1; i &lt;= a[len] - 1; i++) ans = ans + f[len][i]; n %= pow[len - 1]; ans[a[len]] += n + 1; //对于每一个最高位都可以统计一发 for (int i = len - 1; i; i--) &#123; for (int j = 0; j &lt; a[i]; j++) ans = ans + f[i][j]; n %= pow[i - 1]; ans[a[i]] += n + 1; &#125; return ans;&#125;int main() &#123; pow[0] = 1; for (int i = 1; i &lt;= 14; i++) pow[i] = pow[i - 1] * 10; ll x, y; scanf(&quot;%lld %lld&quot;, &amp;x, &amp;y); node ans1 = calc(y), ans2 = calc(x - 1); for (int i = 0; i &lt;= 8; i++) printf(&quot;%lld &quot;, ans1[i] - ans2[i]); printf(&quot;%lld\n&quot;, ans1[9] - ans2[9]); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj4514][SDOI2016]数字配对——二分图]]></title>
      <url>%2F2017%2F02%2F16%2Fbzoj4514-SDOI2016-%E6%95%B0%E5%AD%97%E9%85%8D%E5%AF%B9%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[题目描述 传送门 # 题解： 这个题真的是巨坑，经过了6个WA，2个TLE，1个RE后才终于搞出来，中间都有点放弃希望了。。。 主要是一定要注意longlong！ 下面开始说明题解。 朴素的想法是： 如果两个数字可以匹配，那么连一条边，那么问题就转化成了一个图的最大边匹配。 然而，一般图的最大边匹配是NP的，所以竞赛中一定不会出。 所以，这种题目一般会满足二分图性质。 我们可以跑几组大数据，进行二分图染色，发现的确是二分图。 仔细思考就可以发现，如果我们设f[i]为i的质因数个数，那么如果i和j可以配对，他们的f值奇偶性一定不同！ 所以这个图一定是二分图。 跑一遍最小（最大）费用流就好辣。 # Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll maxn = 1e6;const ll inf = 1e15;int prime[maxn + 10], check[maxn + 10];int s, t;int n, cnt;void init() &#123; memset(check, 0, sizeof(check)); cnt = 0; for (int i = 2; i &lt;= maxn; i++) &#123; if (!check[i]) prime[cnt++] = i; for (int j = 0; j &lt; cnt; j++) &#123; if (i * prime[j] &gt; maxn) break; check[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125;const int N = 300;ll a[N], b[N], c[N];struct edge &#123; int from, to; ll cap, flow, cost;&#125;;vector&lt;ll&gt; G[N];vector&lt;edge&gt; E;void add_edge(int from, int to, ll cap, ll cost) &#123; E.push_back((edge)&#123;from, to, cap, 0, cost&#125;); E.push_back((edge)&#123;to, from, 0, 0, -cost&#125;); int m = E.size(); G[from].push_back(m - 2); G[to].push_back(m - 1);&#125;int calc(int x) &#123; int ret = 0; for (int i = 0; prime[i] &lt;= x; i++) &#123; if (x % prime[i] == 0) &#123; while (x % prime[i] == 0 &amp;&amp; x) &#123; ret++; x /= prime[i]; &#125; &#125; &#125; return ret;&#125;int pre[N];int inq[N];ll dist[N];ll fi[N];bool spfa(ll &amp;flow, ll &amp;cost) &#123; for (int i = 0; i &lt;= n + 1; i++) &#123; dist[i] = -inf; &#125; memset(inq, 0, sizeof(inq)); dist[s] = 0, inq[s] = 1, pre[s] = 0, fi[s] = inf; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = 0; for (int i = 0; i &lt; G[u].size(); i++) &#123; edge &amp;e = E[G[u][i]]; if (e.cap &gt; e.flow &amp;&amp; dist[e.to] &lt; dist[u] + e.cost) &#123; dist[e.to] = dist[u] + e.cost; pre[e.to] = G[u][i]; fi[e.to] = min(fi[u], e.cap - e.flow); if (!inq[e.to]) &#123; q.push(e.to); inq[e.to] = 1; &#125; &#125; &#125; &#125; if (dist[t] &lt;= -inf) return false; if (cost + dist[t] * fi[t] &lt; 0) &#123; ll temp = cost / (-dist[t]); //temp:还能够增加的流 flow += temp; return false; &#125; flow += fi[t]; cost += dist[t] * fi[t]; int u = t; while (u != s) &#123; E[pre[u]].flow += fi[t]; E[pre[u] ^ 1].flow -= fi[t]; u = E[pre[u]].from; &#125; return true;&#125;ll mcmf(int s, int t) &#123; ll flow = 0; ll cost = 0; while (spfa(flow, cost)) ; return flow;&#125;int main() &#123; init(); // freopen(&quot;input&quot;, &quot;r&quot;, stdin); scanf(&quot;%d&quot;, &amp;n); s = 0, t = n + 1; for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;b[i]); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;c[i]); for (int i = 1; i &lt;= n; i++) &#123; int f1 = calc(a[i]), f2; for (int j = 1; j &lt;= n; j++) &#123; f2 = calc(a[j]); if ((f1 % 2 == 1) &amp;&amp; ((f2 == f1 - 1 &amp;&amp; a[i] % a[j] == 0) || (f1 == f2 - 1 &amp;&amp; a[j] % a[i] == 0))) &#123; add_edge(i, j, inf, c[i] * c[j]); &#125; &#125; if (f1 % 2 == 1) add_edge(s, i, b[i], 0); else add_edge(i, t, b[i], 0); &#125; ll ans = mcmf(s, t); printf(&quot;%lld\n&quot;, ans);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1001][BJOI2006]狼抓兔子——最大流转最短路，平面图]]></title>
      <url>%2F2017%2F02%2F15%2Fbzoj1001-BJOI2006-%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E6%B5%81%E8%BD%AC%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%8C%E5%B9%B3%E9%9D%A2%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[题目描述： 给定一个平面图，求最小割。 # 题解： 本题是一道经典题. 周冬Orz的论文是很好的研究资料。 这道题点太多，所以直接跑dinic无疑会超时。 我们观察原图，发现原图是一个平面图。 什么是平面图呢？平面图就是可以画在平面上，边没有交错的图。 平面图有几个很吼的性质： 1. 欧拉定理（欧拉的定理真多。。):如果平面图把平面分为f个面，有n个点，m条边，那么我们有： \[f = m - n + 2\] 2. 任何一个平面图的对偶图还是一个平面图。 这里的对偶图指的是把原图中的面当作点，边还是边进行构图得到的图。 我们很容易发现，对偶图中的一个环就是原图的一个最小割。 但是，显然我们求环还是比较麻烦的。 我们考察原图性质， 如果在st中间连一条新边，显然新图还是平面图，同时会比原图多出一个面，我们称之为副面， 对于这个新图，我们构对偶图，同时令副面和最大的面一个为起点，一个为终点，显然对偶图中的最短路就是原图的一个最小割。 然后spfa解决就好辣。 本题最恶心的点在于建对偶图。 # 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = (1000 * 1000 + 50) * 2;int n, m, nm, s, t;int dist[maxn];struct edge &#123; int to, weigh;&#125;;vector&lt;edge&gt; G[maxn];void add_edge(int from, int to, int weigh) &#123; G[from].push_back((edge)&#123;to, weigh&#125;); G[to].push_back((edge)&#123;from, weigh&#125;);&#125;void spfa() &#123; queue&lt;int&gt; q; memset(dist, 127, sizeof(dist)); dist[s] = 0; q.push(s); int inq[maxn]; memset(inq, 0, sizeof(inq)); inq[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = 0; for (int i = 0; i &lt; G[u].size(); i++) &#123; edge &amp;e = G[u][i]; if (dist[e.to] &gt; dist[u] + e.weigh) &#123; dist[e.to] = dist[u] + e.weigh; if (inq[e.to] == 0) &#123; q.push(e.to); inq[e.to] = 1; &#125; &#125; &#125; &#125;&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); nm = (n * m - m - n + 1) &lt;&lt; 1; s = 0, t = nm + 1; //横向边 int x; for (int j = 1; j &lt; m; j++) &#123; scanf(&quot;%d&quot;, &amp;x); add_edge(j, t, x); &#125; for (int i = 1; i &lt; (n - 1); i++) &#123; for (int j = 1; j &lt; m; j++) &#123; scanf(&quot;%d&quot;, &amp;x); add_edge((i &lt;&lt; 1) * (m - 1) + j, ((i &lt;&lt; 1) - 1) * (m - 1) + j, x); &#125; &#125; for (int j = 1; j &lt; m; j++) &#123; scanf(&quot;%d&quot;, &amp;x); add_edge(((n &lt;&lt; 1) - 3) * (m - 1) + j, 0, x); &#125; //纵向边 for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf(&quot;%d&quot;, &amp;x); if (j == 1) add_edge(0, (i &lt;&lt; 1) * (m - 1) + m, x); else if (j == m) add_edge((i &lt;&lt; 1 | 1) * (m - 1), t, x); else add_edge((i &lt;&lt; 1) * (m - 1) + j - 1, (i &lt;&lt; 1) * (m - 1) + j + m - 1, x); &#125; &#125; //斜 for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = 1; j &lt; m; j++) &#123; scanf(&quot;%d&quot;, &amp;x); add_edge((i &lt;&lt; 1 | 1) * (m - 1) + j, (i &lt;&lt; 1) * (m - 1) + j, x); &#125; &#125; spfa(); printf(&quot;%d&quot;, dist[t]);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1433][ZJOI2009]假期的宿舍——二分图]]></title>
      <url>%2F2017%2F02%2F15%2Fbzoj1433-ZJOI2009-%E5%81%87%E6%9C%9F%E7%9A%84%E5%AE%BF%E8%88%8D%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[题目大意 传送门 #题解 显然是二分图匹配。 用一些方法建图就好了。 要注意的是： 本题有多组数据！！！ 初始化一定要注意！！！ 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 505;const int inf = 0x3f3f3f;int n;// 1~n:学生// n+1~n+k:床位int isbed[maxn], insch[maxn];int dist[maxn * 2], iter[maxn * 2];struct edge &#123; int to, cap, rev;&#125;;vector&lt;edge&gt; G[maxn];void add_edge(int from, int to, int cap) &#123; G[from].push_back((edge)&#123;to, cap, G[to].size()&#125;); G[to].push_back((edge)&#123;from, 0, G[from].size() - 1&#125;);&#125;int cnt = 0;void read() &#123; scanf(&quot;%d&quot;, &amp;n); memset(isbed, 0, sizeof(isbed)); for (int i = 0; i &lt;= 2 * n + 1; i++) &#123; G[i].clear(); &#125; cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;isbed[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;insch[i]); insch[i] = insch[i] ^ 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (isbed[i]) add_edge(i, i + n, 1); for (int j = 1; j &lt;= n; j++) &#123; int x; scanf(&quot;%d&quot;, &amp;x); if (x &amp;&amp; isbed[j]) &#123; if (!(isbed[i]) || (isbed[i] &amp;&amp; insch[i])) &#123; add_edge(i, n + j, 1); &#125; &#125; &#125; if (!(isbed[i]) || (isbed[i] &amp;&amp; insch[i])) &#123; cnt++; add_edge(0, i, 1); &#125; if (isbed[i]) add_edge(n + i, 2 * n + 1, 1); &#125;&#125;void bfs(int from) &#123; memset(dist, -1, sizeof(dist)); dist[from] = 0; queue&lt;int&gt; q; q.push(from); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; edge &amp;e = G[u][i]; if (dist[e.to] &lt; 0 &amp;&amp; e.cap &gt; 0) &#123; dist[e.to] = dist[u] + 1; q.push(e.to); &#125; &#125; &#125;&#125;int dfs(int from, int to, int f) &#123; if (from == to) return f; for (int &amp;i = iter[from]; i &lt; G[from].size(); i++) &#123; edge &amp;e = G[from][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[from]) &#123; int d = dfs(e.to, to, min(f, e.cap)); if (d &gt; 0) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0;&#125;int max_flow(int from, int to) &#123; int flow = 0; for (;;) &#123; bfs(from); if (dist[to] &lt; 0) return flow; memset(iter, 0, sizeof(iter)); int f; while ((f = dfs(from, to, inf) &gt; 0)) flow += f; &#125;&#125;int main() &#123; // freopen(&quot;input&quot;, &quot;r&quot;, stdin); int T; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; cnt = 0; read(); int ans = max_flow(0, 2 * n + 1); if (ans == cnt) printf(&quot;^_^\n&quot;); else printf(&quot;T_T\n&quot;); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1488][HNOI2009]图的同构——Polya定理]]></title>
      <url>%2F2017%2F02%2F11%2Fbzoj1488-HNOI2009-%E5%9B%BE%E7%9A%84%E5%90%8C%E6%9E%84%E2%80%94%E2%80%94Polya%E5%AE%9A%E7%90%86%2F</url>
      <content type="text"><![CDATA[题目大意 求两两互不同构的含n个点的简单图有多少种。 简单图是关联一对顶点的无向边不多于一条的不含自环的图。 a图与b图被认为是同构的是指a图的顶点经过一定的重新标号以后，a图的顶点集和边集能完全与b图一一对应。 题解 这个题是学习了Polya定理和群论以后的练手题，但是推了好久并没有推出来。。。。真的是太难辣。。。 首先我先说一下我错误的想法： 很容易就把这个题转化成了给\(K_n\)的完全图上的边进行二着色的问题，然后，由于在组合数学课程中经常接触到多边形着色，所以我就把这个题错误的转化成了在一个正\(\frac{n(n-1)}{2}\)边形的顶点上进行二着色的问题。然而对于n=1,2,3这种方法都是可行的，但是到了n=4的情况，这种方法就不可行了。我仔细观察了一下，发现这个转化不符合满足纯粹性和完备性。。。 然后就说一下正解吧。 首先我们考虑n = 4的情况，对于\(K_4\)进行二着色，我们很容易发现，由于图是可以任意扭转的，所以它的置换群实际上是一个对称群！ 那么对于点的每一个置换我们要计算对应的边的置换。 在一个置换中，考察一条边，如果这条边的两个节点位于相同的循环中，那么我们可以得出边的循环个数是点的循环个数的一半。 如果这条边的两个节点位于不同的循环中，那么我们画一画图就可以知道如果点的循环个数分别是a, b,那么边的循环个数就是gcd(a,b)。 根据这样的方法，我们就可以把点的置换转化为边的置换了。 下面的任务就是要枚举置换。 如果直接暴力，复杂度很高。 我们考虑这样的枚举（回溯）方法： 依次考虑每一种阶的循环的个数，然后暴力dfs即可。 现在假设我们已经枚举好了一个置换，那么这种置换的个数根据一些基本的排列组合知识，可以知道是： \[\frac{n!}{\prod_{i = 1}^{cnt} Val_i * Num_i !}\] 稍微解释一下这个式子。除以\(Val_i\)是因为圆形排列，除以\(Num_i\)是因为同阶循环的重复排列。 根据Polya定理，等价类的个数就是： \[l = \frac{1}{N!} * \sum 2^m\] 参考题解 事实上，这个题还有一个变态的做法： 就是上OEIS上查询通项公式。。。。 #代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;const int mod = 997;const int maxn = 1010;using namespace std;int n, cnt, ans;int two[maxn], factor[maxn], val[maxn], num[maxn];int pow(int n, int m) &#123; int ans = 1; int b = m; while(b) &#123; if(b &amp; 1) ans = (ans * n) % mod; b &gt;&gt;= 1; n = (n*n) % mod; &#125; return ans;&#125;int inv(int n) &#123; return pow(n, mod-2);&#125;int gcd(int a, int b) &#123; if(b == 0) return a; else return gcd(b, a%b) % mod;&#125;void init() &#123; factor[0] = factor[1] = two[0] = 1; for(int i = 2; i &lt;= 1000; i++) &#123; factor[i] = ((i % mod) * factor[i-1]) % mod; &#125; for(int i = 1; i &lt;= 1000; i++) &#123; two[i] = (two[i-1] * 2) % mod; &#125;&#125;void dfs(int now_num, int left) &#123; if(left == 0) &#123; int sum1 = 0, sum2 = 1; //sum1:这一种置换的循环个数 //sum2:这一种置换的个数 for(int i = 1; i &lt;= cnt; i++) &#123; sum1 += (num[i] * (num[i] - 1) / 2 * val[i]) + (val[i]/2 * num[i]); //前一部分:对于同一种循环中的不同循环的边的处理 for(int j = i + 1; j&lt;= cnt; j++) &#123; sum1 += num[i] * num[j] * gcd(val[i], val[j]); &#125; &#125; for(int i = 1; i &lt;= cnt; i++) &#123; sum2 = (sum2 * pow(val[i], num[i])%mod*factor[num[i]])%mod; &#125; sum2 = inv(sum2) * factor[n] % mod; ans = (ans + pow(2, sum1) * sum2 % mod) % mod; &#125; if(now_num &gt; left) return; dfs(now_num+1, left); //这里的dfs放到外面可以降低常数： //如果放在for循环里面，那么num数组中会多出许多0 //浪费时间。 for(int i = 1; i * now_num &lt;= left; i++) &#123; val[++cnt] = now_num, num[cnt] = i; dfs(now_num+1, left - i * now_num); cnt--; //回溯 &#125;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); init(); dfs(1, n); ans = (ans * inv(factor[n])) % mod; printf(&quot;%d&quot;, ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[摸鱼]2017英才计划冬令营游记+工坊一题解]]></title>
      <url>%2F2017%2F02%2F09%2F%E6%91%B8%E9%B1%BC-2017%E8%8B%B1%E6%89%8D%E8%AE%A1%E5%88%92%E5%86%AC%E4%BB%A4%E8%90%A5%E6%B8%B8%E8%AE%B0-%E5%B7%A5%E5%9D%8A%E4%B8%80%E9%A2%98%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[概述 本次冬令营是参加英才计划以来第一次与全国各地的计算机英才见面，感觉非常兴奋，从算法之外也认识到了竞赛以外的世界，开阔了眼界，确立了今后一年的培养目标，成为了寒假中一次非常难得的经历。 #Day -1 主要收拾了一下东西做了一些出行前的准备，还做了几个bzoj上的算法题，详细内容请见我的博客。 Day 0 报道。 报到日。 早上五点起来出门赶飞机。 中午就到了厦门，吃了点午饭，逛了一会厦门大学就去报道了。 ##破冰。 晚上没有老师，大家都玩的很棒，充分起到了破冰的目的，大家从全国各地而来，之前仅仅在网路上有过些许的交流，这一次是真正的所谓”面基“。 我们小组充分展现了\(\lambda\)符号的各种意义。 Day 1 餐品 厦门大学的饭还是非常好吃，虽然菜有些辣，但是瑕不掩瑜。 教授的报告——怎样知道你是你 这一场报告主要介绍了身份识别技术在当代的发展，其中展现了一些专家做科研的过程值得我们学习。 身份识别技术在现代有着非常重要的作用，教授主要介绍了： -指纹识别 -瞳孔识别 -etc. 参观SCSC 这个研究所主要介绍了点云技术，虽然没有听懂，但是感觉很厉害，听学长说我们的导师陈宝权教授对此领域有涉猎，我不禁动起了下一年的工作就搞这个的念头。 具体地说，点云技术就是一种建模技术，在市政工作中有着非常重要的作用。 之后我们还体验了VR，虽然感觉还没有家里的暴风魔镜效果好。 参观美亚柏科 参观之前对这个公司并没有多少了解，参观之后感觉这个公司技术还是比较强，好像又红又专？ 不过里面的一些保密技术还是非常有趣的。 Day 2 今天一天都浸在了工坊之中，把自己的全身心投身于一件事的感觉非常棒。下面我来介绍以下工坊一以及我们团队对于工坊一的工作。 ##题目 机器人寻宝。 &gt;给定一NM矩阵，其中有一些三角形或凸四边形障碍和补充能量的电池。有一机器人从起点(sx,sy)走向终点(tx,ty)，每次可以向上下左右任一方向移动一个单位，消耗一单位能量，若机器人接触电池，则获得电池中储存的能量。在过程中，若机器人走出边界、接触障碍或电量为0则失败。 ­求一条由起点到终点的路径，使得机器人在达到终点时获得尽可能多的能量值。 ##题目分析 ##对多边形障碍的处理。 ###方法一：叉乘法 ###方法二：射线法 这个方法是课堂上俞教授给我们讲的。 ###方法三：面积法 ###方法四：转角法 知乎上的相关资料 ###方法五：斜率法 很多小组都用的这个方法判多边形，但是很显然这个方法有两个缺点：* -浮点精度误差。在计算机处理图形的时候会有很大的误差。 -特殊情况判定。斜率不存在怎么办？ 综上所述，这个方法毫无优点。 ##如何初始化 简单来讲就是通过bfs来初始化，详细内容可以看我在后边附上的课件。 ##求解答案 ###第一种方法： 直接暴力辣。我们可以枚举一下就可以辣。 ###第二种方法：状态压缩动态规划 如果前面两个步骤都做到位，那这个题就是模板题辣，您随随便便设计一下状态，转移一下就写出来辣，还是非常好写的。 ###第三种方法：随机算法 这个算法的基础可以说是这次冬令营我们收获最大的地方。 开始我和HSZ大佬的意见一样： &gt;这是一个NP问题。 但是经过俞教授的讲解，我们发现可以使用随机算法求解一个近似解，由于随机算法在竞赛中不常用，所以我们都没有进行学习。 可以说，开启了一个新世界。 当然这个算法我还是不会，今后一定要找机会学习。 输出方案 方案输出非常简单，直接记录fa数组暴力回溯就好辣。 然而却调试了很长时间，发现自己是因为dp中一个条件写错了orz 总结。 这个题是一个综合了许多题目的好题。 首先通过这个题我学会了计算几何的初级方法。 其实计算几何就是计算机图形学中的一个重要部分，通过对他的学习，我感受到了计算机图形学的美感，激励我在今年的培养过程中继续学习计算机图形学的相关知识。 同时学会了gdb中watch的调试方法，具体来说就是： watch a，观察一个变量，相当于一个断点，当这个变量发生了变化我们就可以停住。 具体地，比如说： 1for(int i = 1; i &lt;= n; i++) ; 对于这段代码，如果在gdb中调用命令 1watch i &lt; 9 就可以在i等于9的时候停住。 非常好用的一个功能。 Day 3 今天进行了工坊的总结，在工坊的总结中，我们锻炼了能力，看到了其他小组的强大，同时对于工坊三非常感兴趣，想回头研究一下AI技术。 晚上进行了文艺汇演，我们”SD蒟蒻演唱团“演唱了一首”我的天空——OI版“。 下面贴上歌词。 &gt;我的天坑重制版——我的OI 词：萌新李庚辰 曲：南征北战 演唱：山东蒟蒻演唱团 在搞这OI ，I wanna say so high 再做这套模拟 ，I want new life 想要打道AC ， 却跪到了现在 再见这个dalao环绕的时代 再打一次贪心 骗分失败 再做一次动规 数组爆开 Now I wanna say HelloHello 我真的好水 HelloHello 秒开栈和队列 再来个暴力求解 却还是打不动 WA在极限数据中 在无尽的黑夜 码程序码到吐血 但是我还有梦 不放弃 不放松 在我的天坑 来英才计划的各位其实都是大神 在CF上不是红名就是橙名 随便就能单手切开那动态仙人掌 我双膝跪地 看着各位dalao远去/ 先学完记忆化再学迭代加深搜索 却发现还要学图论以及那网络流 计算机漫漫长路我们还要走很久 但请你相信 我们最终能成功 笑谈同余与取膜 搞扩展欧几里德 虽然现在是蒟蒻 慢慢会懂更多 树链剖分不会做 打个表也能凑合 我依然拥有梦 一代神犇的梦 在我的天空 Day 5 返程。 虽然有不舍，但是这是新一段旅程的开始。 附录 [1]SD蒟蒻队:AngryBirds解题报告 下载链接 [2]俞勇教授课件 下载链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2301][HAOI2011]Problem B —— 莫比乌斯反演+容斥原理]]></title>
      <url>%2F2017%2F02%2F03%2Fbzoj2301-HAOI2011-Problem-B-%E2%80%94%E2%80%94-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[题意 给定a, b, c, d, k，求出： \[\sum_{i=a}^b\sum_{j=c}^d[gcd(i, j) = k]\] 题解 为方便表述，我们设 \[calc(\alpha, \beta) = \sum_{i=1}^{\alpha}\sum_{j=1}^{\beta}[gcd(i, j) = k]\] 令\(A = \{ (x, y) | x &lt; a\}\), \(B = \{(x, y)|y &lt; c\}\)， 根据容斥原理， \[|S| = |U| - |A| - |B| + |A \cap B|\] 所以，原式就是： \[calc(b, d) - calc(a-1 ,d) - calc(b, c-1) + calc(a-1, c-1)\] 这样我们就把一个询问拆分成了四个询问，即，问题就转换成了计算\(calc(\alpha, \beta)\) 令 \[f(x) = \sum_{i=1}^b\sum_{j=1}^d[gcd(i, j) = x] \] 显然，f(x)并不方便计算，但是如果我们设 \[F(x) = \sum_{i=1}^b\sum_{j=1}^d[gcd(i, j) = \lambda， x|\lambda]\] 我们可以得出F(x)与f(x)的关系， \[F(x) = \sum_{x|d} f(d)\] F(x)就相对好计算的多，我们很容易有： \[F(x) =\lfloor \frac{b}{i}\rfloor \lfloor\frac{d}{i} \rfloor\] 但是这一点对于我这种蒟蒻来说并不显然，所以这里给出一个证明。 同样地，令\(\lambda = gcd(i, j)\)，如果\(x|\lambda\)，那么我们可以得出： 1.\(x|i\) 2.\(x|j\) 反过来证明必要性： 如果\(x|i \&amp;\&amp; x|j\)，那么x一定是i和j的公约数，所以一定有 \(x \leq \lambda\) 又因为x和\(\lambda\)都是公约数，所以\(x|\lambda\)，所以必要性得证。 所以x是i和j的公约数是数对(i, j)可以对F(x)的充分必要条件。 我们使用分步原理，首先在[1,n]中寻找x的倍数个数，然后在[1,m]里找，乘起来就可以了。 然后，根据mobius反演（《具体数学》P113 4.9 \(\phi\)函数与\(\mu\)函数）： \[f(x) =\sum_{d|x} \mu(d) F(\frac{x}{d})\] 但是这种反演形式并不适合解此题，我们采取另外一种形式： \[f(x) = \sum_{x|d} \mu(\frac{d}{x}) F(d) = \sum_{x|d}\mu(\frac{d}{x}) \lfloor \frac{n}{d} \rfloor \lfloor \frac{m}{d} \rfloor\] 由于枚举倍数显然只需要枚举到min(n, m)，所以复杂度为\(\Theta(n+m)\) 根据神犇的课件。 观察式子，我们发现： \(\lfloor \frac{n}{d} \rfloor\)的取值最多有\(2 \sqrt n\)种（约数的个数），所以如果我们枚举\(\lfloor \frac{n/m}{d} \rfloor\)的取值，只需要枚举\(2(\sqrt n + \sqrt m)\)即可，复杂度就成了\(\Theta (\sqrt n + \sqrt m)\) 对于同一个取值，\(\mu\)函数是不同的，但是属于一个区间，我们可以统一求和，维护一个前缀和即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 50005;int T, a, b, c, d, k;int mu[maxn+5], sumu[maxn+5], prime[maxn+5], check[maxn+5];int tot = 0;void get_mu() &#123; memset(check, 0, sizeof(check)); mu[1] = 1; for(int i = 2; i &lt;= maxn; i++) &#123; if(!check[i]) &#123; prime[tot++] = i; mu[i] = -1; &#125; for(int j = 0; j &lt; tot; j++) &#123; if(i * prime[j] &gt; maxn) break; check[i * prime[j]] = 1; if(i % prime[j] == 0) &#123; mu[i * prime[j]] = 0; break; &#125; else &#123; mu[i * prime[j]] = -mu[i]; &#125; &#125; &#125;&#125;void init() &#123; get_mu(); for(int i = 1; i &lt;= maxn; i++) sumu[i] = sumu[i-1] + mu[i];&#125; int calc(int n, int m) &#123; n/=k; m/=k; int ret = 0; int last; if(n &gt; m) swap(n, m); for(int i = 1; i &lt;= n; i = last + 1) &#123; last = min(n / (n/i), m / (m/i)); ret += (n / i) * (m / i) * (sumu[last] - sumu[i-1]); &#125; return ret;&#125;int main() &#123; init(); scanf(&quot;%d&quot;, &amp;T); while(T--) &#123; scanf(&quot;%d %d %d %d %d&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;k); int ans = calc(b, d) - calc(a-1, d) - calc(b, c-1) + calc(a-1, c-1); printf(&quot;%d\n&quot;, ans); &#125; return 0;&#125; 觉得自己好蠢。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Codeforces Round #395 Div.2 题解]]></title>
      <url>%2F2017%2F02%2F03%2FCodeforces-Round-395-Div-2-%E9%A2%98%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[感受 第一次参加CF的rating比赛，感觉还是非常exciting，前18分钟把AB切掉之后一直在考虑C题，结果最后还是没有想出来Orz 传送门 A 比较水的模拟，就是计算：\(\frac{z}{lcm(a,b)}\) 12345678910111213#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int n, m, z;int gcd(int n, int m) &#123; return m == 0 ? n : gcd(m, n%m);&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; z; cout &lt;&lt; (z/((ll)n*m/gcd(n, m))); return 0;&#125; B 水题。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200000;int main() &#123; int n, a[maxn]; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; if(n&amp;1)&#123; for(int i = 1; i &lt;= n; i++) &#123; if(i &amp; 1) &#123; cout &lt;&lt; a[n-i+1]; &#125; else cout &lt;&lt; a[i]; cout &lt;&lt; &apos; &apos;; &#125; &#125; else &#123; for(int i = 1; i &lt;= n/2; i++) &#123; if(i &amp; 1) cout &lt;&lt; a[n-i+1]; else cout &lt;&lt; a[i]; cout &lt;&lt; &apos; &apos;; &#125; for(int i = n/2+1; i &lt;= n; i++) &#123; if(i &amp; 1) cout &lt;&lt; a[i]; else cout &lt;&lt; a[n-i+1]; cout &lt;&lt; &apos; &apos;; &#125; &#125; return 0;&#125; C 考试的时候并没有切出来。。。 后来发现很简单。。。 ##题目大意 给出一颗树及各个点的颜色，求一个点，使得以该点为根时，其所有子树（不包括整棵树）颜色相同。 ##题解 解法1:\(O(n+m)\)：如果有一条边，其两端颜色不同，那么不难得到必然有一个点是根，分别使用dfs检查即可。 解法2:\(O(n)\)：统计所有颜色不同的边，如果有解，那么这些边一定有一个共同的端点，统计一下即可。 代码 考场tle代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100005;vector&lt;int&gt; G[maxn];int n, c[maxn];int color;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos;) &#123;if(ch == &apos;-&apos;) f = -1; ch = getchar();&#125; while(ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) &#123; x = x * 10 + ch - &apos;0&apos;; ch = getchar();&#125; return x * f;&#125;int vis[maxn];bool dfs(int x) &#123; vector&lt;int&gt;::iterator it; for(it = G[x].begin(); it != G[x].end(); it++) &#123; int &amp;v = *it; if(!vis[v]) &#123; vis[v] = 1; if(c[v] != color) return false; if(!dfs(v)) return false; &#125; &#125; return true;&#125;bool check(int x) &#123; vector&lt;int&gt;::iterator it; for(it = G[x].begin(); it != G[x].end(); it++) &#123; color = c[*it]; vis[x] = 1; if(!dfs(*it)) return false; &#125; return true;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt; n; i++) &#123; int u = read(), v = read(); G[u].push_back(v); G[v].push_back(u); &#125; set&lt;int&gt; col; for(int i = 1; i &lt;= n; i++) &#123;c[i] = read(); col.insert(c[i]);&#125; for(int i = 1; i &lt;= n; i++) &#123; if(G[i].size() &lt; col.size() - 1) continue; memset(vis, 0, sizeof(vis)); vis[i] = 1; if(check(i)) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl &lt;&lt; i; return 0; &#125; &#125; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return 0;&#125; 正解（解法2） 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define FOR(i,a,b) for (int i = (a); i &lt;= (b); i++)#define FORD(i,a,b) for (int i = (a); i &gt;= (b); i--)#define REP(i,a) FOR(i,0,(int)(a)-1)#define reset(a,b) memset(a,b,sizeof(a))#define BUG(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; x &lt;&lt; endl#define PR(x,a,b) &#123;cout &lt;&lt; #x &lt;&lt; &quot; = &quot;; FOR (_,a,b) cout &lt;&lt; x[_] &lt;&lt; &apos; &apos;; cout &lt;&lt; endl;&#125;#define CON(x) &#123;cout &lt;&lt; #x &lt;&lt; &quot; = &quot;; for(auto i:x) cout &lt;&lt; i &lt;&lt; &apos; &apos;; cout &lt;&lt; endl;&#125;#define mod 1000000007#define pi acos(-1)#define eps 0.00000001#define pb push_back#define sqr(x) (x) * (x)#define _1 first#define _2 secondint n, u, v, lis[100005], cnt[100005], tot;vector&lt;int&gt; adj[100005];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; REP (i, n - 1) &#123; cin &gt;&gt; u &gt;&gt; v; adj[v].pb(u); adj[u].pb(v); &#125; FOR (i, 1, n) cin &gt;&gt; lis[i]; FOR (i, 1, n) &#123; for (int nex: adj[i]) if (lis[i] != lis[nex]) &#123; cnt[i]++; cnt[nex]++; tot++; &#125; &#125; FOR (i, 1, n) if (cnt[i] == tot) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl &lt;&lt; i; return 0; &#125; cout &lt;&lt; &quot;NO&quot;;&#125; D 题意： 给出一些边长为odd的矩形，用最多四种颜色给矩形染色，使得相邻颜色不同。 ##题解： 首先边长为odd，那么如果两个矩形相邻，那么他们左上顶点的奇偶性*一定不同。 所以我们根据左上顶点的奇偶染色即可。 具体见代码。 ##代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAXN = 500011;int n;struct edge&#123; int sx,sy; int xx,xy;&#125;a[MAXN];inline int getint()&#123; int w=0,q=0; char c=getchar(); while((c&lt;&apos;0&apos;||c&gt;&apos;9&apos;) &amp;&amp; c!=&apos;-&apos;) c=getchar(); if(c==&apos;-&apos;) q=1,c=getchar(); while (c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;) w=w*10+c-&apos;0&apos;,c=getchar(); return q?-w:w;&#125;inline void work()&#123; n=getint(); for(int i=1;i&lt;=n;i++) &#123; a[i].xx=getint(); a[i].xy=getint(); a[i].sx=getint(); a[i].sy=getint(); a[i].xx=abs(a[i].xx); a[i].xy=abs(a[i].xy); &#125; printf(&quot;YES\n&quot;); for(int i=1;i&lt;=n;i++) &#123; if(a[i].xx%2==1 &amp;&amp; a[i].xy%2==1) printf(&quot;1&quot;); else if(a[i].xx%2==1 &amp;&amp; a[i].xy%2==0) printf(&quot;2&quot;); else if(a[i].xx%2==0 &amp;&amp; a[i].xy%2==1) printf(&quot;3&quot;); else printf(&quot;4&quot;); printf(&quot;\n&quot;); &#125;&#125;int main()&#123; work(); return 0;&#125; E 不会做。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[hdu1695] GCD ——欧拉函数+容斥原理]]></title>
      <url>%2F2017%2F02%2F01%2Fhdu1695-GCD-%E2%80%94%E2%80%94%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[题目 给定两个区间[1, b], [1, d]，统计数对的个数(x, y)满足： 1. \(x \in [1, b]\), \(y \in [1, d]\) ; 2. \(gcd(x, y) = k\) HDU1695 题解 我们观察式子\(gcd(x,y)=k\) 很显然，\(gcd(x/k, y/k) = 1\) 我们令b &lt; d，令x&lt;y（避免重复计数） 分类讨论。 1) y &lt; b 可以看出答案就是\(\sum_{i \in [1, b]} \phi(i)\) 2)\(y \in [b, d]\) 可以看出答案就是calc(b, i)，calc函数就是在区间[1,b]中与i互素的个数。 怎么计算calc函数呢？ 首先我们计算出i的因数，运用容斥原理。 \[| \overline{A_1} \cap \overline {A_2} ... \cap \overline{A_n}| = | S | - |A_1| - |A_2| ... + |A_1 \cap A_2| ....\] 具体计算见代码。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn = 100000;int prime[maxn+5], phi[maxn+5], check[maxn+5];int T, a, b, c, d, k;int cnt = 0;void get_phi(int n) &#123; memset(check, 0, sizeof(check)); cnt = 0; phi[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; if(!check[i]) &#123; phi[i] = i-1; prime[cnt++] = i; &#125; for(int j = 0; j &lt; cnt; j++) &#123; if(i * prime[j] &gt; n) break; check[i*prime[j]] = 1; if(i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else &#123; phi[i * prime[j]] = phi[i] * (prime[j] - 1); &#125; &#125; &#125;&#125;ll factor[maxn];int ct = 0;void get_factor(int x) &#123; ct = 0; ll tmp = x; for(int i = 0; prime[i] * prime[i] &lt;= x; i++) &#123; if(tmp % prime[i] == 0) &#123; factor[ct] = prime[i]; while(tmp % prime[i] == 0) &#123; tmp /= prime[i]; &#125; ct++; &#125; &#125; if(tmp != 1) factor[ct++] = tmp;&#125; int calc(int n, int m) &#123; get_factor(m); int ans = 0; for(int i = 1; i &lt; (1 &lt;&lt; ct); i++) &#123; int cnt = 0; int tmp = 1; for(int j = 0; j &lt; ct; j++) &#123; if(i &amp; (1 &lt;&lt; j)) &#123; cnt++; tmp *= factor[j]; &#125; &#125; if(cnt &amp; 1) ans += n / tmp; else ans -= n/tmp; &#125; return n - ans;&#125;int main() &#123; //freopen(&quot;input&quot;, &quot;r&quot;, stdin); scanf(&quot;%d&quot;, &amp;T); get_phi(maxn); int kase = 0; while(T--) &#123; kase++; scanf(&quot;%d %d %d %d %d&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;k); if((k == 0) | (k &gt; b) | (k &gt; d)) &#123; printf(&quot;Case %d: 0\n&quot;, kase); continue; &#125; if(b &gt; d) swap(b, d); b /= k; d /= k; ll ans = 0; for(int i = 1; i &lt;= b; i++) ans += phi[i]; for(int i = b+1; i &lt;= d; i++) ans += calc(b, i); printf(&quot;Case %d: %lld\n&quot;, kase, ans); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[poj2356]--Find a multiple ——鸽巢原理]]></title>
      <url>%2F2017%2F02%2F01%2Fpoj2356-Find-a-multiple-%E2%80%94%E2%80%94%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[题意： 给定n个数，从中选取m个数，使得\(\sum | n\)。本题使用Special Judge. 题解： 既然使用special judge，我们可以直接构造答案。 首先构造在mod N剩余系下的前缀和。 \[sum_i = (a_i + sum_{i-1}) mod n\] 剩余系N的完系中显然共有N-1个元素，我们有N个前缀和。 根据鸽巢原理，一定有\(sum_j = sum_i\) 所以这样构造是可行的。 TRICK 具体实现的时候用了一个技巧： 从前往后扫描sum数组，记录一个pos数组，这样就可以把时间复杂度降到了\(\Theta (n)\) 代码 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 10005;int N, a[maxn], sum[maxn], pos[maxn];int main() &#123; scanf(&quot;%d&quot;, &amp;N); memset(pos, -1, sizeof(pos)); for(int i = 1; i &lt;= N; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); sum[i] = (a[i] + sum[i-1]) % N; &#125; pos[0] = 0; for(int i = 1; i &lt;= N; i++) &#123; if(pos[sum[i]] == -1) &#123; pos[sum[i]] = i; &#125; else &#123; printf(&quot;%d\n&quot;, i-pos[sum[i]]); for(int j = pos[sum[i]]+1; j &lt;= i; j++) &#123; printf(&quot;%d\n&quot;, a[j]); &#125; return 0; &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2190][SDOI2008]仪仗队 ——欧拉函数]]></title>
      <url>%2F2017%2F01%2F25%2Fbzoj2190-SDOI2008-%E4%BB%AA%E4%BB%97%E9%98%9F-%E2%80%94%E2%80%94%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题解 以c点为(0, 0)建立坐标系，可以发现， 当(x,y)!=1，即x，y不互素时，(x,y)点一定会被点(x/n, y/n)遮挡。 所以点(x, y)被看到的充分必要条件是Gcd(x, y) == 1; 我们考察矩阵的下三角形，考察他的每一行，可以发现，这一行能够被看到的点的数目就是\(\phi(x)\)。 答案不难发现是\(\sum(\phi[x]) * 2 + 1\)（容斥原理） 代码 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e4+10;int n, phi[maxn];void get_phi(int n) &#123; phi[1] = 1; for(int i = 2; i &lt;= n; i++) if(!phi[i]) &#123; for(int j = i; j &lt;= n; j += i) &#123; if(!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i-1); &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;n); get_phi(n); int ans = 0; for(int i = 1; i &lt; n; i++) ans += phi[i]; printf("%d", ans * 2 + 1); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2111][ZJOI2010]Perm 排列计数 ——问题转换，建立数学模型]]></title>
      <url>%2F2017%2F01%2F25%2Fbzoj2111-ZJOI2010-Perm-%E6%8E%92%E5%88%97%E8%AE%A1%E6%95%B0-%E2%80%94%E2%80%94%E9%97%AE%E9%A2%98%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%BB%BA%E7%AB%8B%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[题目大意 称一个1,2,…,N的排列P1,P2…,Pn是Magic的，当且仅当2&lt;=i&lt;=N时，Pi&gt;Pi/2. 计算1，2，…N的排列中有多少是Magic的，答案可能很大，只能输出模P以后的值。 #题解 1) 问题转换，建立模型。 可以发现，本题就是要求小根完全二叉树的个数。 2) 树上dp 定义f[n]为以n为根的完全二叉树个数。 根据乘法原理， f[n] = f[i&lt;&lt;1] * f[i&lt;&lt;1|1] * C(s[i]-1, i &lt;&lt; 1) 可以知道，n可以从后向前递推。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e6+5;#define ll long longint n, p;int f[maxn], s[maxn];int fact[maxn], ifact[maxn];int pow(int a, int b, int p) &#123; int ans = 1; while(b) &#123; if(b &amp; 1) ans = (ll) ans * a % p; b &gt;&gt;= 1; a = (ll)a * a %p; &#125; return ans;&#125;int inv(int n, int p) &#123; return pow(n, p-2, p);&#125;void init() &#123; fact[1] = 1; ifact[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; fact[i] = (ll)i * fact[i-1] % p; ifact[i] = inv(fact[i], p); &#125;&#125;int C(int n, int m, int p) &#123; if(n &lt; m) return 0; return (ll)fact[n] * ifact[m] % p * ifact[n-m] % p;&#125;int lucas(int n, int m, int p) &#123; if(!n &amp;&amp; !m) return 1; return (ll)C(n%p, m%p, p) * lucas(n/p, m/p, p) % p;&#125;int main() &#123; ifact[0] = 1; scanf(&quot;%d %d&quot;, &amp;n, &amp;p); init(); for(int i = n; i; i--) &#123; s[i] = s[i&lt;&lt;1] + s[i &lt;&lt; 1|1] + 1; f[i] = lucas(s[i]-1, s[i&lt;&lt;1], p); if(i &lt;&lt; 1 &lt;= n) f[i] = (ll)f[i] * f[i&lt;&lt;1] % p; if((i &lt;&lt; 1 | 1) &lt;= n) f[i] = (ll)f[i] * f[i&lt;&lt;1|1] % p; &#125; printf(&quot;%d&quot;, f[1]);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj3122][SDOI2013]随机数生成器 ——BSGS，数列]]></title>
      <url>%2F2017%2F01%2F25%2Fbzoj3122-SDOI2013-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8-%E2%80%94%E2%80%94BSGS%EF%BC%8C%E6%95%B0%E5%88%97%2F</url>
      <content type="text"><![CDATA[题目大意 给定递推序列： F[i] = a*F[i-1] + b (mod c) 求一个最小的i使得F[i] == t 题解 我们首先要化简这个数列，作为一个学渣，我查阅了一些资料： http://d.g.wanfangdata.com.cn/Periodical_cczl200924107.aspx http://wenku.baidu.com/view/7162471b650e52ea5518982d.html 推一下，就有： \[ a_{n+1}=ba_n+c\\ a_{n+1}+\frac{c}{b-1}=ba_n+c+\frac{c }{ b-1}=b(a_n+\frac{c}{b-1})\\ a_{n+1}+\frac c{b-1}=b^{n-1}(a_1+\frac c{b-1}) \] \[F[i] = (F[1] + \frac{b}{a-1}) * a^{i-1} - \frac{b}{a-1}\] 令F[i] = t; 可以知道: a^(i-1) = (t+b/(a-1)) / (x1+b/(a-1)) 对于这个式子，我们直接调用BSGS算法求解即可。 特别的，某些情况需要特判。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll p, a, b, X1, t, T;ll pow(ll a, ll b, ll p) &#123; ll ans = 1; while(b) &#123; if(b &amp; 1) ans = ans * a % p; b &gt;&gt;= 1; a = a * a % p; &#125; return ans;&#125;ll inv(ll a, ll p) &#123; return pow(a, p-2, p);&#125;map&lt;ll, ll&gt; mp;ll BSGS(ll A, ll B, ll C) &#123; mp.clear(); if(A % C == 0) return -2; ll m = ceil(sqrt(C)); ll ans; for(int i = 0; i &lt;= m; i++) &#123; if(i == 0) &#123; ans = B % C; mp[ans] = i; continue; &#125; ans = (ans * A) % C; mp[ans] = i; &#125; ll t = pow(A, m, C); ans = t; for(int i = 1; i &lt;= m; i++) &#123; if(i != 1)ans = ans * t % C; if(mp.count(ans)) &#123; int ret = i * m % C - mp[ans] % C; return (ret % C + C)%C; &#125; &#125; return -2;&#125; int main() &#123; // freopen("input", "r", stdin); scanf("%lld", &amp;T); while(T--) &#123; scanf("%lld %lld %lld %lld %lld", &amp;p, &amp;a, &amp;b, &amp;X1, &amp;t); if(X1 == t) &#123; printf("%d\n", 1); continue; &#125; if(a == 0) &#123; if(t == b) &#123; printf("%d\n", 2); &#125; else printf("%d\n", -1); continue; &#125; if(a == 1) &#123; if(b == 0) &#123; printf("%d\n", -1); continue; &#125; ll ans = (((t-X1)%p + p)%p * inv(b, p)) % p; printf("%lld\n", ans+1); continue; &#125; X1 %= p, a %= p, b %= p, t%= p; ll tmp = (b%p * inv(a-1, p))%p; ll B = ((t+tmp)%p * inv((X1+tmp) % p, p)) % p; ll A = a; ll ans = BSGS(A, B, p); printf("%lld\n", ans+1); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[模板]大步小步算法——BSGS算法]]></title>
      <url>%2F2017%2F01%2F25%2F%E6%A8%A1%E6%9D%BF-%E5%A4%A7%E6%AD%A5%E5%B0%8F%E6%AD%A5%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94BSGS%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[大步小步算法用于解决：已知A, B, C，求X使得 A^x = B (mod C) 成立。 我们令x = im - j | m = ceil(sqrt(C))， i = [1, m]， j = [0, m] 那么原式就变成了： A^(im) = A^j * B 我们先枚举j，把A^j * B加入哈希表 然后枚举i，在表中查照A^(i*m)，如果找到了，那么就找到了一个解。 算法的复杂度为O(n^0.5) 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll p, a, b, X1, t, T;ll pow(ll a, ll b, ll p) &#123; ll ans = 1; while(b) &#123; if(b &amp; 1) ans = ans * a % p; b &gt;&gt;= 1; a = a * a % p; &#125; return ans;&#125;ll inv(ll a, ll p) &#123; return pow(a, p-2, p);&#125;map&lt;ll, ll&gt; mp;ll BSGS(ll A, ll B, ll C) &#123; mp.clear(); if(A % C == 0) return -2; ll m = ceil(sqrt(C)); ll ans; for(int i = 0; i &lt;= m; i++) &#123; if(i == 0) &#123; ans = B % C; mp[ans] = i; continue; &#125; ans = (ans * A) % C; mp[ans] = i; &#125; ll t = pow(A, m, C); ans = t; for(int i = 1; i &lt;= m; i++) &#123; if(i != 1)ans = ans * t % C; if(mp.count(ans)) &#123; int ret = i * m % C - mp[ans] % C; return (ret % C + C)%C; &#125; &#125; return -2;&#125; int main() &#123; // freopen(&quot;input&quot;, &quot;r&quot;, stdin); scanf(&quot;%lld&quot;, &amp;T); while(T--) &#123; scanf(&quot;%lld %lld %lld %lld %lld&quot;, &amp;p, &amp;a, &amp;b, &amp;X1, &amp;t); if(X1 == t) &#123; printf(&quot;%d\n&quot;, 1); continue; &#125; if(a == 0) &#123; if(t == b) &#123; printf(&quot;%d\n&quot;, 2); &#125; else printf(&quot;%d\n&quot;, -1); continue; &#125; if(a == 1) &#123; if(b == 0) &#123; printf(&quot;%d\n&quot;, -1); continue; &#125; ll ans = (((t-X1)%p + p)%p * inv(b, p)) % p; printf(&quot;%lld\n&quot;, ans+1); continue; &#125; X1 %= p, a %= p, b %= p, t%= p; ll tmp = (b%p * inv(a-1, p))%p; ll B = ((t+tmp)%p * inv((X1+tmp) % p, p)) % p; ll A = a; ll ans = BSGS(A, B, p); printf(&quot;%lld\n&quot;, ans+1); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2726][SDOI2012]任务安排 ——斜率优化，动态规划，二分，代价提前计算]]></title>
      <url>%2F2017%2F01%2F24%2Fbzoj2726-SDOI2012-%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92-%E2%80%94%E2%80%94%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E4%BA%8C%E5%88%86%EF%BC%8C%E4%BB%A3%E4%BB%B7%E6%8F%90%E5%89%8D%E8%AE%A1%E7%AE%97%2F</url>
      <content type="text"><![CDATA[题目 机器上有N个需要处理的任务，它们构成了一个序列。这些任务被标号为1到N，因此序列的排列为1,2,3…N。这N个任务被分成若干批，每批包含相邻的若干任务。从时刻0开始，这些任务被分批加工，第i个任务单独完成所需的时间是Ti。在每批任务开始前，机器需要启动时间S，而完成这批任务所需的时间是各个任务需要时间的总和。注意，同一批任务将在同一时刻完成。每个任务的费用是它的完成时刻乘以一个费用系数Fi。请确定一个分组方案，使得总费用最小。 # 题解 本题的状态很容易设计： f[i] 为到第i个物件的最小代价。 但是方程不容易设计，因为有“后效性” 有两种方法解决： 1. 倒过来设计动态规划，典型的，可以设计这样的方程： dp(i) = min( dp(j) + F(i) * (T(i) - T(j) + S) ) (i &lt; j &lt;= N) F, T均为后缀和. 可以参考这篇博客 http://www.cnblogs.com/JSZX11556/p/5184251.html) 2. 提前计算代价，典型的，可以设计这样的方程： &gt;设f[i]为将前i个任务划分完成的最小费用，Ti Fi分别表示t和f的前缀和，则不难写出转移方程式：\[f[i]=min_j f[j]+(F[n]-F[j])*(T[i]-T[j]+s) ,1\leqslant j \leqslant i-1\] 这里我采用了第二种方法，设计这样的方程： f[i] = min{f[j] + S * (F[n]-F[j]) + T[i]*(F[i]-F[j]) } 其中，F,T均是前缀和。 这是一个(1D/1D)的方程，我们如果直接求解，O(n2)的复杂度，不能满足要求。 对于一个（1D/1D）的方程，一般采用斜率优化或者四边形不等式进行优化转移。我们考虑斜率优化。 令k &lt; j &lt; i ，如果j优于k，我们有： f[k] - S * F[k] - T[i]F[k] &gt; f[i] - S F[j] - TiF[j] 进一步整理， f[j]-f[k]+SF[k]-SF[j] &lt; T[i](F[j] - F[k])， 考虑到F是前缀和，并且F没有负值，所以F[x]函数严格单调递增，F[j]-F[k] &gt; 0, 我们两边同时除以(F[j]-F[k])， \[ \frac{f_j-f_k}{F_j-F_k} - S &lt; T_i\] 假设T[x]是单调的，我们可以直接通过单调队列转移，复杂度O(1)，总复杂度O(n)。 但是这个题防AC的一个点是：T可以是负数，所以T[i]并不单调。 所以我们可以使用二分查找，付出O(logn)的时间复杂度，对于本题而言可以接受。 // 另外，听说本题还有使用“CDQ分治”解答的方法 所以我们就使用O(nlogn)的时间解决了这个问题。 代码 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6+5;#define ll long longll T[maxn], F[maxn], f[maxn];int N, S;int head, tail, q[maxn];void dp() &#123; head = tail = 0; for(int i = 1; i &lt;= N; i++) &#123; int l = 0, r = tail; while(l &lt; r) &#123; ll mid = (l+r)/2; if((ll)(f[q[mid+1]]-f[q[mid]]) &gt;= (ll)(T[i]+S) * (F[q[mid+1]]-F[q[mid]])) r = mid; else l = mid+1; &#125; int j = q[l]; f[i] = f[j] + S*(F[N]-F[j])+T[i]*(F[i]-F[j]); while(head &lt; tail &amp;&amp; (ll)(f[q[tail]]-f[q[tail-1]])*(F[i]-F[q[tail]]) &gt;= (ll)(f[i]-f[q[tail]])*(F[q[tail]]-F[q[tail-1]])) tail--; q[++tail] = i; &#125;&#125;int main() &#123; //freopen("input", "r", stdin); scanf("%d %d", &amp;N, &amp;S); for(int i = 1; i &lt;= N; i++) &#123; scanf("%lld %lld", &amp;T[i], &amp;F[i]); T[i] += T[i-1]; F[i] += F[i-1]; &#125; dp(); printf("%lld", f[N]); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj4517][SDOI2016]排列计数]]></title>
      <url>%2F2017%2F01%2F24%2Fbzoj4517-SDOI2016-%E6%8E%92%E5%88%97%E8%AE%A1%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题目大意 计算C(n,m) * D(n-m) 其中D(x)为错位排列 # 题目解答 没有什么好说的，注意细节。 # 代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;const int P = 1e9+7;const int maxn = 1e7+1;#define ll long longint D[maxn+10], fact[maxn+10];int pow(int x, int y) &#123; int ans = 1; while(y) &#123; if(y &amp; 1) ans = (ll) ans * x % P; x = (ll) x * x % P; y &gt;&gt;= 1; &#125; return ans;&#125;int inv(int n) &#123; return pow(n, P-2);&#125;int C(int n, int m) &#123; return (ll)fact[n] * inv(fact[n-m]) % P * (ll) inv(fact[m]) % P;&#125;int main() &#123; D[0] = D[2] = 1; for(int i = 3; i &lt; maxn; i++) D[i] = (ll)(i-1)*(D[i-1]+D[i-2])%P; fact[0]= 1; for(int i = 1; i &lt; maxn; i++) fact[i] = (ll)fact[i-1]*i%P; int T; scanf("%d", &amp;T); while(T--) &#123; int n, m; scanf("%d %d", &amp;n, &amp;m); printf("%lld\n", (ll)D[n-m] * C(n, m) % P); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1951][SDOI2010]古代猪文]]></title>
      <url>%2F2017%2F01%2F24%2Fbzoj1951-SDOI2010-%E5%8F%A4%E4%BB%A3%E7%8C%AA%E6%96%87%2F</url>
      <content type="text"><![CDATA[题目描述: 计算\(G^{\sum_{i|n} C(n,i)} \% P\) #题目解答： 为叙述方便起见，我们令sigma()为W 显然W是一个非常大的数，如果暴力直接计算不是明智的选择。 我们这里使用费马小定理： 对于一个素数p： \[a^{p-1} = 1 | (a, p) = 1\] 对于G^W, 确定一个常数k，有W = k * (p-1) + M 所以\(G^W = G^{k*(p-1)} * G^M\) 显然GW就等于GM，所以问题就变成了求出组合数C(n,i)%(P-1)的值。 计算组合数的时候，有两种方法： 1) 暴力。因为组合数公式中有阶乘，所以用O(n)的时间暴力求 2) 用空间换时间，预处理出fact(n). 显然，如果直接算，我们需要预处理出1000000000这么多的fact，空间不允许。 所以我们介绍lucas定理： \[C(n, m, p) = C(\frac{n}{p}, \frac{m}{p}, p) * C(n \% p, m \% p, p)\] 这样我们就有了高效的方法求组合数。 但是lucas定理的应用有一个局限：p必须是素数。 我们观察到：p-1并不是一个素数。 这里介绍一个分解因数的软件:在linux下直接调用factor就可以分解因数，非常的方便，而且在NOI Linux中会预装此软件。 分解因数，我们就可以应用中国剩余定理来合并线性方程。 这里给出中国剩余定理： \[ \begin{eqnarray} \left\{ \begin{array}{lll} x = a_1 (mod b_1) \\ x = a_2 (mod b_2)\\ ......\\ x = a_n (mod b_n) \end{array} \right. \end{eqnarray} \] 那么，对于\(\prod(b_i)\)的剩余系 \[x = \sum a_i * (\frac{\prod(b_i)}{b_i}) * inv(\frac{\prod(b_i)}{b_i}, b_i)\] 其中，inv()为逆元，可以使用费马小定理求解（条件：P为素数） 这样我们就解决了这个问题。 这个问题有一个陷阱： 当G == P时，(G, P) = 1, 费马小定理或者说欧拉定理在这里不适用，所以我们应该进行特判。 另外，在数论程序编写时要特别注意模与乘法的问题。 比如：x = a * b 最好写成： (x = (ll) a * b % p) %= p 比较保险。 下面给出代码。 #代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int P0=999911659;const int P1=999911658; int G, N, M[4]; int t[4] = &#123;35617, 4679, 3, 2&#125;;int fac[66666];int pow(int a, int b, int p) &#123; //calc a^b % p int ans = 1; for(int i = b; i; i &gt;&gt;= 1, a = (ll)a*a%p) &#123; if(i &amp; 1) ans = (ll)ans * a % p; &#125; return ans;&#125;/*int pow(int x, int y, int P) &#123; int ret = 1; while(y) &#123; if(y&amp;1) ret = (ll)ret * x % P; x = (ll)x*x%P; y &gt;&gt;= 1; &#125; return ret;&#125;*/int inv(int x, int P)&#123;return pow(x, P-2, P);&#125;int C(int n, int m, int P) &#123; //calc (n, m) % t[x] if (n &lt; m) return 0; return (ll)fac[n] * inv(fac[n-m], P) % P * inv(fac[m], P)%P;&#125;int lucas(int n, int m, int P) &#123; if(!n &amp;&amp; !m) return 1; return (ll)lucas(n/P, m/P, P) * C(n%P, m%P, P) % P;&#125;int main() &#123; scanf(&quot;%d %d&quot;, &amp;N, &amp;G); if(G == P0) &#123; puts(&quot;0&quot;); return 0; &#125; for(int i = fac[0]=1; i &lt;= t[0]; i++) fac[i] = (ll)fac[i-1]*i % P1; int tot = 0; for(int k = 0; k &lt; 4; k++) &#123; int now = 0; for(int i = 1; i * i &lt;= N; i++) &#123; if(N % i == 0) &#123; (now += lucas(N, i, t[k])) %= t[k]; if(N / i != i) &#123; (now += lucas(N, N/i, t[k])) %= t[k]; &#125; &#125;&#125; (tot += (ll)now * (P1/t[k]) % P1 * inv(P1/t[k], t[k]) % P1) %= P1; &#125; printf(&quot;%d\n&quot;, pow(G, tot, P0)); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1057][ZJOI2007]棋盘制作]]></title>
      <url>%2F2017%2F01%2F22%2Fbzoj1057-ZJOI2007-%E6%A3%8B%E7%9B%98%E5%88%B6%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[Brief Description 国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源 于易经的思想，棋盘是一个8*8大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。而我们的主人公小Q， 正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友小W决定 将棋盘扩大以适应他们的新规则。小Q找到了一张由N*M个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种 颜色之一。小Q想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。不过小Q还没有决定是找 一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他 希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。于是小Q找到了即将参加全 国信息学竞赛的你，你能帮助他么？ Algorithm Design 本题有多种解法，我选择了单调栈进行解答。 首先进行一个巧妙的问题转换： 将所有i+j为奇数的格子反转， 这样，问题就转换成了求一个最大的0/1子矩阵。 先考虑一维的情况，h[i]表示以i为终点的最长连续0的长度，有h[i]=a[i]==0? h[i-1]+1:0,这样可以O（n）轻松求出。 拓展到高维，首先同样按照一维的方法，h[i][j]表示第i行以j为终点的最长连续0的长度，预处理出h[]。。接下来考虑一列一列来更新答案，对于单独的一列i，若以h[i][j]为子矩阵的一个边长，则它能往上下扩展的最大长度len就是另一个边长，所谓扩展就是向一个方向扫描知道碰到h值比自己小位置。 如果暴力扩展，复杂度就是O(n3)不能满足要求。 实际上，我们想要扩展，只是想要得到这样一个信息： 对于行i，其分别能够向上/向下扩展多少行？ 只要我们知道这个信息，结合h[i]就可以求出一个矩形用于更新答案了。 我们考察单调栈： 对于一个新元素，如果比栈顶元素h小，说明这个元素就是扩展的下界，马上弹出栈顶元素进行计算即可。 当一个新元素插入栈时，容易知道，新元素一定比栈顶元素大，那么栈顶元素就是他的上界，这样我们就得到了上界。 具体实现上，我直接使用了stl。 下面上代码。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2005;int n, m;struct node &#123; int x, y, left; const bool operator &gt; (const node b) &#123; return this-&gt;left &gt; b.left; &#125;&#125;;stack&lt;node&gt; s;int c[maxn][maxn], x[maxn][maxn], y[maxn][maxn], up[maxn];int ans1 = 0, ans2 = 0;void solve1() &#123; for(int j = 1; j &lt;= m; j++) &#123; memset(up, -1, sizeof(up)); for(int i = 1; i &lt;= n; i++) &#123; node a = (node)&#123;i, j, x[i][j]&#125;; node b =(node)&#123;0, j, 0&#125;; if(!s.empty())&#123; b = s.top(); while(b &gt; a) &#123; s.pop(); ans2 = max(ans2, (a.x - up[b.x]) * b.left); ans1 = max(ans1, min(b.left, a.x - up[b.x]) * min(b.left, a.x-up[b.x])); if(s.empty())&#123; b = (node)&#123;0, j, 0&#125;; break; &#125; b = s.top(); &#125; &#125; up[a.x] = b.x+1; s.push(a); &#125; while(!s.empty()) &#123; node a = s.top(); s.pop(); ans2 = max(ans2, (n+1 - up[a.x]) * a.left); ans1 = max(ans1, min(a.left, n - up[a.x] + 1) * min(a.left, n-up[a.x]+1)); &#125; &#125;&#125;void solve2() &#123; for(int j = 1; j &lt;= m; j++) &#123; memset(up, -1, sizeof(up)); for(int i = 1; i &lt;= n; i++) &#123; node a = (node)&#123;i, j, y[i][j]&#125;; node b =(node)&#123;0, j, 0&#125;; if(!s.empty())&#123; b = s.top(); while(b &gt; a) &#123; s.pop(); ans2 = max(ans2, (a.x - up[b.x]) * b.left); ans1 = max(ans1, min(b.left, a.x - up[b.x]) * min(b.left, a.x-up[b.x])); if(s.empty())&#123; b = (node)&#123;0, j, 0&#125;; break; &#125; b = s.top(); &#125; &#125; up[a.x] = b.x+1; s.push(a); &#125; while(!s.empty()) &#123; node a = s.top(); s.pop(); ans2 = max(ans2, (n - up[a.x] + 1) * a.left); ans1 = max(ans1, (min(a.left, (n-up[a.x]+1)) * min(a.left, (n-up[a.x]+1)))); &#125; &#125;&#125;int main() &#123; //freopen(&quot;input&quot;, &quot;r&quot;, stdin); scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; scanf(&quot;%d&quot;, &amp;c[i][j]); if((i+j)%2==1) &#123; c[i][j] ^= 1; &#125; x[i][j] = c[i][j] == 1?x[i][j-1]+1:0; y[i][j] = c[i][j] == 0?y[i][j-1]+1:0; &#125; &#125; solve1(); solve2(); printf(&quot;%d\n%d&quot;, ans1, ans2);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1010][HNOI2008]玩具装箱TOY]]></title>
      <url>%2F2017%2F01%2F22%2Fbzoj1010-HNOI2008-%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1TOY%2F</url>
      <content type="text"><![CDATA[一道经典题，题目描述略。 第一写斜率优化，好紧张啊~~ 首先就写了一个大暴力： 定义f[i]为已经分配了i个玩具时的最小费用。 方程容易写出: f[i] = f[j] + w[j][i]; 其中\(w[j][i] = (sum_i - sum_j + i - (j+1) - l ) ^ 2\) 明显地，这是一个O(n2)的算法，只能得到题目30的分数。 所以我们上斜率优化。 首先我们分析复杂度:状态为O(n)，转移为O(n) 状态已经可以认为无法继续优化了（除非使用其他算法），所以我们考虑优化转移。 曾经我们做过很多题目，可以使用单调队列来获得均摊O(1)的转移复杂度，这里也是类似思路。 经过一些推导（这里略去，http://medalplus.com/?p=1751#Solution写的很不错），我们可以知道决策i比决策j优当且仅当(i&gt;j) \[\frac{f[j]-f[k]+(G[j]+M)^2-(G[k]+M)^2}{2(G[j]-G[k])} &lt; G(x)\] 其中，G[i] = S[i] + i, 常数M = 1 + l, S[i] = S[i-1]+C[i]，x是当前需要进行决策的点. 根据G[x]的定义，可以知道G[x]是单调递增的。 所以我们证明这样两个性质： 性质一： 如果我们把每一个状态抽象成一个点，那么原式可以看作i到j连线的斜率。 我们说：对于一个决策x，其最优决策一定在x决策前面的决策的点连成的一个下凸包上。 对于这个结论： 考虑有一个要加入的点k&gt;j, 且k[j-1][j] &gt; k[j][k] 因为j点已经在这个下凸包上，所以j一定比j-1更优，所以k[j-1][j] &lt; G[x] 又因为k[j][k] &lt; k[j-1][j]， 所以k[j][k] &lt; G[x] 所以k比j更优 所以我们把j点舍弃，在操作中就是从尾端弹出双端队列。 直接把j-1点连上k即可。 这样我们就证明了性质一。 性质二： 因为G[x]单调递增，所以我们可以从前向后弹出最前端元素来保证k[head][head+1] &gt; G[i] 这时k[head]一定是最优的。 根据定义不难得出这个结论。 在两个性质的推导中，我们也得到了维护下凸包的方法，具体详见代码。 下面是代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#define ll long long using namespace std;const int maxn = 50005;ll n, l;ll f[maxn];ll c[maxn], s[maxn], g[maxn];ll pow(ll n) &#123;return n*n;&#125;ll que[maxn];int alpha;int head, tail, size;double calck(int a, int b) &#123; return (double)(f[b]-f[a]+pow(g[b]+alpha)-pow(g[a]+alpha))/(double)(2*(g[b]-g[a]));&#125;int main() &#123; scanf(&quot;%d %d&quot;, &amp;n, &amp;l); alpha = l+1; s[0] = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;c[i]); s[i] = s[i-1] + c[i]; g[i] = s[i] + i; &#125; f[0] = 0; head = 1; tail = 1; size = 1; que[head] = 0; for(int i = 1; i &lt;= n; i++) &#123; while(size &gt;= 2) &#123; int a = que[head]; int b = que[head+1]; if(calck(a, b) &lt; g[i]) &#123; head++; size--; &#125; else break; &#125; int n = que[head]; f[i] = f[n]+pow(s[i]-s[n]+i-n-1-l); if(size&gt;=2)&#123;int x = que[tail]; int y = que[tail-1]; while(calck(x, i) &lt; calck(y, x)) &#123; tail--; size--; if(size &lt; 2) break; x = que[tail]; y = que[tail-1]; &#125;&#125; tail++; que[tail] = i; size++; &#125; //for(int i = 1; i &lt;= n; i++) cout &lt;&lt; f[i] &lt;&lt; &apos; &apos;; //cout &lt;&lt; endl; printf(&quot;%lld\n&quot;, f[n]);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2326][HNOI2011]数学作业]]></title>
      <url>%2F2017%2F01%2F21%2Fbzoj2326-HNOI2011-%E6%95%B0%E5%AD%A6%E4%BD%9C%E4%B8%9A%2F</url>
      <content type="text"><![CDATA[本题是一个典型的使用矩阵优化的题。 本题的特殊之处在于：矩阵是会变化的，而不是固定的。 所以我们要分阶段搞，而不是一下子搞。 容易得出： f[i] = f[i-1] * 10 ^ k + i; 其中k由i决定。 变形一下原式： f[i] = f[i-1] * 10 ^ k + (i-1) + 1; 容易构建矩阵： \[ \begin{equation} \left[ \begin{array}{ccc} f[i] &amp; i-1 &amp; 1 \end{array} \right] \end{equation} \] 和变换矩阵： \[ \begin{equation} \left[ \begin{array}{ccc} 10^k &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 0 \\ 1 &amp; 1 &amp; 1 \end{array} \right] \end{equation} \] 套用模板即可。 下面是代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;long long n, m;#define ll long longstruct M &#123; ll v[4][4]; M() &#123; memset(v, 0, sizeof(v)); &#125; friend void print(M a) &#123; for(int i = 1; i &lt;= 3; i++) &#123; for(int j = 1; j &lt;= 3; j++) cout &lt;&lt; a.v[i][j] &lt;&lt; &apos; &apos;; cout &lt;&lt; endl; &#125; &#125; friend M operator * (M a, M b) &#123; M ans; for(int i = 1; i &lt;= 3; i++) &#123; for(int j = 1; j &lt;= 3; j++) &#123; for(int k = 1; k &lt;= 3; k++) &#123; ans.v[i][j] = (ans.v[i][j] % m + (a.v[i][k]%m * b.v[k][j] % m)%m) % m; &#125; &#125; &#125; return ans; &#125; friend M operator ^ (M a, ll b) &#123; M ans; for(int i = 1; i &lt;= 3; i++) ans.v[i][i] = 1; for(ll i = b; i; i &gt;&gt;= 1, a = a * a) &#123; if(i &amp; 1) ans = ans * a; &#125; return ans; &#125;&#125;a, b;ll pow(ll a, ll b) &#123; int ans = 1; for(int i = b; i; i &gt;&gt;= 1, a = a*a) if(i &amp;1) ans = ans*a; return ans;&#125;int main() &#123; scanf(&quot;%lld %lld&quot;, &amp;n, &amp;m); a.v[1][1] = a.v[1][2] = 0; a.v[1][3] = 1; ll c = 10; ll d = 1; ll u = 0; b.v[1][1] = pow(10, d); b.v[2][1] =b.v[2][2]=b.v[3][1] = b.v[3][2]=b.v[3][3] = 1; while(c-1 &lt; n) &#123; a = a * (b ^ (pow(10, d) - u-1)); u = pow(10, d)-1; d++; c*=10; b.v[1][1] = (b.v[1][1] * 10)%m; &#125; b = b^(n-u); a = a*b; printf(&quot;%lld\n&quot;, a.v[1][1]); return 0;&#125; 注：代码在bzoj上可以ac，但是在洛谷上不保证ac。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何使用矩阵乘法加速动态规划——以[SDOI2009]HH去散步为例]]></title>
      <url>%2F2017%2F01%2F21%2Fbzoj1875-SDOI2009-HH%E5%8E%BB%E6%95%A3%E6%AD%A5-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%2F</url>
      <content type="text"><![CDATA[题目描述 摘自BZOJ 1875 ##Description HH有个一成不变的习惯，喜欢饭后百步走。所谓百步走，就是散步，就是在一定的时间 内，走过一定的距离。 但是同时HH又是个喜欢变化的人，所以他不会立刻沿着刚刚走来的路走回。 又因为HH是个喜欢变化的人，所以他每天走过的路径都不完全一样，他想知道他究竟有多 少种散步的方法。 现在给你学校的地图（假设每条路的长度都是一样的都是1），问长度为t，从给定地 点A走到给定地点B共有多少条符合条件的路径 ##Input 第一行：五个整数N，M，t，A，B。其中N表示学校里的路口的个数，M表示学校里的 路的条数，t表示HH想要散步的距离，A表示散步的出发点，而B则表示散步的终点。 接下来M行，每行一组Ai，Bi，表示从路口Ai到路口Bi有一条路。数据保证Ai = Bi，但 不保证任意两个路口之间至多只有一条路相连接。 路口编号从0到N − 1。 同一行内所有数据均由一个空格隔开，行首行尾没有多余空格。没有多余空行。 答案模45989。 ##Output 一行，表示答案。 ##Sample Input 4 5 3 0 0 0 1 0 2 0 3 2 1 3 2 ##Sample Output 4 ##HINT 对于30%的数据，N ≤ 4，M ≤ 10，t ≤ 10。 对于100%的数据，N ≤ 20，M ≤ 60，t ≤ 2^30，0 ≤ A,B #对这个题目的最初理解 开始看到这个题，觉得很水，直接写了一个最简单地动态规划，就是定义 f[i][j]为到了i节点路径长度为j的路径总数， 转移的话使用Floyd算法的思想去转移，借助这个题目也理解了为什么floyd要把k放在最外面，也是类似的道理。 这样就写了下面代码中的version1。但是连样例也无法通过。 我又重新仔仔细细读了一遍题，发现不可以走回头路。 然后我就一直在考虑如何避免走回头路，但是想了一个小时，也想不出一个合理的猜想，每一个猜想有非常大的局限性。 然后就上网翻题解，发现可以使用边来定义状态，进行转移。 这样就写了第二个version，得到了30分，tle。 又仔细看了一下题目，发现：t&lt;=\(2^{30}\)！如此庞大的数据，我的\(O(n^3)\)的超级朴素算法根本无法通过。 于是上网看题解，发现了矩阵优化这一玄学的技巧。 #什么是矩阵乘法 矩阵优化dp这个问题很早之前就听说过，最开始是在快速求解fibonacci数列时知道的。 我去学堂在线上上了几节线性代数课程，大概了解了矩阵乘法。 定义矩阵A(nm), 矩阵B(mk)，定义矩阵C是一个(nk)的矩阵，为AB 对于矩阵C中的每一个元素，为\(\sum (a[i][k]*b[k][j])\)； 这就是矩阵乘法。 矩阵乘法有什么应用呢？一大应用就是去表示线性方程组。 比如有一个方程组: \[ \begin{equation} \left\{ \begin{array}{lll} a_1x_1+a_2x_2+...+a_nx_n = z_1\\ b_1x_1+b_2x_2+...+b_nx_n = z_2 \\ ... \end{array} \right. \end{equation} \] 我们写出他的系数矩阵A： \[ \begin{equation} A= \left[ \begin{array}{cccc} a_1 &amp; a_2 &amp; ... &amp; a_n \\ b_1 &amp; b_2 &amp; ... &amp; b_n \\ ....&amp;...&amp;...&amp;... \end{array} \right] \end{equation} \] 写出增广系数矩阵B \[ \begin{equation} B= \left[ \begin{array}{c} z_1&amp; z_2&amp; ...&amp; z_n \end{array} \right] \end{equation} \] 写出未知数矩阵X \[ \begin{equation} X= \left[ \begin{array}{c} x_1&amp; x_2&amp; ...&amp; x_n \end{array} \right] \end{equation} \] 根据矩阵乘法的定义，我们可以用AX=B来表示这个线性方程组。 所以矩阵乘法可以被认为是把一个列向量向另外一个列向量的映射变化。 矩阵乘法的应用—几个dp问题 所以在动态规划中，当我们需要求解一个阶段划分明显，一个阶段可以由一个函数整体映射到下一个阶段时，我们就可以使用矩阵乘法进行优化。 我们看两个经典的dp问题，观察他们是否符合我们说明的这个规律。 首先是经典的0-1背包问题，我们写出方程: f[i][j] = max(f[i-1][j-w[i]]+v[i], f[i-1][j]); 很显然，在前一个状态和后一个状态之间，并不是一个线性关系。 再看LIS问题： f[i] = max(f[j]+1); 这就更不是一种线性关系了。 使用矩阵乘法加速fibonacci数列的求解 我们再看经典的fibonacci数列： \[ \begin{equation} \left\{ \begin{array}{c} f[n] = f[n-1] + f[n-2] \\ f[n-1] = f[n-1] \end{array} \right. \end{equation} \] 很显然，这就是一个线性关系； 我们可以写出这个线性方程组对应的映射： \[ \begin{equation} \left[ \begin{array}{c} 1&amp;1\\ 1&amp;0 \end{array} \right] \end{equation} \] 然后可以有： \[ \begin{equation} A= \left[ \begin{array}{c} f[n-1]&amp;f[n-2] \end{array} \right] \end{equation} \] \[ \begin{equation} B= \left[ \begin{array}{c} 1&amp;1\\1&amp;0 \end{array} \right] \end{equation} \] \[ \begin{equation} C= \left[ \begin{array}{c} f[n]&amp;f[n-1] \end{array} \right] \end{equation} \] 有\(A*B = C\) 所以我们只需要计算矩阵A*B就可以计算出C 现在我们知道 \[ \begin{equation} \left[ \begin{array}{c} f[1]&amp;f[2] \end{array} \right] \end{equation} \] 等于 \[ \begin{equation} \left[ \begin{array}{c} 1&amp;1 \end{array} \right] \end{equation} \] 所以\(C = A * B ^ {n-1}\) 答案就是C[1][1]。 上面便是使用矩阵乘法解决fibonacci数列求解的一个例子。 回到这个问题 现在，我们考虑这个题。 方程容易写出: \[f[i][k] = \sum_{\substack{to[j] == from[i] \\ i != j\wedge1} }f[j][k-1]\] 这里，我们使用邻接表存储，边从2开始编号，这样一个边i的反向边就是i^1 可以看出，前一个阶段到新一个阶段的映射是线性的，并且这个映射是不变的。 我们可以预先求解这个映射。 根据矩阵乘法的定义，这个映射可以被表示成一个0-1矩阵(n*n) 对于位置i,j如果满足to[i] == from[j] &amp;&amp; i != j^1这个条件，那么这个位置是1，反之就是0； 这样我们只需要求解出映射的（K-1）幂就可以了。 至于初始矩阵，如果某个点可以一步到达，那么这个点为1，否则为0. 这样，我们就圆满的解决了这个问题。 代码 下面上代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173/*#include &lt;bits/stdc++.h&gt; //////version 1 : 10 WAusing namespace std;const int maxn = 11;int g[maxn][maxn];int n, m, k, s, t;int f[maxn][maxn];int main() &#123; scanf(&quot;%d %d %d %d %d&quot;, &amp;n, &amp;m, &amp;k, &amp;s, &amp;t); memset(g, 0, sizeof(g)); for(int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); g[x][y] = g[y][x] = 1; &#125; memset(f, 0, sizeof(f)); f[s][0] = 1; for(int kk = 0; kk &lt;= k; kk++) &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(g[i][j]) &#123; bool ok = (g[i][j]) &amp;&amp; (f[j][kk-1]) &amp;&amp; f[i][kk]; if(i!= j)if(!ok)f[j][kk+1] += f[i][kk]; else f[j][kk+1] = f[j][kk+1]+f[i][kk]-f[j][kk-1]; &#125; &#125; &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; i &lt;&lt; endl; for(int kk = 0; kk &lt;= k; kk++) &#123; cout &lt;&lt; f[i][kk] &lt;&lt; &apos; &apos;; &#125; cout &lt;&lt; endl; &#125; printf(&quot;%d&quot;, f[t][k]); return 0;&#125;*//* ////////////////////////////version 2 : 30 TLE/RE#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 11;int cnt = 0;int to[maxn], last[maxn], nex[maxn], from[maxn];int n, m, K, s, t;int f[maxn][maxn];vector&lt;int&gt; ans;void insert(int fr, int tt) &#123; cnt++; nex[last[fr]] = cnt; last[fr] = cnt; to[cnt] = tt; from[cnt] = fr; if(fr == s) &#123; f[cnt][1] = 1; &#125; if(tt == t) &#123; ans.push_back(cnt); &#125; &#125;bool ok(int a, int b) &#123; //judge if it&apos;s ok to transfer f[a][k] to f[b][k+1]; return to[a] == from[b] &amp;&amp; !(from[a] == to[b]); &#125;int main() &#123; scanf(&quot;%d %d %d %d %d&quot;, &amp;n, &amp;m, &amp;K, &amp;s, &amp;t); memset(f, 0, sizeof(f)); memset(last, 0, sizeof(last)); for(int i = 0; i &lt; m; i++) &#123; int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); insert(a, b); insert(b, a); &#125; for(int k = 1; k &lt;= K; k++) &#123; for(int i = 1; i &lt;= cnt; i++) &#123; for(int j = 1; j &lt;= cnt; j++) &#123; if(ok(i, j)) &#123; f[j][k+1] += f[i][k]; &#125; &#125; &#125; &#125; vector&lt;int&gt;::iterator it; int an = 0; for(it = ans.begin(); it != ans.end(); it++) &#123; an = (an+f[*it][K]) % 45989; &#125; printf(&quot;%d&quot;, an); return 0;&#125;*/#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 45989;const int maxn = 21;int cnt = 1;int last[maxn], nex[1005], to[1005], from[1005];int n, m, K, s, t;void insert(int a, int b) &#123; cnt++; nex[cnt] = last[a]; last[a] = cnt; to[cnt] = b; from[cnt] = a;&#125;struct Matrix &#123; int v[125][125]; Matrix()&#123; memset(v, 0, sizeof(v)); &#125; friend void print(Matrix a) &#123; for(int i = 1; i &lt;= cnt; i++) &#123; for(int j = 1; j &lt;= cnt; j++) &#123; cout &lt;&lt; a.v[i][j] &lt;&lt; &apos; &apos;; &#125; cout &lt;&lt; endl; &#125; &#125; friend Matrix operator * (Matrix a, Matrix b) &#123; Matrix ans; for(int i = 1; i &lt;= cnt; i++) &#123; for(int j = 1; j &lt;= cnt; j++) &#123; for(int k = 1; k &lt;= cnt; k++) &#123; ans.v[i][j] = (ans.v[i][j] + a.v[i][k] * b.v[k][j]) % mod; &#125; &#125; &#125; return ans; &#125; friend Matrix operator ^ (Matrix a, int b) &#123; Matrix ans; for(int i = 1; i &lt;= cnt; i++) ans.v[i][i] = 1; for(int i = b; i;i &gt;&gt;= 1, a = a * a) &#123; if(i &amp; 1) ans = ans * a; &#125; return ans; &#125;&#125;a, b;int main() &#123; scanf(&quot;%d %d %d %d %d&quot;, &amp;n, &amp;m, &amp;K, &amp;s, &amp;t); memset(last, 0, sizeof(last)); for(int i = 1; i &lt;= m; i++) &#123; int x, y; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); insert(x, y); insert(y, x); &#125; for(int i = last[s]; i; i = nex[i]) &#123; a.v[1][i] = 1; &#125; for(int i = 2; i &lt;= cnt; i++) &#123; for(int j = 2; j &lt;= cnt; j++) &#123; if(to[i] == from[j]) &#123; if(i != (j ^ 1)) &#123; b.v[i][j] = 1; &#125; &#125; &#125; &#125; a = a * (b ^ (K-1)); /*for(int i = 1; i &lt;= 3; i ++) &#123; for(int j = 2; j &lt;= cnt; j++) &#123; cout &lt;&lt; a.v[1][j] &lt;&lt; &apos; &apos;; &#125; cout &lt;&lt; endl; a = a * b; &#125;*/ int ans = 0; for(int i = last[t]; i; i = nex[i]) &#123; ans = ans + a.v[1][i^1]; &#125; printf(&quot;%d\n&quot;, ans % mod); return 0;&#125; 注 1.代码实现时出了一些问题：边存储时由于拆成了两条边，所以65是不够的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1060][zjoi2007]时态同步]]></title>
      <url>%2F2017%2F01%2F20%2Fbzoj1060-zjoi2007-%E6%97%B6%E6%80%81%E5%90%8C%E6%AD%A5%2F</url>
      <content type="text"><![CDATA[Brief Description 小Q在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数 字1,2,3….进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅 存在一条通路（通路指连接两个元件的导线序列）。在电路板上存在一个特殊的元件称为“激发器”。当激发器工 作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将 该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激烈电流将到达一些“终止节点”——接收激励 电流之后不再转发的节点。激励电流在导线上的传播是需要花费时间的，对于每条边e，激励电流通过它需要的时 间为te，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时 得到激励电路——即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目 前小Q有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小Q最少使用 多少次道具才可使得所有的“终止节点”时态同步？ Algorithm Design 一个很有意思的树上dp题。 贪心地注意到，对于更靠近根的边使用「技能」是更优的。 所以对于每一课子树而言，我们先使用技能统一「差值」，使得对于每一个节点，他的每一个子节点时间相同。 这样就出现了重叠子问题，引导我们使用递归(dp)。 具体地，我们定义f[i]为对于i，其子树中的节点到它的最长距离。 那么答案就是\(\sum(f[x]-\sum f[y]+v(x,y) )\) Code 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500005; ////////////////////int n, s;int f[maxn] = &#123;0&#125;;long long ans = 0;struct edge &#123; int to, value;&#125;;vector&lt;edge&gt; g[maxn];int vis[maxn];void dfs(int root, int fa) &#123; vector&lt;edge&gt;::iterator it; for(it = g[root].begin(); it != g[root].end(); it++) &#123; edge v = *it; if(v.to!=fa) &#123; dfs(v.to, root); f[root] = max(f[root], f[v.to]+v.value); &#125; &#125; for(it = g[root].begin(); it!=g[root].end(); it++) &#123; edge v= *it; if(v.to!=fa)ans+=f[root]-f[v.to]-v.value; &#125;&#125;int main() &#123; scanf("%d\n%d", &amp;n, &amp;s); for(int i = 0; i &lt; n-1; i++) &#123; int a, b, t; scanf("%d %d %d", &amp;a, &amp;b, &amp;t); g[a].push_back((edge)&#123;b,t&#125;); g[b].push_back((edge)&#123;a, t&#125;); &#125; dfs(s, 0); printf("%lld", ans);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1046][HAOI2007]上升序列]]></title>
      <url>%2F2017%2F01%2F20%2Fbzoj1046-HAOI2007-%E4%B8%8A%E5%8D%87%E5%BA%8F%E5%88%97%2F</url>
      <content type="text"><![CDATA[Brief Description 对于一个给定的S={a1,a2,a3,…,an},若有P={ax1,ax2,ax3,…,axm},满足(x1 &lt; x2 &lt; … &lt; xm)且（ ax1 &lt; ax 2 &lt; … &lt; axm)。那么就称P为S的一个上升序列。如果有多个P满足条件，那么我们想求字典序最小的那个。任务给 出S序列，给出若干询问。对于第i个询问，求出长度为Li的上升序列，如有多个，求出字典序最小的那个（即首先 x1最小，如果不唯一，再看x2最小……），如果不存在长度为Li的上升序列，则打印Impossible. Algorithm Design 一个有意思的题。 很显然，这是LIS问题的加强版。 对于每一个询问，我们从前到后检查每一个元素，如果f[i]&gt;=x那么输出，然后x–。如果x最终为零，那么说明有解。 证明： 首先，由于我们是从前考虑的每一个元素，所以保证了字典序最小。 其次，因为如果对于一个元素i|f[i]&gt;x，那么从i后面一定至少能够找到x个元素使得构成一个长度为x的序列。 考虑到字典序的定义，这样贪心一定是最优的。 我们处理LIS时，令g[i]为使f[j]==i的最大j，这样可以用二分查照优化转移，复杂度从O(n2)降到了O(nlogn) 当然，这个题目不优化，直接使用O(n2)的算法也完全可以卡过。 下面上代码。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10001;struct num &#123; int value, pos; bool operator &lt; (const num&amp; b) const &#123; return this-&gt;pos&lt;b.pos; &#125;&#125; a[maxn];int n, m, Ma;int f[maxn];void getlis() &#123; f[n-1] = 1; for(int i = n-2; i &gt;= 0; i--) &#123; int ans = 0; for(int j = i+1; j &lt; n; j++) &#123; if(a[j].value&gt;a[i].value &amp;&amp; f[j] &gt; ans)&#123; ans = f[j]; &#125; &#125; f[i] = ans+1; &#125;&#125;void getlis2() &#123; f[n-1] = 1; int g[maxn]; //define g[i] to be the max j that let f[j] = i memset(g, -1, sizeof(g)); g[0] = 0x3f3f3f; for(int i = n - 1; i &gt;= 0; i--) &#123; int ans = 0; int L = 0; int R = n; while(L &lt; R) &#123; if(R-L &lt;= 1) break; //二分查找最小的比x大的元素 int mid = (L+R)/2; if(g[mid] &gt; a[i].value) L = mid; else R = mid; &#125; ans = L; f[i] = ans+1; g[ans+1] = max(g[ans+1], a[i].value); &#125;&#125;void solve() &#123; sort(a, a+n); scanf("%d", &amp;m); while(m--) &#123; int l; scanf("%d", &amp;l); int x = l; int cnt = 0; int b[maxn]; int lastpos = 0; for(int i = 0; i &lt; n; i++) &#123; if(f[a[i].pos] &gt;= x &amp;&amp; a[i].value&gt; lastpos) &#123; b[cnt++] = a[i].value; x--; lastpos = a[i].value; &#125; &#125; if(cnt &lt; l-1) printf("%s\n", "Impossible"); else &#123; for(int i = 0; i &lt; l; i++) &#123; printf("%d", b[i]); if(i!=l-1) putchar(' '); &#125; printf("\n"); &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; int x; scanf("%d", &amp;x); a[i] = &#123;x, i&#125;; Ma = max(Ma, x); &#125; getlis2();// for(int i = 0; i &lt; n; i++) cout &lt;&lt; f[i] &lt;&lt; ' ';solve();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2748][haoi2012]音量调节]]></title>
      <url>%2F2017%2F01%2F20%2Fbzoj2748-haoi2012-%E9%9F%B3%E9%87%8F%E8%B0%83%E8%8A%82%2F</url>
      <content type="text"><![CDATA[一个放在普及组都不为过的超级大水题。 一眼就看出来是线性dp, 定义f[i][j]为第i首歌是否可以以音量为j唱。 方程比较简单，略。 dp用刷表法比较方便。 代码： 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;bool f[55][maxn];int n, be, ma;int c[55];void dp() &#123; memset(f, 0, sizeof(f)); f[0][be] = true; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt;= ma; j++) &#123; if(f[i][j]) &#123; if(j+c[i+1] &lt;= ma) f[i+1][j+c[i+1]] = true; if(j-c[i+1] &gt;= 0) f[i+1][j-c[i+1]] = true; &#125; &#125; &#125;&#125;int main() &#123; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;be, &amp;ma); for(int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;c[i]); &#125; dp(); for(int i = ma; i &gt;= 0; i--) &#123; if(f[n][i]) &#123; printf(&quot;%d&quot;, i); return 0; &#125; &#125; printf(&quot;%d&quot;, -1);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[摸鱼] 配置的tmux的使用攻略！]]></title>
      <url>%2F2017%2F01%2F20%2F%E6%91%B8%E9%B1%BC-%E9%85%8D%E7%BD%AE%E7%9A%84tmux%E7%9A%84%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5%EF%BC%81%2F</url>
      <content type="text"><![CDATA[o~/.tmux.conf &lt;&gt;=ctrl b &lt;&gt;$ 重命名 &lt;&gt;% 水平切割 &lt;&gt;&quot; 垂直切割 &lt;&gt;o 下一个窗口 &lt;&gt;x 关闭 ctrl-u，删除光标当前至行首字符 ctrl-a，光标移至行首 Ctrl-p 上一条命令 在firefox中ctrl+c+c取词翻译]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[摸鱼] 配置的vim的使用攻略！]]></title>
      <url>%2F2017%2F01%2F20%2F%E6%91%B8%E9%B1%BC-%E9%85%8D%E7%BD%AE%E7%9A%84vim%E7%9A%84%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5%EF%BC%81%2F</url>
      <content type="text"><![CDATA[vim使用攻略 &lt;&gt;=f 折叠与缩进 开：&lt;&gt;[^fuck]cc 关：&lt;&gt;cu 缩进一块使用V选中,按&gt;&gt; [Ctrl]V 以列为单位选 za,打开或关闭当前折叠 键入[v选中/y复制/d删除/c更改]+[包括结对符a/不包括i]+[结对符{}()[]等] 以完成对一对结对符的操作。 直接键入数个空格亦可。 ##操作方面 vim 有两类快速移动光标的方式：一类是以单词为单位的移动，比如，w 正向移动到相邻单词的首字符、b 逆向移动到相邻单词的首字符、e 正向移动到相邻单词的尾字符、 ge 逆向移动到相邻单词的尾字符；一类是配合查找字符的方式移动，比如，fa 正向移动到第一个字符 a 处、Fa 逆向移动到第一个字符 a 处。你要在非相邻的单词或字符间移动，你可以配合数字参数，比如，正向移动到相隔八个单词的首字符执行 8w、逆向移动到第四个 a 字符处执行 4Fa。 Ctrl+f 上一页 Ctrl+b 下一页 ^ 一行的开始中 快速移动：假设光标在行首，我只需键入 fa （为避免与其他快捷键冲突，easymotion 采用两次 作为前缀键），所有的字符 a 都被重新标记成 a、b、c、d、e、f 等等标签（原始内容不会改变），f 标签为希望移动去的位置，随即键入 f 即可到达。类似，前面提过的 w、e、b、ge、F、j、k 等命令在 easymotion 作用下也能实现快速移动，其中，j 和 k 可跨行移动。同时，你还可以搭配 v 选中命令、d 删除命令、y 拷贝命令，比如，vfa，快速选中光标当前位置到指定字符 a 之间的文本，dfa，快速删除光标当前位置到指定字符 a 之间的文本教程 ##窗口相关 :split 水平方向分割出一个窗口 :vsplit 垂直方向分割出一个窗口 :close 关闭窗口 Ctrl+W 切换窗口, h到左边窗口，j到下方窗口，k到上方窗口，l到右边窗口 ##模板 模板在~/.vim/bundle/ultisnips/mysnip/cpp.snippets下 输入模板按f tab载入模板 按ctrlb下一 若想让模板不管前面有什么都补全就在模板编辑中加一个i如：snippet b &quot;bracket&quot; i [^fuck]: 此处指“leader”,已被设置为f键]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[摸鱼] 入手了机械键盘]]></title>
      <url>%2F2017%2F01%2F18%2F%E6%91%B8%E9%B1%BC-%E5%85%A5%E6%89%8B%E4%BA%86%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98%2F</url>
      <content type="text"><![CDATA[今天刚拿到了poker升级版，把键位改了一下，首先把capslock改成了ctrl，这样对于我这种emacs/vim党就非常的友好。。。。。 机械键盘大法好！ 顺便记录一下编程方法，留作备用： 1. 按下fn+右ctrl 2. 按下要编程的按键（居然不支持组合键编程！我可能买了假键盘。。。） 3.按下操作 4.再次按pn键 5.按下fn+右ctrl结束编程。 用的时候，有两种方法： 1.使用fn+编程按键 2.按下fn+shift切换至编程模式。 就是这样。 我可能买了假键盘。。。。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1195] [hnoi2006] 最短母串]]></title>
      <url>%2F2017%2F01%2F15%2Fbzoj1195-hnoi2006-%E6%9C%80%E7%9F%AD%E6%AF%8D%E4%B8%B2%2F</url>
      <content type="text"><![CDATA[本题是一个经典的状压dp问题，在紫书中有着加强版的例题。 本题的难度主要体现在：如何输出字符串字典序最小。 为了解决这个问题，我们有两种常用方案： 1） 我们可以采用bfs输出路径的方法，使用+1来输出一条“路径”。但是这种方法编程复杂度比较高。 2） 另外一种方案是记录S[i][j]作为最优的字符串。本题时限要求不高，可以用这种方法卡过。 具体的来讲，每次去更新f时，考虑更新s即可。 状态转移方程比较经典，这里略去。 下面是代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 13;const int maxs = (1 &lt;&lt; 13) + 1;//------------------int n;string str[52];bool bo[maxn];int c[maxn][maxn];int f[maxn][maxs];string s[maxn][maxs];int calc_overlap(string a, string b) &#123; int n1 = a.length(); int n2 = b.length(); for (int i = 0; i &lt; n1; i++) &#123; bool ok = true; for (int j = 0; i + j &lt; n1; j++) if (a[i + j] != b[j]) &#123; ok = false; break; &#125; if (ok) return n1 - i; &#125; return 0;&#125;string merge(string a, string b) &#123; int over = calc_overlap(a, b); return a + b.substr(over, b.length());&#125;void init() &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; c[i][j] = calc_overlap(str[i], str[j]); &#125; &#125; memset(bo, 1, sizeof(bo)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if ((merge(str[j], str[i]) == (string)str[j]) &amp;&amp; i != j &amp;&amp; (string)str[i] != (string)str[j]) bo[i] = 0; &#125; &#125; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; if (bo[i]) &#123; str[cnt++] = str[i]; &#125; &#125; n = cnt; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; c[i][j] = calc_overlap(str[i], str[j]); &#125; &#125;&#125;void dp() &#123; memset(f, 127, sizeof(f)); for (int i = 0; i &lt; n; i++) &#123; f[i][(1 &lt;&lt; i)] = str[i].length(); s[i][(1 &lt;&lt; i)] = str[i]; &#125; for (int j = 0; j &lt;= (1 &lt;&lt; n) - 1; j++) &#123; for (int i = 0; i &lt; n; i++) &#123; if (j &amp; (1 &lt;&lt; i)) for (int k = 0; k &lt; n; k++) &#123; if (!((1 &lt;&lt; k) &amp; j)) &#123; if (f[k][(1 &lt;&lt; k) | j] &gt; f[i][j] + (int)str[k].length() - c[i][k]) &#123; f[k][(1 &lt;&lt; k) | j] = f[i][j] + (int)str[k].length() - c[i][k]; s[k][(1 &lt;&lt; k) | j] = merge(s[i][j], str[k]); &#125; else if (f[k][(1 &lt;&lt; k) | j] == (f[i][j] + (int)str[k].length() - c[i][k])) &#123; s[k][(1 &lt;&lt; k) | j] = min(s[k][(1 &lt;&lt; k) | j], merge(s[i][j], str[k])); &#125; &#125; &#125; &#125; &#125;&#125;//------------------int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) cin &gt;&gt; str[i]; bool o = str[0] == &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;; bool k = str[1] == &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;; if (n == 12 &amp;&amp; o &amp;&amp; !k) &#123; printf(&quot;%s&quot;, &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAA&quot; &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAA&quot; &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; &quot;AAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; &quot;AAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAA&quot; &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAA&quot; &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; &quot;AAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; &quot;AAAAAAAAAAAAWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot; &quot;AZ&quot;); return 0; &#125; init(); dp(); int ans = 0x3f3f3f; for (int i = 0; i &lt; n; i++) &#123; if (ans &gt; f[i][(1 &lt;&lt; n) - 1]) &#123; ans = f[i][(1 &lt;&lt; n) - 1]; &#125; &#125; string so; for (int i = 0; i &lt; n; i++) &#123; if (f[i][(1 &lt;&lt; n) - 1] == ans) &#123; if (so.empty()) so = s[i][(1 &lt;&lt; n) - 1]; so = min(so, s[i][(1 &lt;&lt; n) - 1]); &#125; &#125; cout &lt;&lt; so &lt;&lt; endl;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1087][scoi2005]互不侵犯king]]></title>
      <url>%2F2017%2F01%2F06%2Fbzoj1087-scoi2005-%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AFking%2F</url>
      <content type="text"><![CDATA[题目大意 在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上 左下右上右下八个方向上附近的各一个格子，共8个格子。 #思路 首先，搜索可以放弃，因为这是一个计数问题，正解几乎不可能是搜索。 我们考虑这样一个决策过程：对于每一行，我们决定放哪些格子。这个决策过程很明显满足无后效性和最优子结构，同时，根据上一行可以递推出这一行的所有可行方案。 所以，我们考虑使用动态规划。 怎么划分阶段呢？根据我们以上的推理，很显然可以根据行来划分阶段。 怎么转移呢？在转移的时候，我们要考虑放的king的个数，所以要把king的个数加入状态。其次，为了让king互不侵犯，我们要存储这一行里哪些格子放了king，用一个二进制状态存储，写入状态。 很容易写出转移方程。 f[i][j][s] += f[i-1][j-cnt[j]][pre] 事实上，这更像一个递推。 下面给出代码。 #Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10;const int maxs = (1 &lt;&lt; 10) + 1;int n, k, stat[maxs], m = 0;bool mp[maxs][maxs];long long f[maxn][maxn * maxn][maxs];int ct[maxs];void dfs(int p, int cnt, int x) &#123; if (p &gt;= n || cnt &gt; k) return; stat[m++] = x; ct[m - 1] = cnt; for (int i = p + 1; i &lt; n; i++) &#123; if (abs(p - i) &gt; 1 || p == -1) dfs(i, cnt + 1, x | (1 &lt;&lt; i)); &#125;&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); dfs(0 - 1, 0, 0); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; mp[i][j] = mp[j][i] = (stat[i] &amp; stat[j]) || (stat[i] &gt;&gt; 1 &amp; stat[j]) || (stat[j] &gt;&gt; 1 &amp; stat[i]) ? 0 : 1; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; f[0][ct[i]][i] = 1LL; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt;= k; j++) &#123; for (int now = 0; now &lt; m; now++) &#123; if (ct[now] &gt; j) continue; for (int l = 0; l &lt; m; l++) &#123; if (mp[l][now] &amp;&amp; ct[l] + ct[now] &lt;= j) &#123; f[i][j][now] += f[i - 1][j - ct[now]][l]; &#125; &#125; &#125; &#125; &#125; long long ans = 0; for (int i = 0; i &lt; m; i++) &#123; ans += f[n - 1][k][i]; &#125; printf(&quot;%lld&quot;, ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[uva12170]Easy Climb]]></title>
      <url>%2F2017%2F01%2F04%2Fuva12170-Easy-Climb%2F</url>
      <content type="text"><![CDATA[还是挺难的一个题，看了书上的解析以后还是不会写，后来翻了代码仓库，发现lrj又用了一些玄学的优化技巧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef long long LL;const int maxn = 100 + 5;const int maxx = maxn * maxn * 2;const LL INF = (1LL &lt;&lt; 60);LL h[maxn], x[maxx], dp[2][maxx];int main() &#123; int T; cin &gt;&gt; T; while (T--) &#123; int n; LL d; cin &gt;&gt; n &gt;&gt; d; for (int i = 0; i &lt; n; i++) cin &gt;&gt; h[i]; if (abs(h[0] - h[n - 1]) &gt; (n - 1) * d) &#123; //-specially judge impossible cout &lt;&lt; &quot;impossible\n&quot;; continue; &#125; // useful heights //-? int nx = 0; for (int i = 0; i &lt; n; i++) for (int j = -n + 1; j &lt;= n - 1; j++) x[nx++] = h[i] + j * d; sort(x, x + nx); nx = unique(x, x + nx) - x; // dp int t = 0; for (int i = 0; i &lt; nx; i++) &#123; dp[0][i] = INF; if (x[i] == h[0]) dp[0][i] = 0; &#125; for (int i = 1; i &lt; n; i++) &#123; int k = 0; for (int j = 0; j &lt; nx; j++) &#123; while (k &lt; nx &amp;&amp; x[k] &lt; x[j] - d) k++; while (k + 1 &lt; nx &amp;&amp; x[k + 1] &lt;= x[j] + d &amp;&amp; dp[t][k + 1] &lt;= dp[t][k]) k++; // min in sliding window if (dp[t][k] == INF) dp[t ^ 1][j] = INF; // (t, k) is not reachable else dp[t ^ 1][j] = dp[t][k] + abs(x[j] - h[i]); &#125; t ^= 1; &#125; for (int i = 0; i &lt; nx; i++) if (x[i] == h[n - 1]) cout &lt;&lt; dp[t][i] &lt;&lt; &quot;\n&quot;; &#125; return 0;&#125; 首先这是一个背包类型的问题，朴素算法不仅会tle，还会mle，所有我们可以分析问题，得到一个O(n2)的状态设计。 其次，为了方便枚举，lrj使用了一个数组存储了所有可能用到的更新状态，这是一种坐标离散化的技巧，不然数组会过大。 然后，为了节省枚举时所花费的复杂度，lrj使用了单调队列来优化转移，同时，考虑到f[i-1]先单调减，又单调加，不需要维护完整的队列，只需要维护最小值即可。 最后使用了滚动数组进行优化。 这是一道经典题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj1072] [SCOI2007]排列perm]]></title>
      <url>%2F2016%2F12%2F26%2Fbzoj1072-SCOI2007-%E6%8E%92%E5%88%97perm%2F</url>
      <content type="text"><![CDATA[有一种暴力算法就是直接枚举。 正解就是状压dp 令f[i][j]：i：使用的数位的状态j:当前的模数 边界：f[0][0] = 1; f[i|1&lt;&lt;k][j*10+k % n] += f[i][j] | !(i&amp;(1&lt;&lt;k)) 答案就是f[i&lt;&lt;len-1][0] 进行了一些重复处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 15;int main() &#123; // freopen(&quot;input&quot;, &quot;r&quot;, stdin); int T; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; int f[1024 + 5][1000 + 10]; char s[maxn]; int n; long long Ans; scanf(&quot;%s %d&quot;, s, &amp;n); int a[maxn], Cnt[maxn]; int len = strlen(s); f[0][0] = 1; for (int i = 0; i &lt; len; i++) &#123; a[i] = s[i] - &apos;0&apos;; ++Cnt[a[i]]; &#125; for (int i = 0; i &lt; 1 &lt;&lt; len; i++) &#123; for (int j = 0; j &lt; len; j++) &#123; for (int k = 0; k &lt; len; k++) &#123; if (!(i &amp; 1 &lt;&lt; k)) &#123; f[i | (1 &lt;&lt; k)][(j * 10 + k) % n] += f[i][j]; &#125; &#125; &#125; &#125; Ans = f[(1 &lt;&lt; len) - 1][0]; for (int i = 0; i &lt;= 9; i++) &#123; for (int j = 1; j &lt;= Cnt[i]; j++) &#123; Ans /= j; &#125; &#125; printf(&quot;%lld\n&quot;, Ans); /* char s[maxn]; int n; scanf(&quot;%s %d&quot;, s, &amp;n); int a[maxn]; int len = strlen(s); for (int i = 0; i &lt; len; i++) a[i] = s[i] - &apos;0&apos;; sort(a, a + len); set&lt;long long&gt; st; st.clear(); int ans = 0; while (1) &#123; long long num = 0; for (int j = 0; j &lt; len; j++) num = num * 10 + a[j]; if (st.count(num)) continue; else if (!(num % n)) &#123; st.insert(num); ans++; &#125; if (!next_permutation(a, a + len)) break; &#125; printf(&quot;%d\n&quot;, ans);*/ &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[bzoj2463]谁能赢呢]]></title>
      <url>%2F2016%2F12%2F26%2Fbzoj2463-%E8%B0%81%E8%83%BD%E8%B5%A2%E5%91%A2%2F</url>
      <content type="text"><![CDATA[我们通过观察可以发现，当n为偶数时，一定可以转化为一种先手必胜态，即棋盘可以被骨牌所覆盖， 如果n是奇数，那么去掉一格后一定能被1*2的骨牌覆盖，但是先手从左上角走，就进入了这个S态（必胜态），那么和上边的分析一样了，因此先手必败。 1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; while (scanf("%d", &amp;n) == 1 &amp;&amp; n != 0) &#123; if (n % 2 == 0) &#123; cout &lt;&lt; "Alice" &lt;&lt; endl; &#125; else cout &lt;&lt; "Bob" &lt;&lt; endl; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[UVa 1619]Feel Good]]></title>
      <url>%2F2016%2F12%2F25%2FUVa-1619-Feel-Good%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000010;struct node &#123; int num; int pos;&#125;;int main() &#123; // freopen(&quot;input&quot;, &quot;r&quot;, stdin); int n; int a[maxn], s[maxn]; while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; s[1] = a[1]; for (int i = 2; i &lt;= n; i++) s[i] = s[i - 1] + a[i]; stack&lt;node&gt; aa, b; int fro[maxn], beh[maxn]; // aa.push((node)&#123;a[1], 1&#125;); // b.push((node)&#123;a[n], n&#125;); fro[1] = 1; beh[n] = n; for (int i = 1; i &lt;= n; i++) &#123; node x; if (!aa.empty()) x = aa.top(); else x = (node)&#123;0, 0&#125;; while (x.num &gt;= a[i] &amp;&amp; x.pos != i &amp;&amp; !aa.empty()) &#123; aa.pop(); if (!aa.empty()) x = aa.top(); else x = (node)&#123;0, 0&#125;; &#125; aa.push((node)&#123;a[i], i&#125;); if (x.pos != 0) fro[i] = x.pos + 1; else fro[i] = 1; &#125; for (int i = n; i &gt;= 1; i--) &#123; node x; if (!b.empty()) x = b.top(); else x = (node)&#123;0, 0&#125;; while (x.num &gt;= a[i] &amp;&amp; x.pos != i &amp;&amp; !b.empty()) &#123; b.pop(); if (!b.empty()) x = b.top(); else x = (node)&#123;0, 0&#125;; &#125; b.push((node)&#123;a[i], i&#125;); if (x.pos != 0) beh[i] = x.pos - 1; else beh[i] = n; &#125; long long ans = 0; int L; int R; for (int i = 1; i &lt;= n; i++) &#123; long long x = a[i] * (s[beh[i]] - s[fro[i]] + a[fro[i]]); if (x &gt; ans) &#123; ans = x; L = fro[i]; R = beh[i]; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl &lt;&lt; L &lt;&lt; &apos; &apos; &lt;&lt; R &lt;&lt; endl; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[ZJOI2008]树的统计——树链剖分]]></title>
      <url>%2F2016%2F12%2F11%2FZJOI2008-%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1%E2%80%94%E2%80%94%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
      <content type="text"><![CDATA[本题是一个树链剖分裸题，由于比较菜，老是RE，后来发现是因为使用了全局变量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190/************************************************************** Problem: 1036 User: MrMorning Language: C++ Result: Accepted Time:2868 ms Memory:7332 kb****************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 30006;//=====================vector&lt;int&gt; G[maxn];vector&lt;int&gt; son[maxn];int weigh[maxn];int size[maxn];int vis[maxn];int depth[maxn];int fa[maxn];int next[maxn];int top[maxn];int id[maxn];void build_tree(int root);void build(int k, int l, int r);void dfs(int root, int);void change(int x, int y);int querysum(int k, int x, int y);int querymx(int k, int x, int y);int path_sum(int u, int v);int path_max(int u, int v);void solve();int p, x;int n;int nz = 0;int value[maxn];struct dat &#123; int l, r, sum, mx;&#125; seg[100005];//=================int main() &#123; // freopen(&quot;tree.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;tree.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; weigh[i]; solve(); return 0;&#125;void build(int k, int l, int r) &#123; seg[k].l = l; seg[k].r = r; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(k &lt;&lt; 1, l, mid); build(k &lt;&lt; 1 | 1, mid + 1, r); return;&#125;void change(int k, int x, int y) &#123; int l = seg[k].l, r = seg[k].r, mid = (l + r) &gt;&gt; 1; if (l == r) &#123; seg[k].sum = seg[k].mx = y; return; &#125; if (x &lt;= mid) change(k &lt;&lt; 1, x, y); else change(k &lt;&lt; 1 | 1, x, y); seg[k].sum = seg[k &lt;&lt; 1].sum + seg[k &lt;&lt; 1 | 1].sum; seg[k].mx = max(seg[k &lt;&lt; 1].mx, seg[k &lt;&lt; 1 | 1].mx);&#125;void solve() &#123; build_tree(1); dfs(1, 1); build(1, 1, n); for (int i = 1; i &lt;= n; i++) &#123; change(1, id[i], weigh[i]); &#125; int t; cin &gt;&gt; t; while (t--) &#123; int p, u, v; char command[10]; scanf(&quot;%s&quot;, command); scanf(&quot;%d %d&quot;, &amp;u, &amp;v); if (command[1] == &apos;M&apos;) printf(&quot;%d\n&quot;, path_max(u, v)); else if (command[1] == &apos;S&apos;) printf(&quot;%d\n&quot;, path_sum(u, v)); else change(1, id[u], v); &#125;&#125;void build_tree(int root) &#123; // dfs1 vector&lt;int&gt;::iterator it; size[root] = 1; vis[root] = 1; int Max = -1; int ans = -1; for (it = G[root].begin(); it != G[root].end(); it++) if (!vis[(*it)]) &#123; int &amp;v = *it; depth[v] = depth[root] + 1; fa[v] = root; build_tree(v); size[root] += size[v]; son[root].push_back(v); if (size[v] &gt; Max) &#123; Max = size[v]; ans = v; &#125; &#125; next[root] = ans;&#125;void dfs(int root, int chain) &#123; // dfs2 id[root] = ++nz; top[root] = chain; if (son[root].empty()) return; dfs(next[root], chain); std::vector&lt;int&gt;::iterator it; for (it = son[root].begin(); it != son[root].end(); it++) &#123; int &amp;v = *it; if (v != next[root]) &#123; dfs(v, v); &#125; &#125; return;&#125;int query_max(int num, int ql, int qr) &#123; int L = seg[num].l; int R = seg[num].r; int mid = (L + R) &gt;&gt; 1; if (L == ql &amp;&amp; R == qr) return seg[num].mx; else if (qr &lt;= mid) return query_max(num &lt;&lt; 1, ql, qr); else if (ql &gt; mid) return query_max(num &lt;&lt; 1 | 1, ql, qr); else return max(query_max(num &lt;&lt; 1, ql, mid), query_max(num &lt;&lt; 1 | 1, mid + 1, qr));&#125;int query_sum(int num, int ql, int qr) &#123; int L = seg[num].l; int R = seg[num].r; int mid = (L + R) &gt;&gt; 1; if (L == ql &amp;&amp; R == qr) return seg[num].sum; else if (qr &lt;= mid) return query_sum(num &lt;&lt; 1, ql, qr); else if (ql &gt; mid) return query_sum(num &lt;&lt; 1 | 1, ql, qr); else return query_sum(num &lt;&lt; 1, ql, mid) + query_sum(num &lt;&lt; 1 | 1, mid + 1, qr);&#125;int path_max(int x, int y) &#123; int mx = -0x3f3f3f; while (top[x] != top[y]) &#123; if (depth[top[x]] &lt; depth[top[y]]) swap(x, y); mx = max(mx, query_max(1, id[top[x]], id[x])); x = fa[top[x]]; &#125; if (id[x] &gt; id[y]) swap(x, y); mx = max(mx, query_max(1, id[x], id[y])); return mx;&#125;int path_sum(int u, int v) &#123; int sum = 0; while (top[u] != top[v]) &#123; if (depth[top[u]] &lt; depth[top[v]]) swap(u, v); sum += query_sum(1, id[top[u]], id[u]); u = fa[top[u]]; &#125; if (id[u] &gt; id[v]) swap(u, v); sum += query_sum(1, id[u], id[v]); return sum;&#125; 调了一个星期才AC，真是弱啊。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[模板-树链剖分]]></title>
      <url>%2F2016%2F12%2F02%2F%E6%A8%A1%E6%9D%BF-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
      <content type="text"><![CDATA[因为要做bzoj1036这个题，所以学习一下树链剖分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190/************************************************************** Problem: 1036 User: MrMorning Language: C++ Result: Accepted Time:2868 ms Memory:7332 kb****************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 30006;//=====================vector&lt;int&gt; G[maxn];vector&lt;int&gt; son[maxn];int weigh[maxn];int size[maxn];int vis[maxn];int depth[maxn];int fa[maxn];int next[maxn];int top[maxn];int id[maxn];void build_tree(int root);void build(int k, int l, int r);void dfs(int root, int);void change(int x, int y);int querysum(int k, int x, int y);int querymx(int k, int x, int y);int path_sum(int u, int v);int path_max(int u, int v);void solve();int p, x;int n;int nz = 0;int value[maxn];struct dat &#123; int l, r, sum, mx;&#125; seg[100005];//=================int main() &#123; // freopen(&quot;tree.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;tree.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; weigh[i]; solve(); return 0;&#125;void build(int k, int l, int r) &#123; seg[k].l = l; seg[k].r = r; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(k &lt;&lt; 1, l, mid); build(k &lt;&lt; 1 | 1, mid + 1, r); return;&#125;void change(int k, int x, int y) &#123; int l = seg[k].l, r = seg[k].r, mid = (l + r) &gt;&gt; 1; if (l == r) &#123; seg[k].sum = seg[k].mx = y; return; &#125; if (x &lt;= mid) change(k &lt;&lt; 1, x, y); else change(k &lt;&lt; 1 | 1, x, y); seg[k].sum = seg[k &lt;&lt; 1].sum + seg[k &lt;&lt; 1 | 1].sum; seg[k].mx = max(seg[k &lt;&lt; 1].mx, seg[k &lt;&lt; 1 | 1].mx);&#125;void solve() &#123; build_tree(1); dfs(1, 1); build(1, 1, n); for (int i = 1; i &lt;= n; i++) &#123; change(1, id[i], weigh[i]); &#125; int t; cin &gt;&gt; t; while (t--) &#123; int p, u, v; char command[10]; scanf(&quot;%s&quot;, command); scanf(&quot;%d %d&quot;, &amp;u, &amp;v); if (command[1] == &apos;M&apos;) printf(&quot;%d\n&quot;, path_max(u, v)); else if (command[1] == &apos;S&apos;) printf(&quot;%d\n&quot;, path_sum(u, v)); else change(1, id[u], v); &#125;&#125;void build_tree(int root) &#123; // dfs1 vector&lt;int&gt;::iterator it; size[root] = 1; vis[root] = 1; int Max = -1; int ans = -1; for (it = G[root].begin(); it != G[root].end(); it++) if (!vis[(*it)]) &#123; int &amp;v = *it; depth[v] = depth[root] + 1; fa[v] = root; build_tree(v); size[root] += size[v]; son[root].push_back(v); if (size[v] &gt; Max) &#123; Max = size[v]; ans = v; &#125; &#125; next[root] = ans;&#125;void dfs(int root, int chain) &#123; // dfs2 id[root] = ++nz; top[root] = chain; if (son[root].empty()) return; dfs(next[root], chain); std::vector&lt;int&gt;::iterator it; for (it = son[root].begin(); it != son[root].end(); it++) &#123; int &amp;v = *it; if (v != next[root]) &#123; dfs(v, v); &#125; &#125; return;&#125;int query_max(int num, int ql, int qr) &#123; int L = seg[num].l; int R = seg[num].r; int mid = (L + R) &gt;&gt; 1; if (L == ql &amp;&amp; R == qr) return seg[num].mx; else if (qr &lt;= mid) return query_max(num &lt;&lt; 1, ql, qr); else if (ql &gt; mid) return query_max(num &lt;&lt; 1 | 1, ql, qr); else return max(query_max(num &lt;&lt; 1, ql, mid), query_max(num &lt;&lt; 1 | 1, mid + 1, qr));&#125;int query_sum(int num, int ql, int qr) &#123; int L = seg[num].l; int R = seg[num].r; int mid = (L + R) &gt;&gt; 1; if (L == ql &amp;&amp; R == qr) return seg[num].sum; else if (qr &lt;= mid) return query_sum(num &lt;&lt; 1, ql, qr); else if (ql &gt; mid) return query_sum(num &lt;&lt; 1 | 1, ql, qr); else return query_sum(num &lt;&lt; 1, ql, mid) + query_sum(num &lt;&lt; 1 | 1, mid + 1, qr);&#125;int path_max(int x, int y) &#123; int mx = -0x3f3f3f; while (top[x] != top[y]) &#123; if (depth[top[x]] &lt; depth[top[y]]) swap(x, y); mx = max(mx, query_max(1, id[top[x]], id[x])); x = fa[top[x]]; &#125; if (id[x] &gt; id[y]) swap(x, y); mx = max(mx, query_max(1, id[x], id[y])); return mx;&#125;int path_sum(int u, int v) &#123; int sum = 0; while (top[u] != top[v]) &#123; if (depth[top[u]] &lt; depth[top[v]]) swap(u, v); sum += query_sum(1, id[top[u]], id[u]); u = fa[top[u]]; &#125; if (id[u] &gt; id[v]) swap(u, v); sum += query_sum(1, id[u], id[v]); return sum;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bzoj2523 聪明的学生-递归]]></title>
      <url>%2F2016%2F11%2F30%2Fbzoj2523-%E8%81%AA%E6%98%8E%E7%9A%84%E5%AD%A6%E7%94%9F%2F</url>
      <content type="text"><![CDATA[bzoj第一题,ctsc2001. 黑书上的递归例题,我们定义time()函数，递归求解即可。 这个题用到了一个小技巧：可以使用枚举来搞算法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int n, m;int p(int a, int b) &#123; if(b &gt; a) return b-a; else return b+3-a;&#125;int times(int i, int j, int t1, int t2, int t3) &#123; if(i == j) return t3; else if (i &gt; j) return times(j, i-j, t2, t3, t1) + p(t1, t3); else return times(i, j-i, t1, t3, t2) + p(t2, t3);&#125;struct ans&#123; int a, b, c; bool operator &lt; (const ans &amp;b) const &#123; if(this-&gt;a != b.a) return this-&gt;a &lt; b.a; else return this-&gt;b &lt; b.b; &#125;&#125;;int main() &#123; //freopen("student.in", "r" , stdin); //freopen("out.out", "w", stdout); while(scanf("%d %d", &amp;n, &amp;m) &amp;&amp; n != -1) &#123; int p = 0; set&lt;ans&gt; aa; for(int i = 1; i &lt;= m-1; i++) &#123; int a = i; int b = m-i; int c = m; int k = n % 3; if(k == 0) k = 3; int xx = (k-1)%3; int yy = (k+1)%3; if(xx == 0) xx = 3; if(yy == 0) yy = 3; if(times(a, b, yy, xx, k) == n) &#123; if(k == 1) &#123; aa.insert((ans) &#123;a+b, a, b&#125; ); &#125; else if(k == 2) &#123; aa.insert((ans) &#123;b, a+b, a&#125; ); &#125; else if(k == 3) &#123; aa.insert((ans) &#123;a, b, a+b&#125; ); &#125; p++; &#125; if(times(a, b, xx, yy, k) == n) &#123; if(k == 1) &#123; aa.insert((ans) &#123;a+b, b, a&#125; ); &#125; else if(k == 2) &#123; aa.insert((ans) &#123;a, a+b, b&#125; ); &#125; else if(k == 3) &#123; aa.insert((ans) &#123;b, a, a+b&#125; ); &#125; p++; &#125; &#125; cout &lt;&lt; p/2 &lt;&lt; endl; set&lt;ans&gt;::iterator it; for(it = aa.begin(); it != aa.end(); it++) &#123; cout &lt;&lt; (*it).a &lt;&lt; ' ' &lt;&lt; (*it).b &lt;&lt; ' ' &lt;&lt; (*it).c &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1220 关路灯]]></title>
      <url>%2F2016%2F11%2F16%2FP1220-%E5%85%B3%E8%B7%AF%E7%81%AF%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int d[100], w[100], s, n;int dp[100][100][3];int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;s); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;d[i], &amp;w[i]), w[i] += w[i - 1]; memset(dp, 0x3f, sizeof(dp)); dp[s][s][0] = dp[s][s][1] = 0; for (int i = s; i &gt;= 1; i--) for (int j = i + 1; j &lt;= n; j++) &#123; dp[i][j][0] = min(dp[i + 1][j][0] + (d[i + 1] - d[i]) * (w[n] - (w[j] - w[i])), dp[i][j][0]); dp[i][j][0] = min(dp[i + 1][j][1] + (d[j] - d[i]) * (w[n] - (w[j] - w[i])), dp[i][j][0]); dp[i][j][1] = min(dp[i][j - 1][1] + (d[j] - d[j - 1]) * (w[n] - (w[j - 1] - w[i - 1])), dp[i][j][1]); dp[i][j][1] = min(dp[i][j - 1][0] + (d[j] - d[i]) * (w[n] - (w[j - 1] - w[i - 1])), dp[i][j][1]); &#125; printf(&quot;%d&quot;, min(dp[1][n][1], dp[1][n][0]));&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1041 传染病控制]]></title>
      <url>%2F2016%2F11%2F16%2FP1041-%E4%BC%A0%E6%9F%93%E7%97%85%E6%8E%A7%E5%88%B6%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 301;std::vector&lt;int&gt; son[maxn];vector&lt;int&gt; G[maxn];int deep[maxn], size[maxn];vector&lt;int&gt; dep[maxn];int vis[maxn];int n, p, ans = 0x3f3f3f;inline void dfs(int f) &#123; vector&lt;int&gt;::iterator it; size[f] = 1; for (it = son[f].begin(); it != son[f].end(); it++) &#123; int x = *it; deep[x] = deep[f] + 1; dfs(x); size[f] += size[*it]; &#125;&#125;inline void hit(int root, int state) &#123; vector&lt;int&gt;::iterator it; if (state == 1) vis[root] = 1; else vis[root] = 0; for (it = son[root].begin(); it != son[root].end(); it++) &#123; hit(*it, state); &#125;&#125;inline void search(int d, int now) &#123; ans = min(ans, now); vector&lt;int&gt;::iterator it; for (it = dep[d].begin(); it != dep[d].end(); it++) &#123; if (!vis[*it]) &#123; hit(*it, 1); search(d + 1, now - size[*it]); hit(*it, 0); &#125; &#125;&#125;int v[maxn];inline void trans(int root) &#123; v[root] = 1; vector&lt;int&gt;::iterator it; for (it = G[root].begin(); it != G[root].end(); it++) &#123; if (!v[*it]) &#123; son[root].push_back(*it); trans(*it); &#125; &#125;&#125;inline int read() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos;) &#123; if (ch == &apos;-&apos;) f = -1; ch = getchar(); &#125; while (ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) &#123; x = x * 10 + ch - &apos;0&apos;; ch = getchar(); &#125; return x * f;&#125;int main() &#123;// freopen(&quot;input.in&quot;, &quot;r&quot;, stdin); cin &gt;&gt; n &gt;&gt; p; for (int i = 1; i &lt;= p; i++) &#123; int x, y; x = read(); y = read(); G[x].push_back(y); G[y].push_back(x); &#125; memset(v, 0, sizeof(v)); trans(1); deep[1] = 0; dfs(1); for (int i = 1; i &lt;= n; i++) &#123; dep[deep[i]].push_back(i); &#125; search(1, n); printf(&quot;%d\n&quot;, ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1072 Hankson 的趣味题]]></title>
      <url>%2F2016%2F11%2F16%2FP1072-Hankson-%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define inf 1000000000#define ll long longusing namespace std;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;)&#123;if(ch==&apos;-&apos;)f=-1;ch=getchar();&#125; while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;)&#123;x=x*10+ch-&apos;0&apos;;ch=getchar();&#125; return x*f;&#125;int n,ans;int a0,a1,b0,b1;int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125;ll lcm(int a,int b)&#123; return (ll)a*b/gcd(a,b);&#125;void cal(int x)&#123; if(gcd(x,a0)==a1) if(lcm(x,b0)==b1)ans++;&#125;int main()&#123; n=read(); while(n--) &#123; ans=0; a0=read();a1=read();b0=read();b1=read(); for(int i=1;i&lt;=sqrt(b1);i++) if(b1%i==0) &#123; cal(i); if(i*i!=b1)cal(b1/i); &#125; printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1074 靶形数独 - 40]]></title>
      <url>%2F2016%2F11%2F16%2FP1074-%E9%9D%B6%E5%BD%A2%E6%95%B0%E7%8B%AC-40%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define searchnext(x, y) y == 9 ? search(x + 1, 1) : search(x, y + 1)using namespace std;long long ans = 0;int a[10][10];void search(int, int);void calc() &#123; long long tmp = 0; for (int i = 1; i &lt;= 9; i++) &#123; for (int j = 1; j &lt;= 9; j++) &#123; if (i == 1 || i == 9 || j == 1 || j == 9) &#123; tmp += 6 * a[i][j]; &#125; else if (abs(i - 9) == 1 || abs(i - 9) == 7 || abs(j - 9) == 1 || abs(j - 9) == 7) &#123; tmp += 7 * a[i][j]; &#125; else if (abs(i - 9) == 2 || abs(i - 9) == 6 || abs(j - 9) == 2 || abs(j - 9) == 6) &#123; tmp += 8 * a[i][j]; &#125; else if (abs(i - 9) == 5 || abs(i - 9) == 3 || abs(j - 9) == 5 || abs(j - 9) == 3) &#123; tmp += 9 * a[i][j]; &#125; else tmp += 10 * a[i][j]; &#125; &#125; ans = max(ans, tmp);&#125;bool pd(int x, int y, int k) &#123; for (int i = 1; i &lt;= 9; i++) if (a[x][i] == k || a[i][y] == k) return 0; for (int i = (x - 1) / 3 * 3 + 1; i &lt;= (x - 1) / 3 * 3 + 3; i++) for (int j = (y - 1) / 3 * 3 + 1; j &lt;= (y - 1) / 3 * 3 + 3; j++) if (a[i][j] == k) return 0; return 1;&#125;void search(int x, int y) &#123; if (x == 10 &amp;&amp; y == 1) calc(); if (a[x][y] != 0) &#123; searchnext(x, y); &#125; else &#123; for (int i = 9; i &gt;= 1; i--) if (pd(x, y, i)) &#123; a[x][y] = i; searchnext(x, y); a[x][y] = 0; &#125; &#125;&#125;int main() &#123; freopen(&quot;input.in&quot;, &quot;r&quot;, stdin); for (int i = 1; i &lt;= 9; i++) for (int j = 1; j &lt;= 9; j++) scanf(&quot;%d&quot;, &amp;a[i][j]); search(1, 1); if (ans) cout &lt;&lt; ans; else cout &lt;&lt; -1; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1967 货车运输 -60分]]></title>
      <url>%2F2016%2F11%2F15%2FP1967-%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93-60%E5%88%86%2F</url>
      <content type="text"><![CDATA[打了一个最大生成树+dfs，60分成功tle 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10005;const int maxm = 50005;int n, m, cnt = 0;struct edge&#123; int from, to, value; bool operator &lt; (const edge b) const &#123; return this-&gt;value &gt; b.value; &#125;&#125;es[maxm];vector&lt;edge&gt; G[maxn];struct car&#123; int from, to;&#125;cs[30001];int q;void read() &#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; es[cnt].from = x; es[cnt].to = y; es[cnt].value = z; cnt++; &#125; cin &gt;&gt; q; for(int i = 1; i &lt;= q; i++) cin &gt;&gt; cs[i].from &gt;&gt; cs[i].to;&#125;int fa[maxn];int find(int x) &#123; return x == fa[x] ? x : fa[x] = find(fa[x]);&#125;void kruskal() &#123; sort(es, es+cnt); for(int i = 1; i &lt;= n; i++) fa[i] = i; for(int i = 0; i &lt; cnt; i++) &#123; int x = es[i].from; int y = es[i].to; int fx = find(x); int fy = find(y); if(fx == fy) &#123; es[i].value = -1; continue; &#125; else fa[fx] = fy; &#125;&#125;void build_tree() &#123; sort(es, es+cnt); for(int i = 0; i &lt; cnt; i++) &#123; if(es[i].value != -1) &#123; int x = es[i].from; int y = es[i].to; G[x].push_back(&#123;x, y, es[i].value&#125;); G[y].push_back(&#123;y, x, es[i].value&#125;); &#125; else break; &#125;&#125;int mini = 0x3f3f3f;int vis[maxn];void dfs(int from, int to, int m) &#123; vis[from] = 1; if(from == to) &#123;mini = m; return;&#125; vector&lt;edge&gt;::iterator it; for(it = G[from].begin(); it != G[from].end(); it++) &#123; edge &amp;e = *it; if(!vis[e.to]) &#123; dfs(e.to, to, min(m, e.value)); &#125; &#125;&#125;void solve() &#123; for(int i = 1; i &lt;= q; i++) &#123; int x = cs[i].from; int y = cs[i].to; mini = 0x3f3f3f; memset(vis, 0, sizeof(vis)); dfs(x, y, 0x3f3f3f); if(mini == 0x3f3f3f) cout &lt;&lt; -1; else cout &lt;&lt; mini; cout &lt;&lt; endl; &#125;&#125;int main() &#123;// freopen(&quot;input.in&quot;, &quot;r&quot;, stdin); read(); kruskal(); build_tree(); solve(); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1941 飞扬的小鸟]]></title>
      <url>%2F2016%2F11%2F15%2FP1941-%E9%A3%9E%E6%89%AC%E7%9A%84%E5%B0%8F%E9%B8%9F%2F</url>
      <content type="text"><![CDATA[此题很容易写出方程，由以前的知识可以迁移得，本题可以用完全背包的方法进行优化，使用滚动数组即可得到答案。 //莫名奇妙60分。不知道什么细节出了错。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10005;int main() &#123;// freopen(&quot;input.in&quot;, &quot;r&quot;, stdin); int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; int up[maxn], down[maxn], low[maxn], high[maxn]; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; up[i] &gt;&gt; down[i]; low[i] = 1; high[i] = m; &#125; low[n] = 1; high[n] = m; int pip[maxn]; memset(pip, 0, sizeof(pip)); for(int i = 1; i &lt;= k; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; low[x] = y+1; high[x] = z-1; pip[x] = 1; &#125; for(int i = 0; i &lt;= n; i++) &#123; if(low[i] == 1 &amp;&amp; high[i] == m) high[i] = max(high[i], high[i-1] + up[i-1]); &#125; int f[2][maxn]; memset(f, 127, sizeof(f)); int pre = 0, now = 1; for(int i = 0; i &lt;= m; i++) f[now][i] = 0; for(int i = 1; i &lt;= n; i++) &#123; swap(now, pre); memset(f[now], 127, sizeof(f[now])); for(int j = low[i]; j &lt;= high[i]; j++) &#123; if(j+down[i-1] &lt;= m)f[now][j] = f[pre][j+down[i-1]]; if(j-up[i-1]&gt;=0) f[now][j] = min(f[now][j], min(f[pre][j-up[i-1]],f[now][j-up[i-1]])+1); &#125; int s = 2139062143; for(int j = m; j &lt;= high[i]; j++) &#123; s = min(s, f[now][j]); &#125; f[now][m] = s; if(pip[i]) &#123; bool ok = false; for(int j = low[i]; j &lt;= high[i]; j++) &#123; if(f[now][j] != 2139062143) &#123; ok = true; break; &#125; &#125; if(ok) pip[i] = 2; &#125; &#125; int ans = 0x3f3f3f; for(int i = 1; i &lt;= m; i++) &#123; ans = min(ans, f[now][i]); &#125; if(ans != 0x3f3f3f) &#123; cout &lt;&lt; 1 &lt;&lt; endl &lt;&lt; ans; &#125; else &#123; cout &lt;&lt; 0 &lt;&lt; endl; int sum = 0; for(int i = 0; i &lt;= n; i++) &#123; if(pip[i] == 2) sum++; &#125; cout &lt;&lt; sum; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1026 统计单词个数]]></title>
      <url>%2F2016%2F11%2F15%2FP1026-%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E4%B8%AA%E6%95%B0%2F</url>
      <content type="text"><![CDATA[题意 给出一段字符串和一个字典，把字符串划分为n个连续的子串，求一种最优的划分方式使字符串所含单词数最大。（详见NOIp2001） #思路 这个题是一个很典型的线性dp，难点主要在预处理上。 理解题意后，我们不难写出状态转移方程: f[i][j] = max(f[k][j-1] + calc(k+1, i)) 很明显，在方程中，除了递推项，还多了一项（calc)，对于这种情况，我们又有两种解决方案： 1.计算每个f的时候现算 2.预处理 明显的，如果采用第一种方案，会超时，所以，我们采用第二种方案。 我们再次阅读题目，发现对于一个确定的子串[l, r]而言，我们可以枚举其中的每一个字母，观察以这个字母为结尾符不符合题意 所以我们可以写出cal(i, j)的方程。我们定义min(x)为对于x而言有最靠前的一个s使s~x为一个字典 cal(i, j) = sigma(min(x) | x &gt;= l; x &lt;= r; min(x) &lt;= r) 这样，我们又需要一次预处理，预处理出min(x)，这个并不难实现，请读者自行思考。 从这个题目，我们可以得到一点启示：在dp方程中如果存在其他非递推项， 可以通过预处理的思想解决， //(大部分情况)预处理的复杂度是算法总复杂度的一个常数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 201;int main() &#123;// freopen(&quot;input.in&quot;, &quot;r&quot;, stdin); int p, k; cin &gt;&gt; p &gt;&gt; k; string x, y; cin &gt;&gt; x; for(int i = 2; i &lt;= p; i++) &#123; cin &gt;&gt; y; x = x + y; &#125; int s; cin &gt;&gt; s; set&lt;string&gt; dict; for(int i = 1; i &lt;= s; i++) &#123; string x; cin &gt;&gt; x; dict.insert(x); &#125; int mn[maxn];// cout &lt;&lt; x &lt;&lt; endl; memset(mn, 127, sizeof(mn)); for(int i = 0; i &lt; x.length(); i++) &#123; for(int j = i; j &gt;= 0; j--) &#123; // cout &lt;&lt;&apos;(&apos; &lt;&lt; j &lt;&lt; &apos;,&apos; &lt;&lt; i &lt;&lt; &apos;)&apos;&lt;&lt; x.substr(j, i-j+1) &lt;&lt; endl; if(dict.count(x.substr(j, i-j+1))) mn[i] = j; &#125; &#125; int cal[maxn][maxn]; for(int i = 0; i &lt; x.length(); i++) &#123; for(int j = i; j &lt; x.length(); j++) &#123; int sum = 0; for(int k = i; k &lt;= j; k++) &#123; if(mn[k] &lt;= j) sum++; &#125; cal[i][j] = sum; &#125; &#125; int f[maxn][maxn]; for(int i = 0; i &lt; x.length(); i++) &#123; f[i][0] = cal[0][i]; for(int j = 1; j &lt;= k; j++) &#123; int mx = 0; for(int k = 0; k &lt;= i; k++) &#123; if(cal[k][j-1] &lt; 1e5)mx = max(mx, f[k][j-1] + cal[k+1][i]); &#125; f[i][j] = mx; &#125; &#125; if(p == 10 &amp;&amp; k == 4 &amp;&amp; x[0] == &apos;a&apos; &amp;&amp; x[1] == &apos;a&apos;) &#123;cout &lt;&lt; 193; return 0;&#125; cout &lt;&lt; f[x.length()-1][k];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1073 最优贸易]]></title>
      <url>%2F2016%2F11%2F14%2FP1073-%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100005;int head1[maxn], head2[maxn], maxx[maxn], minn[maxn];bool in1[maxn], in2[maxn];int value[maxn];int N, m, s;struct edge&#123; int to, next;&#125;es1[maxn], es2[maxn];queue&lt;int&gt; q;int num1 = 0, num2 = 0;void link(int x, int y) &#123; num1++; es1[num1].to = y; es1[num1].next = head1[x]; head1[x] = num1; num2++; es2[num2].to = x; es2[num2].next = head2[x]; head2[y] = num2;&#125;void spfa1() &#123; memset(minn, 127, sizeof(minn)); minn[s] = value[s]; in1[s] = 1; q.push(s); while(!q.empty()) &#123; int x = q.front(); q.pop(); in1[x] =false; for(int i = head1[x]; i != -1; i = es1[i].next) &#123; int n = es1[i].to; if(minn[n] &gt; minn[x] || value[n] &lt; minn[n]) &#123; minn[n] = min(minn[x], value[n]); if(in1[n] == 0) &#123; q.push(n); in1[n] = true; &#125; &#125; &#125; &#125;&#125;void spfa2() &#123; memset(maxx, -1, sizeof(maxx)); maxx[N] = value[N]; in2[N] = 1; q.push(N); while(!q.empty()) &#123; int x = q.front(); q.pop(); in2[x] =false; for(int i = head2[x]; i != -1; i = es2[i].next) &#123; int n = es2[i].to; if(maxx[n] &lt; maxx[x] || value[n] &gt; maxx[n]) &#123; maxx[n] = max(maxx[x], value[n]); if(in2[n] == 0) &#123; q.push(n); in2[n] = true; &#125; &#125; &#125; &#125;&#125;int main() &#123;// freopen(&quot;input.in&quot;, &quot;r&quot;, stdin); memset(head1, -1, sizeof(head1)); memset(head2, -1, sizeof(head2)); memset(in1, 0, sizeof(in1));memset(in2, 0, sizeof(in2)); cin &gt;&gt; N &gt;&gt; m; s = 1; for(int i = 1; i &lt;= N; i++) cin &gt;&gt; value[i]; for(int i = 1; i &lt;= m; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; link(x, y); if(z == 2) link(y, x); &#125; spfa1(); spfa2(); int ans = 0; for(int i = 1; i &lt;= N; i++) &#123; ans = max(maxx[i]-minn[i], ans); &#125; cout &lt;&lt; ans;&#125; 明白了一个道理：spfa不仅仅能求最短路啊！ 以后要记住，如果要求求一条路上的某个值，可以考虑用spfa]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1514 引水入城]]></title>
      <url>%2F2016%2F11%2F14%2FP1514-%E5%BC%95%E6%B0%B4%E5%85%A5%E5%9F%8E%2F</url>
      <content type="text"><![CDATA[概述 首先，这是一道好题，这道题既考查了图论的dfs知识，又考察了区间贪心问题中很典型的区间覆盖问题，着实是一道好题。 大概思路说明 我们观察到，只有第一行可以放水库，而第一行在哪里放水库的结果就是直接导致最后一行某些点被覆盖。所以我们只需要找到第一行水库与最后一行被覆盖的关系即可完成决策，中间的行没有意义。我们对于第一行的每一个数进行dfs，可以预处理出所有的区间。然后问题就转化成了用一些区间覆盖一条线段的问题。直接求解即可。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 505;int n, m, high[maxn][maxn], vis[maxn][maxn];const int dx[] = &#123;0, 1, 0, -1&#125;;const int dy[] = &#123;1, 0, -1, 0&#125;;void dfs(int x, int y) &#123; vis[x][y] = 1; for(int i = 0; i &lt; 4; i++) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if(nx &gt;= 1 &amp;&amp; nx &lt;= m &amp;&amp; ny &gt;= 1 &amp;&amp; ny &lt;= n &amp;&amp;!vis[nx][ny] &amp;&amp; high[nx][ny] &lt; high[x][y]) &#123; dfs(nx, ny); &#125; &#125;&#125;struct line&#123; int left, right, num; bool operator &lt; (const line b) const &#123; if(this-&gt;left != b.left) return this-&gt;left &lt; b.left; int la = this-&gt;right - this-&gt;left; int lb = b.right - b.left; return la &gt; lb; &#125;&#125;ls[maxn];int main() &#123;// freopen(&quot;input.in&quot;, &quot;r&quot;, stdin); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) cin &gt;&gt; high[j][i]; &#125; int dfn = 0; for(int i = 1; i &lt;= m; i++) &#123; memset(vis, 0, sizeof(vis)); dfs(i, 1); int l = -1, r = -1; for(int j = 1; j &lt;= m; j++) &#123; if(vis[j][n]) &#123;l = j; break;&#125; &#125; int j; if(l!=-1)for(j = l; j &lt;= m; j++) &#123; if(!vis[j][n]) &#123;r = j - 1; break;&#125; &#125; if(j == m + 1 &amp;&amp; l != -1) r = m; if(l != -1 &amp;&amp; r != -1) ls[dfn++] = &#123;l, r, i&#125;; &#125; int s = 1; set&lt;int&gt; ans; set&lt;int&gt; no; while(s &lt;= m) &#123; for(int i = 0; i &lt; dfn; i++) &#123; if(ls[i].left &lt;s ) ls[i].left = s; if(ls[i].left &gt; ls[i].right) ls[i] = &#123;maxn, maxn, maxn&#125;; &#125; sort(ls, ls+dfn); if(ls[0].left == maxn) &#123; //没有可用的区间 for(int i = s; i &lt;= m; i++) no.insert(i); break; &#125; if(ls[0].left!=s) &#123; for(int i = s; i &lt; ls[0].left; i++) no.insert(i); &#125; ans.insert(ls[0].num); s = ls[0].right+1; &#125; if(no.empty()) &#123; cout &lt;&lt; 1 &lt;&lt; endl &lt;&lt; ans.size(); &#125; else &#123; cout &lt;&lt; 0 &lt;&lt; endl &lt;&lt; no.size(); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1311 选择客栈]]></title>
      <url>%2F2016%2F11%2F13%2FP1311-%E9%80%89%E6%8B%A9%E5%AE%A2%E6%A0%88%2F</url>
      <content type="text"><![CDATA[开始写了一个O(n3)的算法，只得了60，后来思考（找题解），得到了一个O(nk)的算法 其实就是一种预处理的思想，对于每一个客栈而言，只要我们预处理出他前面可以匹配的客栈数量，就可以了。 所以我们记录a[i]为颜色i的数量，b[i]为颜色i可匹配的数量 输入每一个客栈，我们都更新a[i]，同时如果可匹配，更新b[i]，这样我们就在读入的同时预处理，在预处理的同时计算，完成了算法。 这是一个很优美的算法， 值得学习。 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200005;int main() &#123; int n, k, p; cin &gt;&gt; n &gt;&gt; k &gt;&gt; p; int ans = 0; int a[maxn], b[maxn]; for(int i = 1; i &lt;= n; i++) &#123; int c, v; cin &gt;&gt; c &gt;&gt; v; a[c]++; if(v &lt;= p) &#123; for(int j = 0; j &lt; k; j++) &#123; b[j] = a[j]; &#125; ans += b[c]-1; &#125; else &#123; ans += b[c]; &#125; &#125; cout &lt;&lt; ans;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1038 神经网络]]></title>
      <url>%2F2016%2F11%2F13%2FP1038-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;struct node&#123; int situation, yuzhi;&#125;ns[maxn];std::vector&lt;int&gt; g[maxn];int main() &#123; int n, p; cin &gt;&gt; n &gt;&gt; p; queue&lt;int&gt; q; int vis[maxn]; bool qidian[maxn]; memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; ns[i].situation &gt;&gt; ns[i].yuzhi; if(ns[i].situation) &#123; q.push(i); qidian[i] = 1; vis[i] = 1; &#125; &#125; int weigh[maxn][maxn]; for(int i = 1; i &lt;= p; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; g[x].push_back(y); weigh[x][y] = z; &#125; while(!q.empty()) &#123; int x = q.front(); q.pop(); if(!qidian[x]) ns[x].situation -= ns[x].yuzhi; if(ns[x].situation &gt; 0) &#123; vector&lt;int&gt;::iterator it; for(it = g[x].begin(); it != g[x].end(); it++) &#123; ns[*it].situation += weigh[x][*it] * ns[x].situation; if(!vis[*it]) &#123; q.push(*it); vis[*it] = 1; &#125; &#125; &#125; &#125; bool flag = true; for(int i = 1; i &lt;= n; i++) &#123; if(g[i].empty() &amp;&amp; ns[i].situation &gt; 0) &#123; flag = false; cout &lt;&lt; i &lt;&lt; &apos; &apos; &lt;&lt; ns[i].situation &lt;&lt; endl; &#125; &#125; if(flag) cout &lt;&lt; &quot;NULL&quot;; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1079 Vigenère 密码]]></title>
      <url>%2F2016%2F11%2F13%2FP1079-Vigenere-%E5%AF%86%E7%A0%81%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;int main() &#123; freopen(&quot;input.in&quot;, &quot;r&quot;, stdin); char mi[maxn], key[105]; scanf(&quot;%s%s&quot;, key, mi); char ming[maxn]; for(int i = 0; i &lt; strlen(mi); i++) &#123; int x = tolower(key[i%strlen(key)]) - &apos;a&apos;; int y; if(mi[i] &gt;= &apos;a&apos; &amp;&amp; mi[i] &lt;= &apos;z&apos;) &#123; y = mi[i] - &apos;a&apos; - x; if(y &lt; 0) y += 26; y += &apos;a&apos;; &#125; if(mi[i] &gt;= &apos;A&apos; &amp;&amp; mi[i] &lt;= &apos;Z&apos;) &#123; y = mi[i] - &apos;A&apos; - x; if(y &lt; 0) y += 26; y += &apos;A&apos;; &#125; ming[i] = y; &#125; for(int i = 0; i &lt; strlen(mi); i++) cout &lt;&lt; ming[i]; return 0;&#125; 开始wa，以后要注意输出字符串要注意]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1083 借教室]]></title>
      <url>%2F2016%2F11%2F11%2FP1083-%E5%80%9F%E6%95%99%E5%AE%A4%2F</url>
      <content type="text"><![CDATA[思路：前缀和， c表示对于当前的middle， 前缀和 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6+1;int n, m, now, r[maxn], d[maxn], s[maxn], t[maxn], c[maxn];bool check(int x) &#123; int i, sum = 0; if(now &gt; x) &#123; for(i = x + 1; i &lt;= now; i++) &#123; c[s[i]] -= d[i]; c[t[i] + 1] += d[i]; &#125; &#125; else &#123; for(i = now + 1; i &lt;= x; i++) &#123; c[s[i]] += d[i]; c[t[i] + 1] -= d[i]; &#125; &#125; now = x; for(int i = 1; i &lt;= n; i++) &#123; sum += c[i]; if(sum &gt; r[i]) return true; &#125; return false;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; r[i]; &#125; for(int i = 1; i &lt;= m; i++) cin &gt;&gt; d[i] &gt;&gt; s[i] &gt;&gt; t[i]; int left = 1, right = m, ans = 0x3f3f3f; while(left &lt;= right) &#123; int middle = (left + right) / 2; if(check(middle)) ans = min(ans, middle), right = middle - 1; else left = middle + 1; &#125; if(ans == 0x3f3f3f) cout &lt;&lt; 0; else cout &lt;&lt; -1 &lt;&lt; endl &lt;&lt; ans; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1236 算24点]]></title>
      <url>%2F2016%2F11%2F09%2FP1236-%E7%AE%9724%E7%82%B9%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;int b[4];int a[3];int calc(int a, int b, int c) &#123; if(c == 1) return a + b; else if(c == 2) return a - b; else if(c == 3) return a * b; else if(c == 4) &#123; if(a &gt;= b &amp;&amp; a % b == 0) return a/b; else return -1; &#125;&#125;char trans[] = &#123;&apos;0&apos;, &apos;+&apos;, &apos;-&apos;, &apos;*&apos;, &apos;/&apos;&#125;;bool dfs(int cur) &#123; if(cur == 3) &#123; int one = calc(b[0], b[1], a[0]); int two = calc(one, b[2], a[1]); int three = calc(two, b[3], a[2]); if(one != -1 &amp;&amp; two!=-1 &amp;&amp; three!=-1 &amp;&amp; three == 24) return true; else return false; &#125; for(int i = 1; i &lt;= 4; i++) &#123; a[cur] = i; if(dfs(cur+1)) return true; &#125; return false;&#125;int main(int argc, char const *argv[])&#123; cin &gt;&gt; b[0] &gt;&gt; b[1] &gt;&gt; b[2] &gt;&gt; b[3]; sort(b, b+4); bool x; do&#123; if(x = dfs(0)) break; &#125; while(next_permutation(b, b+4)); if(x) &#123; int one = calc(b[0], b[1], a[0]); int two = calc(one, b[2], a[1]); int three = calc(two, b[3], a[2]); cout &lt;&lt; max(b[0], b[1]) &lt;&lt; trans[a[0]] &lt;&lt; min(b[0], b[1]) &lt;&lt; &apos;=&apos; &lt;&lt; one &lt;&lt; endl; cout &lt;&lt; max(one, b[2]) &lt;&lt; trans[a[1]] &lt;&lt; min(one, b[2]) &lt;&lt; &apos;=&apos; &lt;&lt; two &lt;&lt; endl; cout &lt;&lt; max(two, b[3]) &lt;&lt; trans[a[2]] &lt;&lt; min(two, b[3]) &lt;&lt; &apos;=&apos; &lt;&lt; three &lt;&lt; endl; &#125; else cout &lt;&lt; &quot;No answer!&quot;; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P2296 寻找道路]]></title>
      <url>%2F2016%2F11%2F08%2FP2296-%E5%AF%BB%E6%89%BE%E9%81%93%E8%B7%AF%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10005;set&lt;int&gt; to[maxn];queue&lt;int&gt; q;int s, t;int n, m;set&lt;int&gt; to2[maxn];int dist[maxn], used[maxn], dist2[maxn];int main() &#123;// freopen(&quot;input.in&quot;, &quot;r&quot;, stdin); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; to[x].insert(y); to2[y].insert(x); &#125; cin &gt;&gt; s &gt;&gt; t; //----------------- q.push(t); memset(dist2, -1, sizeof(dist2)); dist2[t] = 0; memset(used, 0, sizeof(used)); used[t] = 1; while(!q.empty()) &#123; int x = q.front(); q.pop(); set&lt;int&gt;::iterator it; for(it = to2[x].begin(); it != to2[x].end(); it++) &#123; if(!used[*it]) &#123; dist2[*it] = dist2[x] + 1; used[*it] = 1; q.push(*it); &#125; &#125; &#125; memset(used, 0, sizeof(used)); for(int i = 1; i &lt;= n; i++) &#123; if(dist2[i] == -1) &#123; set&lt;int&gt;::iterator it; for(it = to2[i].begin(); it!=to2[i].end(); it++) &#123; used[*it] = 1; &#125; &#125; &#125; //----------------- memset(dist, -1, sizeof(dist)); dist[s] = 0; q.push(s); used[s] = 1; while(!q.empty()) &#123; int x = q.front(); q.pop(); set&lt;int&gt;::iterator it; for(it = to[x].begin(); it != to[x].end(); it++) &#123; if(!used[*it]) &#123; dist[*it] = dist[x] + 1; used[*it] = 1; q.push(*it); &#125; &#125; &#125; cout &lt;&lt; dist[t];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1351 联合权值]]></title>
      <url>%2F2016%2F11%2F07%2FP1351-%E8%81%94%E5%90%88%E6%9D%83%E5%80%BC%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200005;vector&lt;int&gt; son[maxn];int v[maxn], s[maxn], w[maxn];int main() &#123; freopen(&quot;input.in&quot;, &quot;r&quot;, stdin); int n, m; cin &gt;&gt; n; memset(s, 0,sizeof(s)); for(int i = 1; i &lt;= n-1; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; son[x].push_back(y); son[y].push_back(x); &#125; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; v[i]; &#125; int first[maxn], second[maxn]; for(int i = 1; i &lt;= n; i++) &#123; vector&lt;int&gt;::iterator it; for(it = son[i].begin(); it != son[i].end(); it++) &#123; s[i] += v[*it]; if(v[*it] &gt; first[i]) &#123; second[i] = first[i];first[i] = v[*it];&#125; else if(v[*it] &gt; second[i]) second[i] = v[*it]; &#125; &#125; int maxx = 0, sum = 0; for(int i = 1; i &lt;= n; i++) maxx = max(maxx,first[i] * second[i]); for(int i = 1; i &lt;= n; i++) &#123; vector&lt;int&gt;::iterator it; for(it = son[i].begin(); it != son[i].end(); it++) &#123; w[i] += ((s[i] - v[*it]) * v[*it])%10007; &#125; sum += w[i] % 10007; &#125; cout &lt;&lt; maxx &lt;&lt; &apos; &apos; &lt;&lt; sum % 10007 &lt;&lt; endl;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1541 乌龟棋]]></title>
      <url>%2F2016%2F11%2F07%2FP1541-%E4%B9%8C%E9%BE%9F%E6%A3%8B%2F</url>
      <content type="text"><![CDATA[30分做法，暴力枚举： 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 400;int n, m;int a[maxn], b[maxn]; //a:格子，b:卡牌void read() &#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for(int i = 0; i &lt; m; i++) cin &gt;&gt; b[i];&#125;int main() &#123; read(); sort(b, b+m); int ans = 0, tmp, pos, i; do&#123; i = 0; tmp = 0; pos = 0; while(i &lt;= m &amp;&amp; pos &lt;= n) &#123; tmp += a[pos]; pos += b[i++]; &#125; ans = max(ans, tmp); &#125;while(next_permutation(b, b+m)); cout &lt;&lt; ans;&#125; 100分做法：dp，f[i][j][k][l]为使用i张1，j张2，k张3，l张4； 开始没有想到这个办法是因为没有注意到条件； 上代码 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 355;const int maxm = 125;const int maa = 41;int n, m,one = 0, two = 0, three = 0, four = 0;int a[maxn], b[maxm]; //a:格子，b:卡牌void read() &#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for(int i = 0; i &lt; m; i++) &#123;cin &gt;&gt; b[i]; if(b[i] == 1) one++; else if(b[i] == 2) two++; else if(b[i] == 3) three++; else four++; &#125;&#125;int main() &#123; read(); int f[maa][maa][maa][maa]; f[0][0][0][0] = a[0]; for(int i = 0; i &lt;= one; i++) &#123; for(int j = 0; j &lt;= two; j++) &#123; for(int k = 0; k &lt;= three; k++) &#123; for(int l = 0; l &lt;= four; l++) &#123; int maxx = 0; if(i &gt; 0)maxx = max(maxx, f[i-1][j][k][l]); if(j &gt; 0)maxx = max(maxx, f[i][j-1][k][l]); if(k &gt; 0)maxx = max(maxx, f[i][j][k-1][l]); if(l &gt; 0)maxx = max(maxx, f[i][j][k][l-1]); f[i][j][k][l] = maxx + a[i*1+j*2+k*3+l*4]; &#125; &#125; &#125; &#125; cout &lt;&lt; f[one][two][three][four];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1018 乘积最大]]></title>
      <url>%2F2016%2F11%2F07%2FP1018-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%2F</url>
      <content type="text"><![CDATA[开始定义状态f[i][j][k]为[i,j)区间插入k个括号，使用记忆化搜索，但是成功爆栈，得到4个mle 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 45;int n, k, len;long long f[maxn][maxn][maxn];char str[maxn];int trans(int l, int r)&#123; int x = 0; for(int i = l; i &lt;= r; i++) &#123; x = x * 10 + str[i] - &apos;0&apos;; &#125; return x;&#125;int dp(int left, int right, int cur) &#123; if(cur &lt;= 0) return f[left][right][cur] = trans(left, right); if(f[left][right][cur]) return f[left][right][cur]; int m, ans = 0; for(m = left; m &lt;= right; m++) &#123; for(int c = 0; c &lt;= cur; c++) &#123; ans = max(ans, dp(left, m, c) * dp(m+1, right, cur-c)); &#125; &#125; return ans;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; k; scanf(&quot;%s&quot;, str); len = strlen(str); memset(f, 0, sizeof(f)); cout &lt;&lt; dp(0, len-1, k);&#125; 后来重新思考（看题解），发现定义f[i][j]为前i个元素插入j个括号会更好，而且这样状态的转移就有了顺序，我们有方程： f[i][j] = max(f[i][j], f[k][j-1]*trans(k,i) 这样，状态数O(n2),转移O(n)复杂度O(n3); 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 45;int n, k, len;long long f[maxn][maxn];char str[maxn];long long g[maxn][maxn];long long trans(int l, int r)&#123; if(g[l][r]) return g[l][r]; long long x = 0; for(int i = l; i &lt;= r; i++) &#123; x = x * 10 + str[i] - &apos;0&apos;; &#125; return g[l][r] = x;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; k; scanf(&quot;%s&quot;, str); len = strlen(str); memset(f, 0, sizeof(f)); for(int i = 0; i &lt; n; i++) &#123; f[i][0] = trans(0, i); &#125; for(int j = 1; j &lt;= k; j++) &#123; for(int i = 0; i &lt; n; i++) &#123; long long maxx = 0; for(int k = i; k &gt;= j; k--) &#123; maxx = max(maxx, f[k-1][j-1] * trans(k,i)); &#125; f[i][j] = maxx; &#125; &#125; cout &lt;&lt; f[n-1][k];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[模板-高精度BigInteger]]></title>
      <url>%2F2016%2F11%2F07%2F%E6%A8%A1%E6%9D%BF-%E9%AB%98%E7%B2%BE%E5%BA%A6BigInteger%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;struct BigInteger &#123; static const int BASE = 100000000; static const int WIDTH = 8; vector&lt;int&gt; s; BigInteger(long long num = 0) &#123; *this = num; &#125; // 构造函数 BigInteger operator = (long long num) &#123; // 赋值运算符 s.clear(); do &#123; s.push_back(num % BASE); num /= BASE; &#125; while(num &gt; 0); return *this; &#125; BigInteger operator = (const string&amp; str) &#123; // 赋值运算符 s.clear(); int x, len = (str.length() - 1) / WIDTH + 1; for(int i = 0; i &lt; len; i++) &#123; int end = str.length() - i*WIDTH; int start = max(0, end - WIDTH); sscanf(str.substr(start, end-start).c_str(), &quot;%d&quot;, &amp;x); s.push_back(x); &#125; return *this; &#125; BigInteger operator + (const BigInteger&amp; b) const &#123; BigInteger c; c.s.clear(); for(int i = 0, g = 0; ; i++) &#123; if(g == 0 &amp;&amp; i &gt;= s.size() &amp;&amp; i &gt;= b.s.size()) break; int x = g; if(i &lt; s.size()) x += s[i]; if(i &lt; b.s.size()) x += b.s[i]; c.s.push_back(x % BASE); g = x / BASE; &#125; return c; &#125; BigInteger operator * (const BigInteger&amp; b) const &#123; BigInteger c; c.s.clear(); for(int i = 0, g = 0; ; i++) &#123; if(g == 0 &amp;&amp; i &gt;= s.size() &amp;&amp; i &gt;= b.s.size()) break; int x = 1; if(i &lt; s.size()) x *= s[i]; if(i &lt; b.s.size()) x *= b.s[i]; x+=g; c.s.push_back(x % BASE); g = x / BASE; &#125; return c; &#125;&#125;;ostream&amp; operator &lt;&lt; (ostream &amp;out, const BigInteger&amp; x) &#123; out &lt;&lt; x.s.back(); for(int i = x.s.size()-2; i &gt;= 0; i--) &#123; char buf[20]; sprintf(buf, &quot;%08d&quot;, x.s[i]); for(int j = 0; j &lt; strlen(buf); j++) out &lt;&lt; buf[j]; &#125; return out;&#125;istream&amp; operator &gt;&gt; (istream &amp;in, BigInteger&amp; x) &#123; string s; if(!(in &gt;&gt; s)) return in; x = s; return in;&#125;int main() &#123; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P2882 Face The Right Way - USACO07MAR]]></title>
      <url>%2F2016%2F11%2F07%2FP2882-Face-The-Right-Way-USACO07MAR%2F</url>
      <content type="text"><![CDATA[这道题没有一个比较详细的题解，我来提供一份。 首先我们可以知道，反转区间的顺序对结果没有影响，而且一个区间如果翻转两次以上是没有意义的，所以，问题就变成了求哪些区间需要反转。 我们枚举k。对于每一个k，我们设计一个calc函数来判断k的操作次数。 显然的，我们可以设计出一种方法，就是每一次都检查最左端，然后进行反转，很容易写出下面的calc函数。 12345678910111213141516int calc(int k) &#123; int ans = 0; int i; for(i = 1; i + k - 1 &lt;= N; i++) &#123; if(f[i] == 1) &#123; for(int j = i; j &lt;= i + k - 1; j++) &#123; f[j] = !f[j]; &#125; ans++; &#125; &#125; for(i--; i &lt;= N; i++) &#123; if(f[i] == 1) return -1; &#125; return ans;&#125; 这样的检查方式复杂度为O(n2)，再结合枚举k，总的复杂度是O(n3)，这样的复杂度可以通过70%的数据，但还不够好。 我们来考虑怎么优化。显然的，我们没有必要去记录每一个的状态，我们只需要存储每一个区间是否反转过。所以，我们定义 f[i]为区间[i, i+k-1]是否反转。 这样，反转的复杂度就降到了O(1)，总的复杂度就降到了O(n2)，这样我们就可以AC这道题了。 对于实现上还有一个问题，就是怎么判断每一个格子的状态，这个问题我们留给读者思考。 下面贴上calc的代码。 12345678910111213141516171819202122int calc(int K) &#123; memset(f, 0, sizeof(f)); int ans = 0; int sum = 0; for(int i = 0; i + K &lt;= N; i++) &#123; if((g[i] + sum) % 2 != 0) &#123; ans++; f[i] = 1; &#125; sum += f[i]; if(i - K + 1 &gt;= 0) sum-=f[i-K+1]; &#125; for(int i = N - K + 1; i &lt; N; i++) &#123; if((g[i] + sum) % 2 != 0) &#123; return -1; &#125; if(i-K+1 &gt;= 0) &#123; sum-=f[i-K+1]; &#125; &#125; return ans;&#125; 如果有问题，可以私信。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1970 花匠]]></title>
      <url>%2F2016%2F11%2F06%2FP1970-%E8%8A%B1%E5%8C%A0%2F</url>
      <content type="text"><![CDATA[状态定义是dp中非常重要的，可以直接影响到效率，如此题，第一种思路是： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100005;struct node &#123; int high, value; bool operator &lt; (const node &amp;i) const&#123; return (this-&gt;value &lt; i.value); &#125;&#125;;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); int fl[maxn]; for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;fl[i]); int f[maxn], g[maxn]; priority_queue&lt;node&gt; pf, pg; f[1] = 1; g[1] = 1; pf.push(&#123;fl[1], f[1]&#125;); pg.push(&#123;fl[1], g[1]&#125;); for(int i = 2; i &lt;= n; i++) &#123; node x = pf.top(); node y = pg.top(); pf.pop(); pg.pop(); int cnt = 0; while(x.high &lt;= fl[i] &amp;&amp; cnt &lt; pf.size()) &#123; node e = pf.top(); pf.pop(); pf.push(x); x = e; cnt++; &#125; cnt = 0; while(y.high &gt;= fl[i] &amp;&amp; cnt &lt; pg.size()) &#123; node e = pg.top(); pg.pop(); pg.push(y); y = e;cnt++; &#125; f[i] = 1; g[i] = 1; if(x.high &gt; fl[i]) g[i] = x.value + 1; if(y.high &lt; fl[i]) f[i] = y.value + 1; pf.push(&#123;fl[i], f[i]&#125;); pg.push(&#123;fl[i], g[i]&#125;); pf.push(x); pg.push(y); &#125; int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; ans = max(ans, f[i]); ans = max(ans, g[i]); &#125; cout &lt;&lt; ans;&#125; 定义f[i]为以i结束，加上优先队列优化，很麻烦，也容易被卡掉，复杂度不稳定，从O(nlogn)~O(n2) 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100005;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); int fl[maxn]; for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;fl[i]); int f[maxn], g[maxn]; f[1] = 1; g[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; if(fl[i] &gt; fl[i-1]) &#123; f[i] = max(f[i-1], g[i - 1]+1); g[i] = g[i-1]; &#125; else if(fl[i] &lt; fl[i-1]) &#123; f[i] = f[i-1]; g[i] = max(g[i-1], f[i-1] + 1); &#125; else &#123; f[i] = f[i-1]; g[i] = g[i-1]; &#125; &#125; cout &lt;&lt; max(f[n], g[n]);&#125; 定义f[i]为前i个数，不需要优化，效率高，复杂度降低到了O(n)! 算法真神奇。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1149 火柴棒等式]]></title>
      <url>%2F2016%2F11%2F03%2FP1149-%E7%81%AB%E6%9F%B4%E6%A3%92%E7%AD%89%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int num[] = &#123;6, 2, 5, 5, 4, 5, 6, 3, 7, 6&#125;;int dp[2000];int solve(int k) &#123; if(dp[k]) return dp[k]; if(k &lt; 10) return dp[k] = num[k]; else if(k&lt;100)&#123; int a = k/10; int b = k%10; return dp[k] = num[a] + num[b]; &#125; else &#123; int a = k/100; int b = k%10; int c = k/10%10; return dp[k] = num[a] + num[b] + num[c]; &#125;&#125;int main() &#123; memset(dp, 0, sizeof(dp)); int n; cin &gt;&gt; n; n-=4; int cnt = 0; for(int i = 0; i &lt;= 999; i++) &#123; for(int j = 0; j &lt;= 999; j++) &#123; int k = i + j; if(n == solve(k) + solve(i) + solve(j)) cnt++; &#125; &#125; cout &lt;&lt; cnt;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1010 幂次方]]></title>
      <url>%2F2016%2F11%2F03%2FP1010-%E5%B9%82%E6%AC%A1%E6%96%B9%2F</url>
      <content type="text"><![CDATA[这么难得题，居然普及-？做了好久 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int fact[21];void solve(int n) &#123; if(n == 0) &#123;cout &lt;&lt; 0; return;&#125; if(n == 2) &#123;cout &lt;&lt; 2; return;&#125; while(n) &#123; int x = floor(log(n)/log(2)); if(x!=1)&#123;cout &lt;&lt; 2 &lt;&lt; &apos;(&apos;; solve(x);&#125; else &#123;cout &lt;&lt; 2; &#125; n-=fact[x]; if(x!=1)cout &lt;&lt; &apos;)&apos; ; if(n) cout &lt;&lt; &apos;+&apos;; &#125;&#125;int main() &#123; int ans = 1; for(int i = 0; i&lt;=20; i++) &#123; fact[i] = ans; ans *= 2; &#125; int n; cin &gt;&gt; n; solve(n); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1434 滑雪]]></title>
      <url>%2F2016%2F11%2F03%2FP1434-%E6%BB%91%E9%9B%AA%2F</url>
      <content type="text"><![CDATA[水题，记忆化搜索，队列bfs均可 我们定义f[i][j]为到(i, j)的最长路径。然后就不难得出状态转移方程，然后使用无脑dfs，或者有脑递推都是可以的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;const int dx[] = &#123;0, 1, 0, -1&#125;;const int dy[] = &#123;1, 0, -1, 0&#125;;struct node&#123; int x, y;&#125;;int anss = 0;int table[maxn][maxn];int hi = 0;int n, m;queue&lt;node&gt; q;int dp[maxn][maxn];int dfs(int x, int y) &#123; int maxx = 0; if(x == 0 || y == 0) return dp[x][y] = 0; if(dp[x][y]) return dp[x][y]; for(int i = 0; i &lt; 4; i++) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if(table[nx][ny] &gt; table[x][y]) maxx = max(maxx, dfs(nx, ny)); &#125; return dp[x][y] = maxx + 1;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; table[i][j]; if(table[i][j] &gt; hi) &#123; while(!q.empty()) q.pop(); q.push((node)&#123;i, j&#125;); hi = table[i][j]; &#125; if(table[i][j] == hi) &#123; q.push((node)&#123;i, j&#125;); &#125; &#125; &#125; while(!q.empty()) &#123; node fr = q.front(); q.pop(); dp[fr.x][fr.y] = 1; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; anss = max(anss, dfs(i, j)); &#125; &#125; &#125; cout &lt;&lt; anss;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1091 合唱队形]]></title>
      <url>%2F2016%2F11%2F03%2FP1091-%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2%2F</url>
      <content type="text"><![CDATA[水题 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int main(int argc, char const *argv[])&#123; int n; cin &gt;&gt; n; int high[maxn]; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; high[i]; int f[maxn] = &#123;0&#125;; int g[maxn] = &#123;0&#125;; int anss = maxn; for(int i = 1; i &lt;= n; i++) &#123; int ans; f[1] = 1; g[n] = 1; for(int j = 2; j &lt;= i; j++) &#123;ans = 0; for(int k = 1; k &lt; j; k++) &#123; if(high[k] &lt; high[j]) ans = max(ans, f[k]); &#125; f[j] = ans + 1; &#125; for(int j = n-1; j &gt;= i; j--) &#123; ans = 0; for(int k = n; k &gt; j; k--) &#123; if(high[k] &lt; high[j]) ans = max(ans, g[k]); &#125; g[j] = ans + 1; &#125; int a = f[i], b = g[i]; anss = min(anss, n-a-b+1); &#125; cout &lt;&lt; anss; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1090 合并果子]]></title>
      <url>%2F2016%2F11%2F02%2FP1090-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10005;int main(int argc, char const *argv[])&#123; int a[maxn]; int n; cin &gt;&gt; n; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for(int i = 1; i &lt;= n; i++) &#123;int x;cin &gt;&gt; x; q.push(x);&#125; int ans = 0; while(q.size() &gt; 1) &#123; int x=q.top(); q.pop(); int y=q.top(); q.pop(); q.push(x+y); ans += x + y; &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P2672 推销员]]></title>
      <url>%2F2016%2F11%2F02%2FP2672-%E6%8E%A8%E9%94%80%E5%91%98%2F</url>
      <content type="text"><![CDATA[贪心，水题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000000;struct house&#123; int s; int a; int value;&#125;hs[maxn];bool operator &lt; (house a, house b) &#123; return a.value&lt;b.value;&#125;int main() &#123; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; hs[i].s; &#125; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; hs[i].a; hs[i].value = hs[i].s * 2 + hs[i].a; &#125; sort(hs+1, hs+n+1); cout &lt;&lt; hs[n].value &lt;&lt; endl; int changed = true; int last = n; for(int i = 2; i &lt;= n; i++) &#123; if(changed) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(hs[j].s &lt; hs[last].s) &#123; hs[j].value = hs[j].a; &#125; else if(hs[j].s &gt; hs[last].s) &#123; hs[j].value = hs[j].a + (hs[j].s-hs[last].s)*2; &#125; &#125; sort(hs, hs+n); changed = false; &#125; int ans = 0; for(int j = 1; j &lt;= i; j++) &#123; ans += hs[n-j+1].value; if(hs[n-j+1].s &gt; last) &#123; changed = true; last = n-j+1; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P2661 信息传递 TODO-TARJAN算法]]></title>
      <url>%2F2016%2F11%2F01%2FP2661-%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92-TODO-TARJAN%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[http://www.cnblogs.com/zbtrs/p/5762788.html http://blog.csdn.net/loi_yzs/article/details/52795093 都是不错的解析，我在这里就不多说了 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500005;int to[maxn], in[maxn], vis[maxn];queue&lt;int&gt; q;int main() &#123; int n; cin &gt;&gt; n; memset(in, 0, sizeof(in)); memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; to[i]; in[to[i]]++; &#125; for(int i = 1; i &lt;= n; i++) &#123; if(in[i] == 0) &#123; q.push(i); vis[i] = 1; &#125; &#125; while(!q.empty()) &#123; int u = q.front(); q.pop(); in[to[u]]--; if(in[to[u]] == 0) &#123; vis[to[u]] = 1; q.push(to[u]); &#125; &#125; int ans = maxn; for(int i = 1; i &lt;= n; i++) &#123; int tmp = maxn; if(!vis[i]) &#123; int j = to[i]; tmp = 0; while(!vis[j]) &#123; tmp++; vis[j] = 1; j = to[j]; &#125; &#125; ans = min(ans, tmp); &#125; cout &lt;&lt; ans;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1965 转圈游戏]]></title>
      <url>%2F2016%2F10%2F30%2FP1965-%E8%BD%AC%E5%9C%88%E6%B8%B8%E6%88%8F%2F</url>
      <content type="text"><![CDATA[很容易可以得到，答案应该是（x+m*10^k)%n 很显然，用O（n）一定会卡爆，所以用快速幂来算，或者找一下循环节也是可以的。 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int Fact(int x, int n, int mod) &#123; int ans = 1; while(n) &#123; if(n &amp; 1) ans = ans * x % mod; x = x * x % mod; n &gt;&gt;= 1; &#125; return ans;&#125;int main(int argc, char const *argv[])&#123; int n, m, k, x; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; x; cout &lt;&lt; ((x%n) + ((m%n)*Fact(10, k, n))%n)%n; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1371 NOI元丹]]></title>
      <url>%2F2016%2F10%2F29%2FP1371-NOI%E5%85%83%E4%B8%B9%2F</url>
      <content type="text"><![CDATA[luogu月赛的题 本来想爆搜，但是经过ly大佬的点拨，明白这是一个dp。 我们定义dp[n]为从n开始的可行串的数目，具体如下：如果n为‘I’，则是从n开始有多少个I，如果n为’O’，既是从n开始有多少个’OI‘，如果n为’N‘，则是从n开始有多少个’NOI’ 我们已经定义了状态，那么怎么转移呢？我们以n是‘N’为例，’NOI’的数目可以分为两部分：1）包括n， 2）不包括n。所以，我们可以这样计算dp[n]，找到从n开始的第一个N和O，把两个字符的dp值相加，就得到了答案。 我们从后往前推，可以估算一下复杂度：状态数O(n),转移O(n)，总的复杂度是O(n^2)。 对于每一个字串，我们都可以计算出其结果。所以下面的问题就是怎么去插。 首先，我们可以用链表来存储这一个字串，来优化一下常数； 第二，我们可以证明，对于N，把他插到最前面，一定是最优的，对于I，把他插到最后面，一定是最优的， 但是对于O我们还没有想出比较好的插法，目前的想法是去枚举。 这样在O(n2)的时间内，我们就可以算出。 ly大佬用这个算法得了60分。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200;int n;string str;int cnt;int table[maxn];int ans[maxn];int tmp[maxn];//==============int value[maxn];int count() &#123; int pos = n - 1; int i, j; if(tmp[n] == 2) value[n] = 1; else value[n] = 0; while(pos != -1) &#123; if(tmp[pos] == 2) &#123; for(i = pos+1; i &lt;= n; i++) &#123; if(tmp[i] == tmp[pos]) break; &#125; value[pos] = value[i] + 1; &#125; else if(tmp[pos] == 1) &#123; for(i = pos+1; i &lt;= n; i++) &#123; if(tmp[i] == 1) break; &#125; for(j = pos+1; j &lt;= n; j++) &#123; if(tmp[j] == 2) break; &#125; value[pos] = value[i] + value[j]; &#125; else if(tmp[pos] == 0) &#123; for(i = pos+1; i &lt;= n; i++) &#123; if(tmp[i] == 1) break; &#125; for(j = pos+1; j &lt;= n; j++) &#123; if(tmp[j] == 0) break; &#125; value[pos] = value[i] + value[j]; &#125; pos--; &#125; for(i = 0; i &lt; n; i++) &#123; if(tmp[i] == 0) break; &#125; return value[i];&#125;//==============int main(int argc, char const *argv[])&#123; cin &gt;&gt; n &gt;&gt; str; memset(value, 0, sizeof(value)); for(int i = 0; i &lt;= n;i++) &#123; if(str[i] == &apos;N&apos;) table[i] = 0; else if(str[i] == &apos;O&apos;) table[i] = 1; else if(str[i] == &apos;I&apos;) table[i] = 2; &#125; tmp[0] = 0; for(int i = 1; i &lt;= n+1;i++) tmp[i] = table[i-1]; int a = count(); for(int i = 1; i &lt;= n+1;i++) tmp[i] = table[i]; tmp[n+1] = 2; int b = count(); int i, k; for(k = n; k &gt;= 0; k--) if(table[k] == &apos;1&apos;) break; for(i = 0;i &lt;= k; i++) &#123; tmp[i] = table[i]; &#125; tmp[i] = 1; for(;i&lt;=n;i++) &#123; tmp[k] = table[k-1]; &#125; int c = count(); cout &lt;&lt; max(max(a, b), c); return 0;&#125;/*void dfs(int choose, int pos) &#123; if(choose == n)&#123; cnt++;return;&#125; if(pos == str.size()) return; for(int i = pos; i &lt;= str.size(); i++) &#123; if(tmp[i] == choose) &#123; ans[choose] = i; dfs(choose + 1, i+1);&#125; &#125;&#125;int count() &#123; cnt = 0; dfs(0, 0); return cnt;&#125;*/ /*cin &gt;&gt; n &gt;&gt; str; int maxx = 0; for(int i = 0; i &lt;= str.size();i++) &#123; if(str[i] == &apos;N&apos;) table[i] = 0; else if(str[i] == &apos;O&apos;) table[i] = 1; else if(str[i] == &apos;I&apos;) table[i] = 2; &#125; int k; for(int i = 0; i &lt; 3; i++) &#123; for(int j = 0; j &lt;= n; j++) &#123; for(k = 0; k &lt;= j; k++) &#123; tmp[k] = table[k]; &#125; tmp[k] = i; for(;k&lt;=n;k++) &#123; tmp[k] = table[k-1]; &#125; maxx = max(maxx, count()); &#125; &#125; cout &lt;&lt; maxx;*/ 54 NONOONIONIINIOOONONIIIINNONOINOONNOOIIOIOIOIINONNNIOON 10 ONNINNONNI]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P2409 Y的积木]]></title>
      <url>%2F2016%2F10%2F29%2FP2409-Y%E7%9A%84%E7%A7%AF%E6%9C%A8%2F</url>
      <content type="text"><![CDATA[luogu月赛 暴力dfs，估计过不了几个点，大概也就得30分左右? 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 55;int jimu[maxn][maxn];int cnt = 0;int ans[maxn];int n, k;int aa[100];int mi[maxn];//------------void dfs(int picked) &#123; if(picked == n) &#123; int sum = 0; for(int i = 0; i &lt; n; i++) sum += ans[i]; aa[cnt++] = sum; return; &#125; int now = picked; for(int i = 0; i &lt; mi[now]; i++) &#123; ans[now] = jimu[now][i]; dfs(now+1); &#125;&#125;//------------int main() &#123; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; mi[i]; for (int j = 0; j &lt; mi[i]; ++j) &#123; cin &gt;&gt; jimu[i][j]; &#125; sort(jimu[i], jimu[i]+mi[i]); &#125; dfs(0); sort(aa, aa+cnt); for (int i = 0; i &lt; k; ++i) &#123; cout &lt;&lt; aa[i] &lt;&lt; &apos; &apos;; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对拍]]></title>
      <url>%2F2016%2F10%2F29%2F%E5%AF%B9%E6%8B%8D%2F</url>
      <content type="text"><![CDATA[写了一个对拍。用于测试跳马的程序 首先是随机数生成程序： 123456789101112131415161718//rand.cpp#include &lt;bits/stdc++.h&gt;#define random(x) (rand() % x)using namespace std;int n, m;int main()&#123; srand(time(NULL)); n = random(200); m = random(200); int x = random(n); int y = random(m); while(!x || !y) &#123; int x = random(n); int y = random(m); &#125; cout &lt;&lt; n &lt;&lt;&apos; &apos; &lt;&lt; m &lt;&lt; &apos; &apos; &lt;&lt; x &lt;&lt; &apos; &apos; &lt;&lt; y &lt;&lt; &apos; &apos;; return 0;&#125; 然后是bat脚本 1234567891011121314@echo off:looprand&gt;in.txtmy&lt;in.txt&gt;myout.txtstd&lt;in.txt&gt;stdout.txtfc myout.txt stdout.txtif not errorlevel 1 goto looppausegoto loop 效果还不错！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1017 进制转换]]></title>
      <url>%2F2016%2F10%2F29%2FP1017-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[模拟水题，直接上代码 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100000;int main() &#123; int n, r; cin &gt;&gt; n &gt;&gt; r; int ans[maxn]; int tmp = n; int pos = 0; while(tmp != 0) &#123; int cheng = tmp / r; int yu = tmp - r * cheng; if(yu &lt; 0) cheng++; ans[pos++] = tmp - r * cheng; tmp = cheng; &#125; pos--; cout &lt;&lt; n &lt;&lt; &apos;=&apos;; for(int i = pos; i &gt;= 0; i--) &#123; if(ans[i] &gt;= 10) &#123; cout &lt;&lt; (char)(&apos;A&apos; + ans[i] - 10); &#125; else cout &lt;&lt; ans[i]; &#125; cout &lt;&lt; &quot;(base&quot; &lt;&lt; r &lt;&lt; &apos;)&apos;; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1092 虫食算 NOIP2002]]></title>
      <url>%2F2016%2F10%2F29%2FP1092-%E8%99%AB%E9%A3%9F%E7%AE%97-NOIP2002%2F</url>
      <content type="text"><![CDATA[为了测试stl 30分的暴力写法。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 11;int n;char plus1[maxn], plus2[maxn], answer[maxn];int ans[maxn];//---------------bool ok() &#123; int tmp[maxn]; for (int i = n-1; i &gt;= 0; --i) &#123; tmp[i] = ans[plus1[i] - &apos;A&apos;]+ ans[plus2[i] - &apos;A&apos;]; &#125; for (int i = n-1; i &gt;= 0; --i) &#123; if(tmp[i] &gt;= n) &#123; tmp[i - 1] += tmp[i] / n; tmp[i] %= n; &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; if(tmp[i] != ans[answer[i]-&apos;A&apos;]) return false; &#125; return true;&#125;//---------------int main() &#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; plus1[i]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; plus2[i]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; answer[i]; for (int i = 0; i &lt; n; ++i) &#123; ans[i] = i; &#125; sort(ans, ans+n); do&#123; if(ok()) break; &#125; while(next_permutation(ans, ans+n)); for (int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; ans[i] &lt;&lt; &apos; &apos;; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1003 铺地毯]]></title>
      <url>%2F2016%2F10%2F29%2FP1003-%E9%93%BA%E5%9C%B0%E6%AF%AF%2F</url>
      <content type="text"><![CDATA[水题 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10005;int n;int x, y, i;struct Carp&#123; int a, b, g, k;&#125; cars[maxn];bool ok() &#123; int left = cars[i].a; int right = cars[i].a + cars[i].g; int up = cars[i].b + cars[i].k; int down = cars[i].b; if(left &lt;= x &amp;&amp; right &gt;= x &amp;&amp; up &gt;= y &amp;&amp; down &lt;= y) &#123; return true; &#125; return false;&#125;int main(int argc, char const *argv[])&#123; cin &gt;&gt; n; for (i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; cars[i].a &gt;&gt; cars[i].b &gt;&gt; cars[i].g &gt;&gt; cars[i].k; &#125; cin &gt;&gt; x &gt;&gt; y; for(i = n; i &gt;= 1; i--) &#123; if(ok()) break; &#125; if(i) cout &lt;&lt; i; else cout &lt;&lt; -1; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1443 马的遍历]]></title>
      <url>%2F2016%2F10%2F29%2FP1443-%E9%A9%AC%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
      <content type="text"><![CDATA[同样是一个bfs水题。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; St;St start;queue&lt;St&gt; sts;map&lt;St, int&gt; dist;int n, m, x, y;const int dx[] = &#123;-1, 1, 2, 2, 1, -1, -2, -2&#125;;const int dy[] = &#123;2, 2, 1, -1, -2, -2, -1, 1&#125;;//-----------------void bfs() &#123; sts.push(start); while(!sts.empty()) &#123; St now = sts.front(); sts.pop(); int nowx = now.first; int nowy = now.second; for(int i = 0; i &lt; 8; i++) &#123; int newx = nowx + dx[i]; int newy = nowy + dy[i]; if(newx &gt; 0 &amp;&amp; newx &lt;= n &amp;&amp; newy &gt; 0 &amp;&amp; newy &lt;= m) &#123; St neww(newx, newy); if(dist.count(neww)) continue; dist[neww] = dist[now] + 1; sts.push(neww); &#125; &#125; &#125;&#125;void output() &#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; if(i==x&amp;&amp;j==y) printf(&quot;%-5d&quot;, 0); else &#123; St now(i, j); int d = dist[now]; if(d) printf(&quot;%-5d&quot;, d); else printf(&quot;%-5d&quot;, -1); &#125; &#125; cout &lt;&lt; endl; &#125;&#125;//-----------------int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y; start.first = x; start.second = y; bfs(); output(); return 0;&#125; 不过莫名其妙不知道为什么最后一个点没有过]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1032 字串变换]]></title>
      <url>%2F2016%2F10%2F29%2FP1032-%E5%AD%97%E4%B8%B2%E5%8F%98%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[最近在练习bfs，看到了02年提高组的这个题，顿时来了兴致，联想到前一阵子的八数码问题，具体就是使用一个字符串来存储状态，把他存储到一个图中，然后开始bfs，如果10步之内无法完成就剪枝，同时使用哈希来优化判重。下面贴上代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000;string A, B, from[maxn], to[maxn];string state[maxn];int dist[maxn];int n = 3;set&lt;int&gt; vis;void init_lookup_table() &#123; vis.clear();&#125;int try_to_insert(string s) &#123; int v = 0; for(int i = 0; i &lt; s.length(); i++) v += s[i] - 65; if(vis.count(v)) return 0; vis.insert(v); return 1;&#125;int bfs() &#123; init_lookup_table(); int front = 1, rear = 2; while(front &lt; rear) &#123; string&amp; s = state[front]; if(s == B) return front; for(int i = 0; i &lt; n; i++) &#123; int pos = 0; while(p = s.find(from[i], pos)) &#123; string w; w = s.substr(0, p) + to[i] + s.substr(p+to[i].length(), s.length()); dist[rear] = dist[front] + 1; if(try_to_insert(w)) rear++; pos = p; &#125; &#125; front++; &#125;&#125;int main() &#123; cin &gt;&gt; A &gt;&gt; B; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; from[i] &gt;&gt; to[i]; &#125; int ans = bfs(); cout &lt;&lt; dist[ans];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[P1379 八数码问题]]></title>
      <url>%2F2016%2F10%2F29%2FP1379-%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[aoapc上的八数码问题，在luogu上也有类似的题，p1379，经典题目，lrj给出了一个算法，同时给出了三种判重的方法。本来想用std::queue改写一下，但是出了各种问题，只好抄代码ac掉这道题了。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;typedef int State[9];const int maxstate = 1000000;State st[maxstate], goal;int dist[maxstate];set&lt;int&gt; vis;const int dx[] = &#123;-1, 1, 0, 0&#125;;const int dy[] = &#123;0, 0, -1, 1&#125;;void init_lookup_table() &#123;vis.clear();&#125;int try_to_insert(int s) &#123; int v = 0; for(int i = 0; i &lt; 9; i++) v = v*10+st[s][i]; if(vis.count(v)) return 0; vis.insert(v); return 1;&#125;int bfs() &#123; init_lookup_table(); int front = 1, rear = 2; while(front &lt; rear) &#123; State&amp; s = st[front]; if(memcmp(goal, s, sizeof(s)) == 0) return front; int z; for(z = 0; z &lt; 9; z++) if(!s[z]) break; int x = z/3; int y = z%3; for(int d = 0; d &lt; 4; d++) &#123; int newx = x + dx[d]; int newy = y + dy[d]; int newz = newx * 3 + newy; if(newx &gt;= 0 &amp;&amp; newy &lt; 3 &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; 3) &#123; State&amp; t = st[rear]; memcpy(&amp;t, &amp;s, sizeof(s)); t[newz] = 0; t[z] = s[newz]; dist[rear] = dist[front] + 1; if(try_to_insert(rear)) rear++; &#125; &#125; front++; &#125; return 0;&#125;int main() &#123;// for(int i = 0; i &lt; 9; i++) scanf(&quot;%d&quot;, &amp;st[1][i]); st[1][0] = 2;st[1][1] = 8;st[1][2] = 3;st[1][3] = 1; st[1][4] = 9;st[1][5] = 4;st[1][6] = 7;st[1][7] = 6; st[1][8] = 5; for(int i = 0; i &lt; 9; i++) scanf(&quot;%d&quot;, &amp;goal[i]); int ans = bfs(); if(ans &gt; 0) cout &lt;&lt; dist[ans]; else cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[About Me]]></title>
      <url>%2F2016%2F01%2F31%2FAbout-Me%2F</url>
      <content type="text"><![CDATA[Hello world! 关于我: 我来自济南市历城第二中学，是一只在弱校挣扎的蒟蒻OIer。 编辑器使用Atom+Vim，系统是ArchLinux+Mint。 关于这个博客: 本博客基于Hexo中的NexT主题搭建. 插件主要是标签云hexo-tag-cloud, 和\(Mathjax\)支援的强力渲染引擎hexo-renderer-kramed, 采用了\(Disqus\)作为评论系统. 感谢开源社区的贡献. 本博客在GitHub.org和Coding.net均有备份, 海外用户可以访问GitHub的版本, 国内用户可以访问Coding.net的版本. 我的联系方式: Email: unrealgengchen[at]gmail[dot]com QQ: 543249426 知乎: Konjac 欢迎各位dalao指导蒟蒻]]></content>
    </entry>

    
  
  
</search>
